{
  "transaction_info": {
    "hash": "0x16a3806192c8983581f1fb1abda0e0ee2bca51e3b8320bd65841c5a9979f6a26",
    "block_number": 22839949,
    "block_hash": "0xe54a904828e9cdd45dc0e8e5589aa877e1eb5d635bc3f775564f9cda5c301bf6",
    "position": 259,
    "total_gas_used": 431784
  },
  "call_tree": [
    {
      "trace_index": 0,
      "trace_address": [],
      "call_type": "call",
      "from": "0xf43e8c65956aef41f53b2be01845e01880897116",
      "to": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "gas": 545046,
      "gas_used": 431784,
      "input": "0xe11013dd000000000000000000000000f43e8c65956aef41f53b2be01845e018808971160000000000000000000000000000000000000000000000000000000000030d400000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000b7375706572627269646765000000000000000000000000000000000000000000",
      "function_signature": "bridgeETHTo(address,uint32,bytes)",
      "output": "0x",
      "subtraces": 2,
      "success": true
    },
    {
      "trace_index": 1,
      "trace_address": [
        0
      ],
      "call_type": "staticcall",
      "from": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "to": "0x0475cbcaebd9ce8afa5025828d5b98dfb67e059e",
      "value": 0,
      "value_eth": 0.0,
      "gas": 531332,
      "gas_used": 2347,
      "input": "0xb7947262",
      "function_signature": "isUpgrading()",
      "output": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "subtraces": 0,
      "success": true
    },
    {
      "trace_index": 2,
      "trace_address": [
        1
      ],
      "call_type": "delegatecall",
      "from": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "to": "0x0b09ba359a106c9ea3b181cbc5f394570c7d2a7a",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "gas": 523989,
      "gas_used": 419009,
      "input": "0xe11013dd000000000000000000000000f43e8c65956aef41f53b2be01845e018808971160000000000000000000000000000000000000000000000000000000000030d400000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000b7375706572627269646765000000000000000000000000000000000000000000",
      "function_signature": "bridgeETHTo(address,uint32,bytes)",
      "output": "0x",
      "subtraces": 1,
      "success": true
    },
    {
      "trace_index": 3,
      "trace_address": [
        1,
        0
      ],
      "call_type": "call",
      "from": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "to": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "gas": 494282,
      "gas_used": 397042,
      "input": "0x3dbb202b000000000000000000000000420000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000030d4000000000000000000000000000000000000000000000000000000000000000c41635f5fd000000000000000000000000f43e8c65956aef41f53b2be01845e01880897116000000000000000000000000f43e8c65956aef41f53b2be01845e018808971160000000000000000000000000000000000000000000000000570a9ec4ff400000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000b737570657262726964676500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "function_signature": "sendMessage(address,bytes,uint32)",
      "output": "0x",
      "subtraces": 2,
      "success": true
    },
    {
      "trace_index": 4,
      "trace_address": [
        1,
        0,
        0
      ],
      "call_type": "staticcall",
      "from": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "to": "0x8efb6b5c4767b09dc9aa6af4eaa89f749522bae2",
      "value": 0,
      "value_eth": 0.0,
      "gas": 479367,
      "gas_used": 3213,
      "input": "0xbf40fac10000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a4f564d5f4c3143726f7373446f6d61696e4d657373656e676572000000000000",
      "function_signature": "getAddress(string)",
      "output": "0x0000000000000000000000005d5a095665886119693f0b41d8dfee78da033e8b",
      "subtraces": 0,
      "success": true
    },
    {
      "trace_index": 5,
      "trace_address": [
        1,
        0,
        1
      ],
      "call_type": "delegatecall",
      "from": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "to": "0x5d5a095665886119693f0b41d8dfee78da033e8b",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "gas": 473239,
      "gas_used": 383408,
      "input": "0x3dbb202b000000000000000000000000420000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000030d4000000000000000000000000000000000000000000000000000000000000000c41635f5fd000000000000000000000000f43e8c65956aef41f53b2be01845e01880897116000000000000000000000000f43e8c65956aef41f53b2be01845e018808971160000000000000000000000000000000000000000000000000570a9ec4ff400000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000b737570657262726964676500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "function_signature": "sendMessage(address,bytes,uint32)",
      "output": "0x",
      "subtraces": 1,
      "success": true
    },
    {
      "trace_index": 6,
      "trace_address": [
        1,
        0,
        1,
        0
      ],
      "call_type": "call",
      "from": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "to": "0x49048044d57e1c92a77f79988d21fa8faf74e97e",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "gas": 446088,
      "gas_used": 354096,
      "input": "0xe9e05c4200000000000000000000000042000000000000000000000000000000000000070000000000000000000000000000000000000000000000000570a9ec4ff40000000000000000000000000000000000000000000000000000000000000007e176000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001c4d764ad0b000100000000000000000000000000000000000000000000000000000006a1f70000000000000000000000003154cf16ccdb4c6d922629664174b904d80f2c3500000000000000000000000042000000000000000000000000000000000000100000000000000000000000000000000000000000000000000570a9ec4ff400000000000000000000000000000000000000000000000000000000000000030d4000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000c41635f5fd000000000000000000000000f43e8c65956aef41f53b2be01845e01880897116000000000000000000000000f43e8c65956aef41f53b2be01845e018808971160000000000000000000000000000000000000000000000000570a9ec4ff400000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000b73757065726272696467650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "function_signature": "depositTransaction(address,uint256,uint64,bool,bytes)",
      "output": "0x",
      "subtraces": 1,
      "success": true
    },
    {
      "trace_index": 7,
      "trace_address": [
        1,
        0,
        1,
        0,
        0
      ],
      "call_type": "delegatecall",
      "from": "0x49048044d57e1c92a77f79988d21fa8faf74e97e",
      "to": "0xb443da3e07052204a02d630a8933dac05a0d6fb4",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "gas": 434133,
      "gas_used": 348996,
      "input": "0xe9e05c4200000000000000000000000042000000000000000000000000000000000000070000000000000000000000000000000000000000000000000570a9ec4ff40000000000000000000000000000000000000000000000000000000000000007e176000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001c4d764ad0b000100000000000000000000000000000000000000000000000000000006a1f70000000000000000000000003154cf16ccdb4c6d922629664174b904d80f2c3500000000000000000000000042000000000000000000000000000000000000100000000000000000000000000000000000000000000000000570a9ec4ff400000000000000000000000000000000000000000000000000000000000000030d4000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000c41635f5fd000000000000000000000000f43e8c65956aef41f53b2be01845e01880897116000000000000000000000000f43e8c65956aef41f53b2be01845e018808971160000000000000000000000000000000000000000000000000570a9ec4ff400000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000b73757065726272696467650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "function_signature": "depositTransaction(address,uint256,uint64,bool,bytes)",
      "output": "0x",
      "subtraces": 1,
      "success": true
    },
    {
      "trace_index": 8,
      "trace_address": [
        1,
        0,
        1,
        0,
        0,
        0
      ],
      "call_type": "staticcall",
      "from": "0x49048044d57e1c92a77f79988d21fa8faf74e97e",
      "to": "0x73a79fab69143498ed3712e519a88a918e1f4072",
      "value": 0,
      "value_eth": 0.0,
      "gas": 409211,
      "gas_used": 7969,
      "input": "0xcc731b02",
      "function_signature": "resourceConfig()",
      "output": "0x0000000000000000000000000000000000000000000000000000000001312d00000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000003b9aca0000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000ffffffffffffffffffffffffffffffff",
      "subtraces": 1,
      "success": true
    },
    {
      "trace_index": 9,
      "trace_address": [
        1,
        0,
        1,
        0,
        0,
        0,
        0
      ],
      "call_type": "delegatecall",
      "from": "0x73a79fab69143498ed3712e519a88a918e1f4072",
      "to": "0x78ffe9209dff6fe1c9b6f3efdf996bee60346d0e",
      "value": 0,
      "value_eth": 0.0,
      "gas": 397950,
      "gas_used": 2962,
      "input": "0xcc731b02",
      "function_signature": "resourceConfig()",
      "output": "0x0000000000000000000000000000000000000000000000000000000001312d00000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000003b9aca0000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000ffffffffffffffffffffffffffffffff",
      "subtraces": 0,
      "success": true
    }
  ],
  "addresses_involved": [
    "0x49048044d57e1c92a77f79988d21fa8faf74e97e",
    "0x0b09ba359a106c9ea3b181cbc5f394570c7d2a7a",
    "0x5d5a095665886119693f0b41d8dfee78da033e8b",
    "0xb443da3e07052204a02d630a8933dac05a0d6fb4",
    "0x78ffe9209dff6fe1c9b6f3efdf996bee60346d0e",
    "0xf43e8c65956aef41f53b2be01845e01880897116",
    "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
    "0x8efb6b5c4767b09dc9aa6af4eaa89f749522bae2",
    "0x73a79fab69143498ed3712e519a88a918e1f4072",
    "0x0475cbcaebd9ce8afa5025828d5b98dfb67e059e",
    "0x3154cf16ccdb4c6d922629664174b904d80f2c35"
  ],
  "value_transfers": [
    {
      "from": "0xf43e8c65956aef41f53b2be01845e01880897116",
      "to": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "trace_index": 0
    },
    {
      "from": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "to": "0x0b09ba359a106c9ea3b181cbc5f394570c7d2a7a",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "trace_index": 2
    },
    {
      "from": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "to": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "trace_index": 3
    },
    {
      "from": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "to": "0x5d5a095665886119693f0b41d8dfee78da033e8b",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "trace_index": 5
    },
    {
      "from": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "to": "0x49048044d57e1c92a77f79988d21fa8faf74e97e",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "trace_index": 6
    },
    {
      "from": "0x49048044d57e1c92a77f79988d21fa8faf74e97e",
      "to": "0xb443da3e07052204a02d630a8933dac05a0d6fb4",
      "value": 392000000000000000,
      "value_eth": 0.392,
      "trace_index": 7
    }
  ],
  "gas_analysis": {
    "total_gas_used": 2350826,
    "gas_by_call": [
      {
        "trace_index": 0,
        "gas_used": 431784,
        "call_type": "call",
        "function": "bridgeETHTo(address,uint32,bytes)"
      },
      {
        "trace_index": 1,
        "gas_used": 2347,
        "call_type": "staticcall",
        "function": "isUpgrading()"
      },
      {
        "trace_index": 2,
        "gas_used": 419009,
        "call_type": "delegatecall",
        "function": "bridgeETHTo(address,uint32,bytes)"
      },
      {
        "trace_index": 3,
        "gas_used": 397042,
        "call_type": "call",
        "function": "sendMessage(address,bytes,uint32)"
      },
      {
        "trace_index": 4,
        "gas_used": 3213,
        "call_type": "staticcall",
        "function": "getAddress(string)"
      },
      {
        "trace_index": 5,
        "gas_used": 383408,
        "call_type": "delegatecall",
        "function": "sendMessage(address,bytes,uint32)"
      },
      {
        "trace_index": 6,
        "gas_used": 354096,
        "call_type": "call",
        "function": "depositTransaction(address,uint256,uint64,bool,bytes)"
      },
      {
        "trace_index": 7,
        "gas_used": 348996,
        "call_type": "delegatecall",
        "function": "depositTransaction(address,uint256,uint64,bool,bytes)"
      },
      {
        "trace_index": 8,
        "gas_used": 7969,
        "call_type": "staticcall",
        "function": "resourceConfig()"
      },
      {
        "trace_index": 9,
        "gas_used": 2962,
        "call_type": "delegatecall",
        "function": "resourceConfig()"
      }
    ]
  },
  "function_calls": [
    {
      "trace_index": 0,
      "function": "bridgeETHTo(address,uint32,bytes)",
      "from": "0xf43e8c65956aef41f53b2be01845e01880897116",
      "to": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "gas_used": 431784
    },
    {
      "trace_index": 1,
      "function": "isUpgrading()",
      "from": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "to": "0x0475cbcaebd9ce8afa5025828d5b98dfb67e059e",
      "gas_used": 2347
    },
    {
      "trace_index": 2,
      "function": "bridgeETHTo(address,uint32,bytes)",
      "from": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "to": "0x0b09ba359a106c9ea3b181cbc5f394570c7d2a7a",
      "gas_used": 419009
    },
    {
      "trace_index": 3,
      "function": "sendMessage(address,bytes,uint32)",
      "from": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "to": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "gas_used": 397042
    },
    {
      "trace_index": 4,
      "function": "getAddress(string)",
      "from": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "to": "0x8efb6b5c4767b09dc9aa6af4eaa89f749522bae2",
      "gas_used": 3213
    },
    {
      "trace_index": 5,
      "function": "sendMessage(address,bytes,uint32)",
      "from": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "to": "0x5d5a095665886119693f0b41d8dfee78da033e8b",
      "gas_used": 383408
    },
    {
      "trace_index": 6,
      "function": "depositTransaction(address,uint256,uint64,bool,bytes)",
      "from": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "to": "0x49048044d57e1c92a77f79988d21fa8faf74e97e",
      "gas_used": 354096
    },
    {
      "trace_index": 7,
      "function": "depositTransaction(address,uint256,uint64,bool,bytes)",
      "from": "0x49048044d57e1c92a77f79988d21fa8faf74e97e",
      "to": "0xb443da3e07052204a02d630a8933dac05a0d6fb4",
      "gas_used": 348996
    },
    {
      "trace_index": 8,
      "function": "resourceConfig()",
      "from": "0x49048044d57e1c92a77f79988d21fa8faf74e97e",
      "to": "0x73a79fab69143498ed3712e519a88a918e1f4072",
      "gas_used": 7969
    },
    {
      "trace_index": 9,
      "function": "resourceConfig()",
      "from": "0x73a79fab69143498ed3712e519a88a918e1f4072",
      "to": "0x78ffe9209dff6fe1c9b6f3efdf996bee60346d0e",
      "gas_used": 2962
    }
  ],
  "contract_info": {
    "0x49048044d57e1c92a77f79988d21fa8faf74e97e": {
      "address": "0x49048044d57e1c92a77f79988d21fa8faf74e97e",
      "has_source_code": true,
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/optimism/packages/contracts-bedrock/contracts/universal/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Proxy\\n * @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\\n *         if the caller is address(0), meaning that the call originated from an off-chain\\n *         simulation.\\n */\\ncontract Proxy {\\n    /**\\n     * @notice The storage slot that holds the address of the implementation.\\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n     */\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @notice The storage slot that holds the address of the owner.\\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n     */\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @notice An event that is emitted each time the implementation is changed. This event is part\\n     *         of the EIP-1967 specification.\\n     *\\n     * @param implementation The address of the implementation contract\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\\n     *         EIP-1967 specification.\\n     *\\n     * @param previousAdmin The previous owner of the contract\\n     * @param newAdmin      The new owner of the contract\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\\n     *         eth_call to interact with this proxy without needing to use low-level storage\\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\\n     *         normal EVM execution.\\n     */\\n    modifier proxyCallIfNotAdmin() {\\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\\n     *         implementation is not possible.\\n     *\\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\\n     *               transparent proxy interface.\\n     */\\n    constructor(address _admin) {\\n        _changeAdmin(_admin);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /**\\n     * @notice Set the implementation contract address. The code at the given address will execute\\n     *         when this contract is called.\\n     *\\n     * @param _implementation Address of the implementation contract.\\n     */\\n    function upgradeTo(address _implementation) public virtual proxyCallIfNotAdmin {\\n        _setImplementation(_implementation);\\n    }\\n\\n    /**\\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\\n     *         atomic execution of initialization-based upgrades.\\n     *\\n     * @param _implementation Address of the implementation contract.\\n     * @param _data           Calldata to delegatecall the new implementation with.\\n     */\\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\\n        public\\n        payable\\n        virtual\\n        proxyCallIfNotAdmin\\n        returns (bytes memory)\\n    {\\n        _setImplementation(_implementation);\\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\\n        require(success, \\\"Proxy: delegatecall to new implementation contract failed\\\");\\n        return returndata;\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\\n     *\\n     * @param _admin New owner of the proxy contract.\\n     */\\n    function changeAdmin(address _admin) public virtual proxyCallIfNotAdmin {\\n        _changeAdmin(_admin);\\n    }\\n\\n    /**\\n     * @notice Gets the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function admin() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function implementation() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**\\n     * @notice Sets the implementation address.\\n     *\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n        emit Upgraded(_implementation);\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract.\\n     *\\n     * @param _admin New owner of the proxy contract.\\n     */\\n    function _changeAdmin(address _admin) internal {\\n        address previous = _getAdmin();\\n        assembly {\\n            sstore(OWNER_KEY, _admin)\\n        }\\n        emit AdminChanged(previous, _admin);\\n    }\\n\\n    /**\\n     * @notice Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall() internal {\\n        address impl = _getImplementation();\\n        require(impl != address(0), \\\"Proxy: implementation not initialized\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        address impl;\\n        assembly {\\n            impl := sload(IMPLEMENTATION_KEY)\\n        }\\n        return impl;\\n    }\\n\\n    /**\\n     * @notice Queries the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@base-contracts/=lib/base-contracts/\",\r\n      \"@eth-optimism-bedrock/=lib/optimism/packages/contracts-bedrock/\",\r\n      \"@gnosissafe/contracts/=lib/safe-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"base-contracts/=lib/base-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"optimism/=lib/optimism/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "contract_name": "Proxy",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "optimization_used": "1",
      "runs": "999999",
      "constructor_arguments": "",
      "evm_version": "Default",
      "library": "",
      "license_type": "",
      "proxy": "1",
      "implementation": "0xb443da3e07052204a02d630a8933dac05a0d6fb4",
      "bytecode": null
    },
    "0x0b09ba359a106c9ea3b181cbc5f394570c7d2a7a": {
      "address": "0x0b09ba359a106c9ea3b181cbc5f394570c7d2a7a",
      "has_source_code": true,
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/L1/L1StandardBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n// Contracts\\nimport { StandardBridge } from \\\"src/universal/StandardBridge.sol\\\";\\n\\n// Libraries\\nimport { Predeploys } from \\\"src/libraries/Predeploys.sol\\\";\\n\\n// Interfaces\\nimport { ISemver } from \\\"interfaces/universal/ISemver.sol\\\";\\nimport { ICrossDomainMessenger } from \\\"interfaces/universal/ICrossDomainMessenger.sol\\\";\\nimport { ISuperchainConfig } from \\\"interfaces/L1/ISuperchainConfig.sol\\\";\\n\\n/// @custom:proxied true\\n/// @title L1StandardBridge\\n/// @notice The L1StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\\n///         L2. In the case that an ERC20 token is native to L1, it will be escrowed within this\\n///         contract. If the ERC20 token is native to L2, it will be burnt. Before Bedrock, ETH was\\n///         stored within this contract. After Bedrock, ETH is instead stored inside the\\n///         OptimismPortal contract.\\n///         NOTE: this contract is not intended to support all variations of ERC20 tokens. Examples\\n///         of some token types that may not be properly supported by this contract include, but are\\n///         not limited to: tokens with transfer fees, rebasing tokens, and tokens with blocklists.\\ncontract L1StandardBridge is StandardBridge, ISemver {\\n    /// @custom:legacy\\n    /// @notice Emitted whenever a deposit of ETH from L1 into L2 is initiated.\\n    /// @param from      Address of the depositor.\\n    /// @param to        Address of the recipient on L2.\\n    /// @param amount    Amount of ETH deposited.\\n    /// @param extraData Extra data attached to the deposit.\\n    event ETHDepositInitiated(address indexed from, address indexed to, uint256 amount, bytes extraData);\\n\\n    /// @custom:legacy\\n    /// @notice Emitted whenever a withdrawal of ETH from L2 to L1 is finalized.\\n    /// @param from      Address of the withdrawer.\\n    /// @param to        Address of the recipient on L1.\\n    /// @param amount    Amount of ETH withdrawn.\\n    /// @param extraData Extra data attached to the withdrawal.\\n    event ETHWithdrawalFinalized(address indexed from, address indexed to, uint256 amount, bytes extraData);\\n\\n    /// @custom:legacy\\n    /// @notice Emitted whenever an ERC20 deposit is initiated.\\n    /// @param l1Token   Address of the token on L1.\\n    /// @param l2Token   Address of the corresponding token on L2.\\n    /// @param from      Address of the depositor.\\n    /// @param to        Address of the recipient on L2.\\n    /// @param amount    Amount of the ERC20 deposited.\\n    /// @param extraData Extra data attached to the deposit.\\n    event ERC20DepositInitiated(\\n        address indexed l1Token,\\n        address indexed l2Token,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /// @custom:legacy\\n    /// @notice Emitted whenever an ERC20 withdrawal is finalized.\\n    /// @param l1Token   Address of the token on L1.\\n    /// @param l2Token   Address of the corresponding token on L2.\\n    /// @param from      Address of the withdrawer.\\n    /// @param to        Address of the recipient on L1.\\n    /// @param amount    Amount of the ERC20 withdrawn.\\n    /// @param extraData Extra data attached to the withdrawal.\\n    event ERC20WithdrawalFinalized(\\n        address indexed l1Token,\\n        address indexed l2Token,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /// @notice Semantic version.\\n    /// @custom:semver 2.3.0\\n    string public constant version = \\\"2.3.0\\\";\\n\\n    /// @notice Address of the SuperchainConfig contract.\\n    ISuperchainConfig public superchainConfig;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer systemConfig\\n    /// @notice Spacer taking up the legacy `systemConfig` slot.\\n    address private spacer_51_0_20;\\n\\n    /// @notice Constructs the L1StandardBridge contract.\\n    constructor() StandardBridge() {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice Initializer.\\n    /// @param _messenger        Contract for the CrossDomainMessenger on this network.\\n    /// @param _superchainConfig Contract for the SuperchainConfig on this network.\\n    function initialize(ICrossDomainMessenger _messenger, ISuperchainConfig _superchainConfig) external initializer {\\n        superchainConfig = _superchainConfig;\\n        __StandardBridge_init({\\n            _messenger: _messenger,\\n            _otherBridge: StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE))\\n        });\\n    }\\n\\n    /// @inheritdoc StandardBridge\\n    function paused() public view override returns (bool) {\\n        return superchainConfig.paused();\\n    }\\n\\n    /// @notice Allows EOAs to bridge ETH by sending directly to the bridge.\\n    receive() external payable override onlyEOA {\\n        _initiateETHDeposit(msg.sender, msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\\\"\\\"));\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Deposits some amount of ETH into the sender's account on L2.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    ///                     Data supplied here will not be used to execute any code on L2 and is\\n    ///                     only emitted as extra data for the convenience of off-chain tooling.\\n    function depositETH(uint32 _minGasLimit, bytes calldata _extraData) external payable onlyEOA {\\n        _initiateETHDeposit(msg.sender, msg.sender, _minGasLimit, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Deposits some amount of ETH into a target account on L2.\\n    ///         Note that if ETH is sent to a contract on L2 and the call fails, then that ETH will\\n    ///         be locked in the L2StandardBridge. ETH may be recoverable if the call can be\\n    ///         successfully replayed by increasing the amount of gas supplied to the call. If the\\n    ///         call will fail for any amount of gas, then the ETH will be locked permanently.\\n    /// @param _to          Address of the recipient on L2.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    ///                     Data supplied here will not be used to execute any code on L2 and is\\n    ///                     only emitted as extra data for the convenience of off-chain tooling.\\n    function depositETHTo(address _to, uint32 _minGasLimit, bytes calldata _extraData) external payable {\\n        _initiateETHDeposit(msg.sender, _to, _minGasLimit, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Deposits some amount of ERC20 tokens into the sender's account on L2.\\n    /// @param _l1Token     Address of the L1 token being deposited.\\n    /// @param _l2Token     Address of the corresponding token on L2.\\n    /// @param _amount      Amount of the ERC20 to deposit.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    ///                     Data supplied here will not be used to execute any code on L2 and is\\n    ///                     only emitted as extra data for the convenience of off-chain tooling.\\n    function depositERC20(\\n        address _l1Token,\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    )\\n        external\\n        virtual\\n        onlyEOA\\n    {\\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Deposits some amount of ERC20 tokens into a target account on L2.\\n    /// @param _l1Token     Address of the L1 token being deposited.\\n    /// @param _l2Token     Address of the corresponding token on L2.\\n    /// @param _to          Address of the recipient on L2.\\n    /// @param _amount      Amount of the ERC20 to deposit.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    ///                     Data supplied here will not be used to execute any code on L2 and is\\n    ///                     only emitted as extra data for the convenience of off-chain tooling.\\n    function depositERC20To(\\n        address _l1Token,\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    )\\n        external\\n        virtual\\n    {\\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Finalizes a withdrawal of ETH from L2.\\n    /// @param _from      Address of the withdrawer on L2.\\n    /// @param _to        Address of the recipient on L1.\\n    /// @param _amount    Amount of ETH to withdraw.\\n    /// @param _extraData Optional data forwarded from L2.\\n    function finalizeETHWithdrawal(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    )\\n        external\\n        payable\\n    {\\n        finalizeBridgeETH(_from, _to, _amount, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Finalizes a withdrawal of ERC20 tokens from L2.\\n    /// @param _l1Token   Address of the token on L1.\\n    /// @param _l2Token   Address of the corresponding token on L2.\\n    /// @param _from      Address of the withdrawer on L2.\\n    /// @param _to        Address of the recipient on L1.\\n    /// @param _amount    Amount of the ERC20 to withdraw.\\n    /// @param _extraData Optional data forwarded from L2.\\n    function finalizeERC20Withdrawal(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    )\\n        external\\n    {\\n        finalizeBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _extraData);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Retrieves the access of the corresponding L2 bridge contract.\\n    /// @return Address of the corresponding L2 bridge contract.\\n    function l2TokenBridge() external view returns (address) {\\n        return address(otherBridge);\\n    }\\n\\n    /// @notice Internal function for initiating an ETH deposit.\\n    /// @param _from        Address of the sender on L1.\\n    /// @param _to          Address of the recipient on L2.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    function _initiateETHDeposit(address _from, address _to, uint32 _minGasLimit, bytes memory _extraData) internal {\\n        _initiateBridgeETH(_from, _to, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /// @notice Internal function for initiating an ERC20 deposit.\\n    /// @param _l1Token     Address of the L1 token being deposited.\\n    /// @param _l2Token     Address of the corresponding token on L2.\\n    /// @param _from        Address of the sender on L1.\\n    /// @param _to          Address of the recipient on L2.\\n    /// @param _amount      Amount of the ERC20 to deposit.\\n    /// @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n    /// @param _extraData   Optional data to forward to L2.\\n    function _initiateERC20Deposit(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    )\\n        internal\\n    {\\n        _initiateBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /// @inheritdoc StandardBridge\\n    /// @notice Emits the legacy ETHDepositInitiated event followed by the ETHBridgeInitiated event.\\n    ///         This is necessary for backwards compatibility with the legacy bridge.\\n    function _emitETHBridgeInitiated(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        override\\n    {\\n        emit ETHDepositInitiated(_from, _to, _amount, _extraData);\\n        super._emitETHBridgeInitiated(_from, _to, _amount, _extraData);\\n    }\\n\\n    /// @inheritdoc StandardBridge\\n    /// @notice Emits the legacy ERC20DepositInitiated event followed by the ERC20BridgeInitiated\\n    ///         event. This is necessary for backwards compatibility with the legacy bridge.\\n    function _emitETHBridgeFinalized(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        override\\n    {\\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _extraData);\\n        super._emitETHBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n\\n    /// @inheritdoc StandardBridge\\n    /// @notice Emits the legacy ERC20WithdrawalFinalized event followed by the ERC20BridgeFinalized\\n    ///         event. This is necessary for backwards compatibility with the legacy bridge.\\n    function _emitERC20BridgeInitiated(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        override\\n    {\\n        emit ERC20DepositInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n        super._emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /// @inheritdoc StandardBridge\\n    /// @notice Emits the legacy ERC20WithdrawalFinalized event followed by the ERC20BridgeFinalized\\n    ///         event. This is necessary for backwards compatibility with the legacy bridge.\\n    function _emitERC20BridgeFinalized(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        override\\n    {\\n        emit ERC20WithdrawalFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n        super._emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/universal/StandardBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n// Contracts\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\n// Libraries\\nimport { ERC165Checker } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { SafeCall } from \\\"src/libraries/SafeCall.sol\\\";\\nimport { EOA } from \\\"src/libraries/EOA.sol\\\";\\n\\n// Interfaces\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IOptimismMintableERC20 } from \\\"interfaces/universal/IOptimismMintableERC20.sol\\\";\\nimport { ILegacyMintableERC20 } from \\\"interfaces/legacy/ILegacyMintableERC20.sol\\\";\\nimport { ICrossDomainMessenger } from \\\"interfaces/universal/ICrossDomainMessenger.sol\\\";\\n\\n/// @custom:upgradeable\\n/// @title StandardBridge\\n/// @notice StandardBridge is a base contract for the L1 and L2 standard ERC20 bridges. It handles\\n///         the core bridging logic, including escrowing tokens that are native to the local chain\\n///         and minting/burning tokens that are native to the remote chain.\\nabstract contract StandardBridge is Initializable {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice The L2 gas limit set when eth is depoisited using the receive() function.\\n    uint32 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 200_000;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer messenger\\n    /// @notice Spacer for backwards compatibility.\\n    bytes30 private spacer_0_2_30;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer l2TokenBridge\\n    /// @notice Spacer for backwards compatibility.\\n    address private spacer_1_0_20;\\n\\n    /// @notice Mapping that stores deposits for a given pair of local and remote tokens.\\n    mapping(address => mapping(address => uint256)) public deposits;\\n\\n    /// @notice Messenger contract on this domain.\\n    /// @custom:network-specific\\n    ICrossDomainMessenger public messenger;\\n\\n    /// @notice Corresponding bridge on the other domain.\\n    /// @custom:network-specific\\n    StandardBridge public otherBridge;\\n\\n    /// @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\\n    ///         A gap size of 45 was chosen here, so that the first slot used in a child contract\\n    ///         would be a multiple of 50.\\n    uint256[45] private __gap;\\n\\n    /// @notice Emitted when an ETH bridge is initiated to the other chain.\\n    /// @param from      Address of the sender.\\n    /// @param to        Address of the receiver.\\n    /// @param amount    Amount of ETH sent.\\n    /// @param extraData Extra data sent with the transaction.\\n    event ETHBridgeInitiated(address indexed from, address indexed to, uint256 amount, bytes extraData);\\n\\n    /// @notice Emitted when an ETH bridge is finalized on this chain.\\n    /// @param from      Address of the sender.\\n    /// @param to        Address of the receiver.\\n    /// @param amount    Amount of ETH sent.\\n    /// @param extraData Extra data sent with the transaction.\\n    event ETHBridgeFinalized(address indexed from, address indexed to, uint256 amount, bytes extraData);\\n\\n    /// @notice Emitted when an ERC20 bridge is initiated to the other chain.\\n    /// @param localToken  Address of the ERC20 on this chain.\\n    /// @param remoteToken Address of the ERC20 on the remote chain.\\n    /// @param from        Address of the sender.\\n    /// @param to          Address of the receiver.\\n    /// @param amount      Amount of the ERC20 sent.\\n    /// @param extraData   Extra data sent with the transaction.\\n    event ERC20BridgeInitiated(\\n        address indexed localToken,\\n        address indexed remoteToken,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /// @notice Emitted when an ERC20 bridge is finalized on this chain.\\n    /// @param localToken  Address of the ERC20 on this chain.\\n    /// @param remoteToken Address of the ERC20 on the remote chain.\\n    /// @param from        Address of the sender.\\n    /// @param to          Address of the receiver.\\n    /// @param amount      Amount of the ERC20 sent.\\n    /// @param extraData   Extra data sent with the transaction.\\n    event ERC20BridgeFinalized(\\n        address indexed localToken,\\n        address indexed remoteToken,\\n        address indexed from,\\n        address to,\\n        uint256 amount,\\n        bytes extraData\\n    );\\n\\n    /// @notice Only allow EOAs to call the functions. Note that this is not safe against contracts\\n    ///         calling code within their constructors, but also doesn't really matter since we're\\n    ///         just trying to prevent users accidentally depositing with smart contract wallets.\\n    modifier onlyEOA() {\\n        require(EOA.isSenderEOA(), \\\"StandardBridge: function can only be called from an EOA\\\");\\n        _;\\n    }\\n\\n    /// @notice Ensures that the caller is a cross-chain message from the other bridge.\\n    modifier onlyOtherBridge() {\\n        require(\\n            msg.sender == address(messenger) && messenger.xDomainMessageSender() == address(otherBridge),\\n            \\\"StandardBridge: function can only be called from the other bridge\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice Initializer.\\n    /// @param _messenger   Contract for CrossDomainMessenger on this network.\\n    /// @param _otherBridge Contract for the other StandardBridge contract.\\n    function __StandardBridge_init(\\n        ICrossDomainMessenger _messenger,\\n        StandardBridge _otherBridge\\n    )\\n        internal\\n        onlyInitializing\\n    {\\n        messenger = _messenger;\\n        otherBridge = _otherBridge;\\n    }\\n\\n    /// @notice Allows EOAs to bridge ETH by sending directly to the bridge.\\n    ///         Must be implemented by contracts that inherit.\\n    receive() external payable virtual;\\n\\n    /// @notice Getter for messenger contract.\\n    ///         Public getter is legacy and will be removed in the future. Use `messenger` instead.\\n    /// @return Contract of the messenger on this domain.\\n    /// @custom:legacy\\n    function MESSENGER() external view returns (ICrossDomainMessenger) {\\n        return messenger;\\n    }\\n\\n    /// @notice Getter for the other bridge contract.\\n    ///         Public getter is legacy and will be removed in the future. Use `otherBridge` instead.\\n    /// @return Contract of the bridge on the other network.\\n    /// @custom:legacy\\n    function OTHER_BRIDGE() external view returns (StandardBridge) {\\n        return otherBridge;\\n    }\\n\\n    /// @notice This function should return true if the contract is paused.\\n    ///         On L1 this function will check the SuperchainConfig for its paused status.\\n    ///         On L2 this function should be a no-op.\\n    /// @return Whether or not the contract is paused.\\n    function paused() public view virtual returns (bool) {\\n        return false;\\n    }\\n\\n    /// @notice Sends ETH to the sender's address on the other chain.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function bridgeETH(uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {\\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /// @notice Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a\\n    ///         smart contract and the call fails, the ETH will be temporarily locked in the\\n    ///         StandardBridge on the other chain until the call is replayed. If the call cannot be\\n    ///         replayed with any amount of gas (call always reverts), then the ETH will be\\n    ///         permanently locked in the StandardBridge on the other chain. ETH will also\\n    ///         be locked if the receiver is the other bridge, because finalizeBridgeETH will revert\\n    ///         in that case.\\n    /// @param _to          Address of the receiver.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function bridgeETHTo(address _to, uint32 _minGasLimit, bytes calldata _extraData) public payable {\\n        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _extraData);\\n    }\\n\\n    /// @notice Sends ERC20 tokens to the sender's address on the other chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\\n    /// @param _amount      Amount of local tokens to deposit.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function bridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    )\\n        public\\n        virtual\\n        onlyEOA\\n    {\\n        _initiateBridgeERC20(_localToken, _remoteToken, msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /// @notice Sends ERC20 tokens to a receiver's address on the other chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of local tokens to deposit.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function bridgeERC20To(\\n        address _localToken,\\n        address _remoteToken,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    )\\n        public\\n        virtual\\n    {\\n        _initiateBridgeERC20(_localToken, _remoteToken, msg.sender, _to, _amount, _minGasLimit, _extraData);\\n    }\\n\\n    /// @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other\\n    ///         StandardBridge contract on the remote chain.\\n    /// @param _from      Address of the sender.\\n    /// @param _to        Address of the receiver.\\n    /// @param _amount    Amount of ETH being bridged.\\n    /// @param _extraData Extra data to be sent with the transaction. Note that the recipient will\\n    ///                   not be triggered with this data, but it will be emitted and can be used\\n    ///                   to identify the transaction.\\n    function finalizeBridgeETH(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    )\\n        public\\n        payable\\n        onlyOtherBridge\\n    {\\n        require(paused() == false, \\\"StandardBridge: paused\\\");\\n        require(msg.value == _amount, \\\"StandardBridge: amount sent does not match amount required\\\");\\n        require(_to != address(this), \\\"StandardBridge: cannot send to self\\\");\\n        require(_to != address(messenger), \\\"StandardBridge: cannot send to messenger\\\");\\n\\n        // Emit the correct events. By default this will be _amount, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitETHBridgeFinalized(_from, _to, _amount, _extraData);\\n\\n        bool success = SafeCall.call(_to, gasleft(), _amount, hex\\\"\\\");\\n        require(success, \\\"StandardBridge: ETH transfer failed\\\");\\n    }\\n\\n    /// @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other\\n    ///         StandardBridge contract on the remote chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\\n    /// @param _from        Address of the sender.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of the ERC20 being bridged.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function finalizeBridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    )\\n        public\\n        onlyOtherBridge\\n    {\\n        require(paused() == false, \\\"StandardBridge: paused\\\");\\n        if (_isOptimismMintableERC20(_localToken)) {\\n            require(\\n                _isCorrectTokenPair(_localToken, _remoteToken),\\n                \\\"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\\\"\\n            );\\n\\n            IOptimismMintableERC20(_localToken).mint(_to, _amount);\\n        } else {\\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\\n            IERC20(_localToken).safeTransfer(_to, _amount);\\n        }\\n\\n        // Emit the correct events. By default this will be ERC20BridgeFinalized, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /// @notice Initiates a bridge of ETH through the CrossDomainMessenger.\\n    /// @param _from        Address of the sender.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of ETH being bridged.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function _initiateBridgeETH(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    )\\n        internal\\n    {\\n        require(msg.value == _amount, \\\"StandardBridge: bridging ETH must include sufficient ETH value\\\");\\n\\n        // Emit the correct events. By default this will be _amount, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitETHBridgeInitiated(_from, _to, _amount, _extraData);\\n\\n        messenger.sendMessage{ value: _amount }({\\n            _target: address(otherBridge),\\n            _message: abi.encodeWithSelector(this.finalizeBridgeETH.selector, _from, _to, _amount, _extraData),\\n            _minGasLimit: _minGasLimit\\n        });\\n    }\\n\\n    /// @notice Sends ERC20 tokens to a receiver's address on the other chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of local tokens to deposit.\\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\\n    ///                     not be triggered with this data, but it will be emitted and can be used\\n    ///                     to identify the transaction.\\n    function _initiateBridgeERC20(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes memory _extraData\\n    )\\n        internal\\n    {\\n        require(msg.value == 0, \\\"StandardBridge: cannot send value\\\");\\n\\n        if (_isOptimismMintableERC20(_localToken)) {\\n            require(\\n                _isCorrectTokenPair(_localToken, _remoteToken),\\n                \\\"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\\\"\\n            );\\n\\n            IOptimismMintableERC20(_localToken).burn(_from, _amount);\\n        } else {\\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\\n        }\\n\\n        // Emit the correct events. By default this will be ERC20BridgeInitiated, but child\\n        // contracts may override this function in order to emit legacy events as well.\\n        _emitERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n\\n        messenger.sendMessage({\\n            _target: address(otherBridge),\\n            _message: abi.encodeWithSelector(\\n                this.finalizeBridgeERC20.selector,\\n                // Because this call will be executed on the remote chain, we reverse the order of\\n                // the remote and local token addresses relative to their order in the\\n                // finalizeBridgeERC20 function.\\n                _remoteToken,\\n                _localToken,\\n                _from,\\n                _to,\\n                _amount,\\n                _extraData\\n            ),\\n            _minGasLimit: _minGasLimit\\n        });\\n    }\\n\\n    /// @notice Checks if a given address is an OptimismMintableERC20. Not perfect, but good enough.\\n    ///         Just the way we like it.\\n    /// @param _token Address of the token to check.\\n    /// @return True if the token is an OptimismMintableERC20.\\n    function _isOptimismMintableERC20(address _token) internal view returns (bool) {\\n        return ERC165Checker.supportsInterface(_token, type(ILegacyMintableERC20).interfaceId)\\n            || ERC165Checker.supportsInterface(_token, type(IOptimismMintableERC20).interfaceId);\\n    }\\n\\n    /// @notice Checks if the \\\"other token\\\" is the correct pair token for the OptimismMintableERC20.\\n    ///         Calls can be saved in the future by combining this logic with\\n    ///         `_isOptimismMintableERC20`.\\n    /// @param _mintableToken OptimismMintableERC20 to check against.\\n    /// @param _otherToken    Pair token to check.\\n    /// @return True if the other token is the correct pair token for the OptimismMintableERC20.\\n    function _isCorrectTokenPair(address _mintableToken, address _otherToken) internal view returns (bool) {\\n        if (ERC165Checker.supportsInterface(_mintableToken, type(ILegacyMintableERC20).interfaceId)) {\\n            return _otherToken == ILegacyMintableERC20(_mintableToken).l1Token();\\n        } else {\\n            return _otherToken == IOptimismMintableERC20(_mintableToken).remoteToken();\\n        }\\n    }\\n\\n    /// @notice Emits the ETHBridgeInitiated event and if necessary the appropriate legacy event\\n    ///         when an ETH bridge is finalized on this chain.\\n    /// @param _from      Address of the sender.\\n    /// @param _to        Address of the receiver.\\n    /// @param _amount    Amount of ETH sent.\\n    /// @param _extraData Extra data sent with the transaction.\\n    function _emitETHBridgeInitiated(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        virtual\\n    {\\n        emit ETHBridgeInitiated(_from, _to, _amount, _extraData);\\n    }\\n\\n    /// @notice Emits the ETHBridgeFinalized and if necessary the appropriate legacy event when an\\n    ///         ETH bridge is finalized on this chain.\\n    /// @param _from      Address of the sender.\\n    /// @param _to        Address of the receiver.\\n    /// @param _amount    Amount of ETH sent.\\n    /// @param _extraData Extra data sent with the transaction.\\n    function _emitETHBridgeFinalized(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        virtual\\n    {\\n        emit ETHBridgeFinalized(_from, _to, _amount, _extraData);\\n    }\\n\\n    /// @notice Emits the ERC20BridgeInitiated event and if necessary the appropriate legacy\\n    ///         event when an ERC20 bridge is initiated to the other chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the ERC20 on the remote chain.\\n    /// @param _from        Address of the sender.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of the ERC20 sent.\\n    /// @param _extraData   Extra data sent with the transaction.\\n    function _emitERC20BridgeInitiated(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        virtual\\n    {\\n        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n\\n    /// @notice Emits the ERC20BridgeFinalized event and if necessary the appropriate legacy\\n    ///         event when an ERC20 bridge is initiated to the other chain.\\n    /// @param _localToken  Address of the ERC20 on this chain.\\n    /// @param _remoteToken Address of the ERC20 on the remote chain.\\n    /// @param _from        Address of the sender.\\n    /// @param _to          Address of the receiver.\\n    /// @param _amount      Amount of the ERC20 sent.\\n    /// @param _extraData   Extra data sent with the transaction.\\n    function _emitERC20BridgeFinalized(\\n        address _localToken,\\n        address _remoteToken,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _extraData\\n    )\\n        internal\\n        virtual\\n    {\\n        emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Predeploys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Predeploys\\n/// @notice Contains constant addresses for protocol contracts that are pre-deployed to the L2 system.\\n//          This excludes the preinstalls (non-protocol contracts).\\nlibrary Predeploys {\\n    /// @notice Number of predeploy-namespace addresses reserved for protocol usage.\\n    uint256 internal constant PREDEPLOY_COUNT = 2048;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the LegacyMessagePasser predeploy. Deprecate. Use the updated\\n    ///         L2ToL1MessagePasser contract instead.\\n    address internal constant LEGACY_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the L1MessageSender predeploy. Deprecated. Use L2CrossDomainMessenger\\n    ///         or access tx.origin (or msg.sender) in a L1 to L2 transaction instead.\\n    ///         Not embedded into new OP-Stack chains.\\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the DeployerWhitelist predeploy. No longer active.\\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\\n\\n    /// @notice Address of the canonical WETH contract.\\n    address internal constant WETH = 0x4200000000000000000000000000000000000006;\\n\\n    /// @notice Address of the L2CrossDomainMessenger predeploy.\\n    address internal constant L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000007;\\n\\n    /// @notice Address of the GasPriceOracle predeploy. Includes fee information\\n    ///         and helpers for computing the L1 portion of the transaction fee.\\n    address internal constant GAS_PRICE_ORACLE = 0x420000000000000000000000000000000000000F;\\n\\n    /// @notice Address of the L2StandardBridge predeploy.\\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\\n\\n    //// @notice Address of the SequencerFeeWallet predeploy.\\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\\n\\n    /// @notice Address of the OptimismMintableERC20Factory predeploy.\\n    address internal constant OPTIMISM_MINTABLE_ERC20_FACTORY = 0x4200000000000000000000000000000000000012;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the L1BlockNumber predeploy. Deprecated. Use the L1Block predeploy\\n    ///         instead, which exposes more information about the L1 state.\\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\\n\\n    /// @notice Address of the L2ERC721Bridge predeploy.\\n    address internal constant L2_ERC721_BRIDGE = 0x4200000000000000000000000000000000000014;\\n\\n    /// @notice Address of the L1Block predeploy.\\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;\\n\\n    /// @notice Address of the L2ToL1MessagePasser predeploy.\\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000016;\\n\\n    /// @notice Address of the OptimismMintableERC721Factory predeploy.\\n    address internal constant OPTIMISM_MINTABLE_ERC721_FACTORY = 0x4200000000000000000000000000000000000017;\\n\\n    /// @notice Address of the ProxyAdmin predeploy.\\n    address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000018;\\n\\n    /// @notice Address of the BaseFeeVault predeploy.\\n    address internal constant BASE_FEE_VAULT = 0x4200000000000000000000000000000000000019;\\n\\n    /// @notice Address of the L1FeeVault predeploy.\\n    address internal constant L1_FEE_VAULT = 0x420000000000000000000000000000000000001A;\\n\\n    /// @notice Address of the OperatorFeeVault predeploy.\\n    address internal constant OPERATOR_FEE_VAULT = 0x420000000000000000000000000000000000001b;\\n\\n    /// @notice Address of the SchemaRegistry predeploy.\\n    address internal constant SCHEMA_REGISTRY = 0x4200000000000000000000000000000000000020;\\n\\n    /// @notice Address of the EAS predeploy.\\n    address internal constant EAS = 0x4200000000000000000000000000000000000021;\\n\\n    /// @notice Address of the GovernanceToken predeploy.\\n    address internal constant GOVERNANCE_TOKEN = 0x4200000000000000000000000000000000000042;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the LegacyERC20ETH predeploy. Deprecated. Balances are migrated to the\\n    ///         state trie as of the Bedrock upgrade. Contract has been locked and write functions\\n    ///         can no longer be accessed.\\n    address internal constant LEGACY_ERC20_ETH = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;\\n\\n    /// @notice Address of the CrossL2Inbox predeploy.\\n    address internal constant CROSS_L2_INBOX = 0x4200000000000000000000000000000000000022;\\n\\n    /// @notice Address of the L2ToL2CrossDomainMessenger predeploy.\\n    address internal constant L2_TO_L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000023;\\n\\n    /// @notice Address of the SuperchainWETH predeploy.\\n    address internal constant SUPERCHAIN_WETH = 0x4200000000000000000000000000000000000024;\\n\\n    /// @notice Address of the ETHLiquidity predeploy.\\n    address internal constant ETH_LIQUIDITY = 0x4200000000000000000000000000000000000025;\\n\\n    /// @notice Address of the OptimismSuperchainERC20Factory predeploy.\\n    address internal constant OPTIMISM_SUPERCHAIN_ERC20_FACTORY = 0x4200000000000000000000000000000000000026;\\n\\n    /// @notice Address of the OptimismSuperchainERC20Beacon predeploy.\\n    address internal constant OPTIMISM_SUPERCHAIN_ERC20_BEACON = 0x4200000000000000000000000000000000000027;\\n\\n    // TODO: Precalculate the address of the implementation contract\\n    /// @notice Arbitrary address of the OptimismSuperchainERC20 implementation contract.\\n    address internal constant OPTIMISM_SUPERCHAIN_ERC20 = 0xB9415c6cA93bdC545D4c5177512FCC22EFa38F28;\\n\\n    /// @notice Address of the SuperchainTokenBridge predeploy.\\n    address internal constant SUPERCHAIN_TOKEN_BRIDGE = 0x4200000000000000000000000000000000000028;\\n\\n    /// @notice Returns the name of the predeploy at the given address.\\n    function getName(address _addr) internal pure returns (string memory out_) {\\n        require(isPredeployNamespace(_addr), \\\"Predeploys: address must be a predeploy\\\");\\n        if (_addr == LEGACY_MESSAGE_PASSER) return \\\"LegacyMessagePasser\\\";\\n        if (_addr == L1_MESSAGE_SENDER) return \\\"L1MessageSender\\\";\\n        if (_addr == DEPLOYER_WHITELIST) return \\\"DeployerWhitelist\\\";\\n        if (_addr == WETH) return \\\"WETH\\\";\\n        if (_addr == L2_CROSS_DOMAIN_MESSENGER) return \\\"L2CrossDomainMessenger\\\";\\n        if (_addr == GAS_PRICE_ORACLE) return \\\"GasPriceOracle\\\";\\n        if (_addr == L2_STANDARD_BRIDGE) return \\\"L2StandardBridge\\\";\\n        if (_addr == SEQUENCER_FEE_WALLET) return \\\"SequencerFeeVault\\\";\\n        if (_addr == OPTIMISM_MINTABLE_ERC20_FACTORY) return \\\"OptimismMintableERC20Factory\\\";\\n        if (_addr == L1_BLOCK_NUMBER) return \\\"L1BlockNumber\\\";\\n        if (_addr == L2_ERC721_BRIDGE) return \\\"L2ERC721Bridge\\\";\\n        if (_addr == L1_BLOCK_ATTRIBUTES) return \\\"L1Block\\\";\\n        if (_addr == L2_TO_L1_MESSAGE_PASSER) return \\\"L2ToL1MessagePasser\\\";\\n        if (_addr == OPTIMISM_MINTABLE_ERC721_FACTORY) return \\\"OptimismMintableERC721Factory\\\";\\n        if (_addr == PROXY_ADMIN) return \\\"ProxyAdmin\\\";\\n        if (_addr == BASE_FEE_VAULT) return \\\"BaseFeeVault\\\";\\n        if (_addr == L1_FEE_VAULT) return \\\"L1FeeVault\\\";\\n        if (_addr == OPERATOR_FEE_VAULT) return \\\"OperatorFeeVault\\\";\\n        if (_addr == SCHEMA_REGISTRY) return \\\"SchemaRegistry\\\";\\n        if (_addr == EAS) return \\\"EAS\\\";\\n        if (_addr == GOVERNANCE_TOKEN) return \\\"GovernanceToken\\\";\\n        if (_addr == LEGACY_ERC20_ETH) return \\\"LegacyERC20ETH\\\";\\n        if (_addr == CROSS_L2_INBOX) return \\\"CrossL2Inbox\\\";\\n        if (_addr == L2_TO_L2_CROSS_DOMAIN_MESSENGER) return \\\"L2ToL2CrossDomainMessenger\\\";\\n        if (_addr == SUPERCHAIN_WETH) return \\\"SuperchainWETH\\\";\\n        if (_addr == ETH_LIQUIDITY) return \\\"ETHLiquidity\\\";\\n        if (_addr == OPTIMISM_SUPERCHAIN_ERC20_FACTORY) return \\\"OptimismSuperchainERC20Factory\\\";\\n        if (_addr == OPTIMISM_SUPERCHAIN_ERC20_BEACON) return \\\"OptimismSuperchainERC20Beacon\\\";\\n        if (_addr == SUPERCHAIN_TOKEN_BRIDGE) return \\\"SuperchainTokenBridge\\\";\\n        revert(\\\"Predeploys: unnamed predeploy\\\");\\n    }\\n\\n    /// @notice Returns true if the predeploy is not proxied.\\n    function notProxied(address _addr) internal pure returns (bool) {\\n        return _addr == GOVERNANCE_TOKEN || _addr == WETH;\\n    }\\n\\n    /// @notice Returns true if the address is a defined predeploy that is embedded into new OP-Stack chains.\\n    function isSupportedPredeploy(address _addr, bool _useInterop) internal pure returns (bool) {\\n        return _addr == LEGACY_MESSAGE_PASSER || _addr == DEPLOYER_WHITELIST || _addr == WETH\\n            || _addr == L2_CROSS_DOMAIN_MESSENGER || _addr == GAS_PRICE_ORACLE || _addr == L2_STANDARD_BRIDGE\\n            || _addr == SEQUENCER_FEE_WALLET || _addr == OPTIMISM_MINTABLE_ERC20_FACTORY || _addr == L1_BLOCK_NUMBER\\n            || _addr == L2_ERC721_BRIDGE || _addr == L1_BLOCK_ATTRIBUTES || _addr == L2_TO_L1_MESSAGE_PASSER\\n            || _addr == OPTIMISM_MINTABLE_ERC721_FACTORY || _addr == PROXY_ADMIN || _addr == BASE_FEE_VAULT\\n            || _addr == L1_FEE_VAULT || _addr == OPERATOR_FEE_VAULT || _addr == SCHEMA_REGISTRY || _addr == EAS\\n            || _addr == GOVERNANCE_TOKEN || (_useInterop && _addr == CROSS_L2_INBOX)\\n            || (_useInterop && _addr == L2_TO_L2_CROSS_DOMAIN_MESSENGER) || (_useInterop && _addr == SUPERCHAIN_WETH)\\n            || (_useInterop && _addr == ETH_LIQUIDITY) || (_useInterop && _addr == SUPERCHAIN_TOKEN_BRIDGE);\\n    }\\n\\n    function isPredeployNamespace(address _addr) internal pure returns (bool) {\\n        return uint160(_addr) >> 11 == uint160(0x4200000000000000000000000000000000000000) >> 11;\\n    }\\n\\n    /// @notice Function to compute the expected address of the predeploy implementation\\n    ///         in the genesis state.\\n    function predeployToCodeNamespace(address _addr) internal pure returns (address) {\\n        require(\\n            isPredeployNamespace(_addr), \\\"Predeploys: can only derive code-namespace address for predeploy addresses\\\"\\n        );\\n        return address(\\n            uint160(uint256(uint160(_addr)) & 0xffff | uint256(uint160(0xc0D3C0d3C0d3C0D3c0d3C0d3c0D3C0d3c0d30000)))\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/universal/ISemver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ISemver\\n/// @notice ISemver is a simple contract for ensuring that contracts are\\n///         versioned using semantic versioning.\\ninterface ISemver {\\n    /// @notice Getter for the semantic version of the contract. This is not\\n    ///         meant to be used onchain but instead meant to be used by offchain\\n    ///         tooling.\\n    /// @return Semver contract version as a string.\\n    function version() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"interfaces/universal/ICrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICrossDomainMessenger {\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n    event Initialized(uint8 version);\\n    event RelayedMessage(bytes32 indexed msgHash);\\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\\n    event SentMessageExtension1(address indexed sender, uint256 value);\\n\\n    function MESSAGE_VERSION() external view returns (uint16);\\n    function MIN_GAS_CALLDATA_OVERHEAD() external view returns (uint64);\\n    function MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR() external view returns (uint64);\\n    function MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR() external view returns (uint64);\\n    function OTHER_MESSENGER() external view returns (ICrossDomainMessenger);\\n    function RELAY_CALL_OVERHEAD() external view returns (uint64);\\n    function RELAY_CONSTANT_OVERHEAD() external view returns (uint64);\\n    function RELAY_GAS_CHECK_BUFFER() external view returns (uint64);\\n    function RELAY_RESERVED_GAS() external view returns (uint64);\\n    function TX_BASE_GAS() external view returns (uint64);\\n    function FLOOR_CALLDATA_OVERHEAD() external view returns (uint64);\\n    function ENCODING_OVERHEAD() external view returns (uint64);\\n    function baseGas(bytes memory _message, uint32 _minGasLimit) external pure returns (uint64);\\n    function failedMessages(bytes32) external view returns (bool);\\n    function messageNonce() external view returns (uint256);\\n    function otherMessenger() external view returns (ICrossDomainMessenger);\\n    function paused() external view returns (bool);\\n    function relayMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _minGasLimit,\\n        bytes memory _message\\n    )\\n        external\\n        payable;\\n    function sendMessage(address _target, bytes memory _message, uint32 _minGasLimit) external payable;\\n    function successfulMessages(bytes32) external view returns (bool);\\n    function xDomainMessageSender() external view returns (address);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/ISuperchainConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ISuperchainConfig {\\n    enum UpdateType {\\n        GUARDIAN\\n    }\\n\\n    event ConfigUpdate(UpdateType indexed updateType, bytes data);\\n    event Initialized(uint8 version);\\n    event Paused(string identifier);\\n    event Unpaused();\\n\\n    function GUARDIAN_SLOT() external view returns (bytes32);\\n    function PAUSED_SLOT() external view returns (bytes32);\\n    function guardian() external view returns (address guardian_);\\n    function initialize(address _guardian, bool _paused) external;\\n    function pause(string memory _identifier) external;\\n    function paused() external view returns (bool paused_);\\n    function unpause() external;\\n    function version() external view returns (string memory);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title SafeCall\\n/// @notice Perform low level safe calls\\nlibrary SafeCall {\\n    /// @notice Performs a low level call without copying any returndata.\\n    /// @dev Passes no calldata to the call context.\\n    /// @param _target   Address to call\\n    /// @param _gas      Amount of gas to pass to the call\\n    /// @param _value    Amount of value to pass to the call\\n    function send(address _target, uint256 _gas, uint256 _value) internal returns (bool success_) {\\n        assembly {\\n            success_ :=\\n                call(\\n                    _gas, // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    0, // inloc\\n                    0, // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n    }\\n\\n    /// @notice Perform a low level call with all gas without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _value    Amount of value to pass to the call\\n    function send(address _target, uint256 _value) internal returns (bool success_) {\\n        success_ = send(_target, gasleft(), _value);\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _gas      Amount of gas to pass to the call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(\\n        address _target,\\n        uint256 _gas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (bool success_)\\n    {\\n        assembly {\\n            success_ :=\\n                call(\\n                    _gas, // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    add(_calldata, 32), // inloc\\n                    mload(_calldata), // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(address _target, uint256 _value, bytes memory _calldata) internal returns (bool success_) {\\n        success_ = call({ _target: _target, _gas: gasleft(), _value: _value, _calldata: _calldata });\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(address _target, bytes memory _calldata) internal returns (bool success_) {\\n        success_ = call({ _target: _target, _gas: gasleft(), _value: 0, _calldata: _calldata });\\n    }\\n\\n    /// @notice Helper function to determine if there is sufficient gas remaining within the context\\n    ///         to guarantee that the minimum gas requirement for a call will be met as well as\\n    ///         optionally reserving a specified amount of gas for after the call has concluded.\\n    /// @param _minGas      The minimum amount of gas that may be passed to the target context.\\n    /// @param _reservedGas Optional amount of gas to reserve for the caller after the execution\\n    ///                     of the target context.\\n    /// @return `true` if there is enough gas remaining to safely supply `_minGas` to the target\\n    ///         context as well as reserve `_reservedGas` for the caller after the execution of\\n    ///         the target context.\\n    /// @dev !!!!! FOOTGUN ALERT !!!!!\\n    ///      1.) The 40_000 base buffer is to account for the worst case of the dynamic cost of the\\n    ///          `CALL` opcode's `address_access_cost`, `positive_value_cost`, and\\n    ///          `value_to_empty_account_cost` factors with an added buffer of 5,700 gas. It is\\n    ///          still possible to self-rekt by initiating a withdrawal with a minimum gas limit\\n    ///          that does not account for the `memory_expansion_cost` & `code_execution_cost`\\n    ///          factors of the dynamic cost of the `CALL` opcode.\\n    ///      2.) This function should *directly* precede the external call if possible. There is an\\n    ///          added buffer to account for gas consumed between this check and the call, but it\\n    ///          is only 5,700 gas.\\n    ///      3.) Because EIP-150 ensures that a maximum of 63/64ths of the remaining gas in the call\\n    ///          frame may be passed to a subcontext, we need to ensure that the gas will not be\\n    ///          truncated.\\n    ///      4.) Use wisely. This function is not a silver bullet.\\n    function hasMinGas(uint256 _minGas, uint256 _reservedGas) internal view returns (bool) {\\n        bool _hasMinGas;\\n        assembly {\\n            // Equation: gas × 63 ≥ minGas × 64 + 63(40_000 + reservedGas)\\n            _hasMinGas := iszero(lt(mul(gas(), 63), add(mul(_minGas, 64), mul(add(40000, _reservedGas), 63))))\\n        }\\n        return _hasMinGas;\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata. This function\\n    ///         will revert if the call cannot be performed with the specified minimum\\n    ///         gas.\\n    /// @param _target   Address to call\\n    /// @param _minGas   The minimum amount of gas that may be passed to the call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function callWithMinGas(\\n        address _target,\\n        uint256 _minGas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        bool _success;\\n        bool _hasMinGas = hasMinGas(_minGas, 0);\\n        assembly {\\n            // Assertion: gasleft() >= (_minGas * 64) / 63 + 40_000\\n            if iszero(_hasMinGas) {\\n                // Store the \\\"Error(string)\\\" selector in scratch space.\\n                mstore(0, 0x08c379a0)\\n                // Store the pointer to the string length in scratch space.\\n                mstore(32, 32)\\n                // Store the string.\\n                //\\n                // SAFETY:\\n                // - We pad the beginning of the string with two zero bytes as well as the\\n                // length (24) to ensure that we override the free memory pointer at offset\\n                // 0x40. This is necessary because the free memory pointer is likely to\\n                // be greater than 1 byte when this function is called, but it is incredibly\\n                // unlikely that it will be greater than 3 bytes. As for the data within\\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\\n                // - It's fine to clobber the free memory pointer, we're reverting.\\n                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\\n\\n                // Revert with 'Error(\\\"SafeCall: Not enough gas\\\")'\\n                revert(28, 100)\\n            }\\n\\n            // The call will be supplied at least ((_minGas * 64) / 63) gas due to the\\n            // above assertion. This ensures that, in all circumstances (except for when the\\n            // `_minGas` does not account for the `memory_expansion_cost` and `code_execution_cost`\\n            // factors of the dynamic cost of the `CALL` opcode), the call will receive at least\\n            // the minimum amount of gas specified.\\n            _success :=\\n                call(\\n                    gas(), // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    add(_calldata, 32), // inloc\\n                    mload(_calldata), // inlen\\n                    0x00, // outloc\\n                    0x00 // outlen\\n                )\\n        }\\n        return _success;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/EOA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title EOA\\n/// @notice A library for detecting if an address is an EOA.\\nlibrary EOA {\\n    /// @notice Returns true if sender address is an EOA.\\n    /// @return isEOA_ True if the sender address is an EOA.\\n    function isSenderEOA() internal view returns (bool isEOA_) {\\n        if (msg.sender == tx.origin) {\\n            isEOA_ = true;\\n        } else if (address(msg.sender).code.length == 23) {\\n            // If the sender is not the origin, check for 7702 delegated EOAs.\\n            assembly {\\n                let ptr := mload(0x40)\\n                mstore(0x40, add(ptr, 0x20))\\n                extcodecopy(caller(), ptr, 0, 0x20)\\n                isEOA_ := eq(shr(232, mload(ptr)), 0xEF0100)\\n            }\\n        } else {\\n            // If more or less than 23 bytes of code, not a 7702 delegated EOA.\\n            isEOA_ = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"interfaces/universal/IOptimismMintableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title IOptimismMintableERC20\\n/// @notice This interface is available on the OptimismMintableERC20 contract.\\n///         We declare it as a separate interface so that it can be used in\\n///         custom implementations of OptimismMintableERC20.\\ninterface IOptimismMintableERC20 is IERC165 {\\n    function remoteToken() external view returns (address);\\n\\n    function bridge() external returns (address);\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burn(address _from, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/legacy/ILegacyMintableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n/// @custom:legacy\\n/// @title ILegacyMintableERC20\\n/// @notice This interface was available on the legacy L2StandardERC20 contract.\\n///         It remains available on the OptimismMintableERC20 contract for\\n///         backwards compatibility.\\n\\ninterface ILegacyMintableERC20 is IERC165 {\\n    function l1Token() external view returns (address);\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burn(address _from, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-v5/=lib/openzeppelin-contracts-v5/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"@lib-keccak/=lib/lib-keccak/contracts/lib/\",\r\n      \"@solady/=lib/solady/src/\",\r\n      \"@solady-v0.0.245/=lib/solady-v0.0.245/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"kontrol-cheatcodes/=lib/kontrol-cheatcodes/src/\",\r\n      \"interfaces/=interfaces/\",\r\n      \"@solady-test/=lib/lib-keccak/lib/solady/test/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-v5/lib/erc4626-tests/\",\r\n      \"lib-keccak/=lib/lib-keccak/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts-v5/=lib/openzeppelin-contracts-v5/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solady-v0.0.245/=lib/solady-v0.0.245/src/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"localToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"remoteToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ERC20BridgeFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"localToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"remoteToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ERC20BridgeInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ERC20DepositInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ERC20WithdrawalFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ETHBridgeFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ETHBridgeInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ETHDepositInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ETHWithdrawalFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MESSENGER\",\"outputs\":[{\"internalType\":\"contract ICrossDomainMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OTHER_BRIDGE\",\"outputs\":[{\"internalType\":\"contract StandardBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_localToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_remoteToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_minGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"bridgeERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_localToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_remoteToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_minGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"bridgeERC20To\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_minGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"bridgeETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_minGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"bridgeETHTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l2Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_minGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"depositERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l2Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_minGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"depositERC20To\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_minGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_minGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"depositETHTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_localToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_remoteToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"finalizeBridgeERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"finalizeBridgeETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l2Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"finalizeERC20Withdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"finalizeETHWithdrawal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICrossDomainMessenger\",\"name\":\"_messenger\",\"type\":\"address\"},{\"internalType\":\"contract ISuperchainConfig\",\"name\":\"_superchainConfig\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2TokenBridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messenger\",\"outputs\":[{\"internalType\":\"contract ICrossDomainMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherBridge\",\"outputs\":[{\"internalType\":\"contract StandardBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superchainConfig\",\"outputs\":[{\"internalType\":\"contract ISuperchainConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "contract_name": "L1StandardBridge",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "optimization_used": "1",
      "runs": "999999",
      "constructor_arguments": "",
      "evm_version": "london",
      "library": "",
      "license_type": "",
      "proxy": "0",
      "implementation": "",
      "bytecode": null
    },
    "0x5d5a095665886119693f0b41d8dfee78da033e8b": {
      "address": "0x5d5a095665886119693f0b41d8dfee78da033e8b",
      "has_source_code": true,
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/L1/L1CrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n// Contracts\\nimport { CrossDomainMessenger } from \\\"src/universal/CrossDomainMessenger.sol\\\";\\n\\n// Libraries\\nimport { Predeploys } from \\\"src/libraries/Predeploys.sol\\\";\\n\\n// Interfaces\\nimport { ISemver } from \\\"interfaces/universal/ISemver.sol\\\";\\nimport { ISuperchainConfig } from \\\"interfaces/L1/ISuperchainConfig.sol\\\";\\nimport { IOptimismPortal2 as IOptimismPortal } from \\\"interfaces/L1/IOptimismPortal2.sol\\\";\\n\\n/// @custom:proxied true\\n/// @title L1CrossDomainMessenger\\n/// @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\\n///         for sending and receiving data on the L1 side. Users are encouraged to use this\\n///         interface instead of interacting with lower-level contracts directly.\\ncontract L1CrossDomainMessenger is CrossDomainMessenger, ISemver {\\n    /// @notice Contract of the SuperchainConfig.\\n    ISuperchainConfig public superchainConfig;\\n\\n    /// @notice Contract of the OptimismPortal.\\n    /// @custom:network-specific\\n    IOptimismPortal public portal;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer systemConfig\\n    /// @notice Spacer taking up the legacy `systemConfig` slot.\\n    address private spacer_253_0_20;\\n\\n    /// @notice Semantic version.\\n    /// @custom:semver 2.6.0\\n    string public constant version = \\\"2.6.0\\\";\\n\\n    /// @notice Constructs the L1CrossDomainMessenger contract.\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice Initializes the contract.\\n    /// @param _superchainConfig Contract of the SuperchainConfig contract on this network.\\n    /// @param _portal Contract of the OptimismPortal contract on this network.\\n    function initialize(ISuperchainConfig _superchainConfig, IOptimismPortal _portal) external initializer {\\n        superchainConfig = _superchainConfig;\\n        portal = _portal;\\n        __CrossDomainMessenger_init({ _otherMessenger: CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER) });\\n    }\\n\\n    /// @notice Getter function for the OptimismPortal contract on this chain.\\n    ///         Public getter is legacy and will be removed in the future. Use `portal()` instead.\\n    /// @return Contract of the OptimismPortal on this chain.\\n    /// @custom:legacy\\n    function PORTAL() external view returns (IOptimismPortal) {\\n        return portal;\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function _sendMessage(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal override {\\n        portal.depositTransaction{ value: _value }({\\n            _to: _to,\\n            _value: _value,\\n            _gasLimit: _gasLimit,\\n            _isCreation: false,\\n            _data: _data\\n        });\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function _isOtherMessenger() internal view override returns (bool) {\\n        return msg.sender == address(portal) && portal.l2Sender() == address(otherMessenger);\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\\n        return _target == address(this) || _target == address(portal);\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function paused() public view override returns (bool) {\\n        return superchainConfig.paused();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/universal/CrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n// Libraries\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { SafeCall } from \\\"src/libraries/SafeCall.sol\\\";\\nimport { Hashing } from \\\"src/libraries/Hashing.sol\\\";\\nimport { Encoding } from \\\"src/libraries/Encoding.sol\\\";\\nimport { Constants } from \\\"src/libraries/Constants.sol\\\";\\n\\n/// @custom:legacy\\n/// @title CrossDomainMessengerLegacySpacer0\\n/// @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\\n///         libAddressManager variable used to exist. Must be the first contract in the inheritance\\n///         tree of the CrossDomainMessenger.\\ncontract CrossDomainMessengerLegacySpacer0 {\\n    /// @custom:legacy\\n    /// @custom:spacer libAddressManager\\n    /// @notice Spacer for backwards compatibility.\\n    address private spacer_0_0_20;\\n}\\n\\n/// @custom:legacy\\n/// @title CrossDomainMessengerLegacySpacer1\\n/// @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\\n///         PausableUpgradable and OwnableUpgradeable variables used to exist. Must be\\n///         the third contract in the inheritance tree of the CrossDomainMessenger.\\ncontract CrossDomainMessengerLegacySpacer1 {\\n    /// @custom:legacy\\n    /// @custom:spacer ContextUpgradable's __gap\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         ContextUpgradable.\\n    uint256[50] private spacer_1_0_1600;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer OwnableUpgradeable's _owner\\n    /// @notice Spacer for backwards compatibility.\\n    ///         Come from OpenZeppelin OwnableUpgradeable.\\n    address private spacer_51_0_20;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer OwnableUpgradeable's __gap\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         OwnableUpgradeable.\\n    uint256[49] private spacer_52_0_1568;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer PausableUpgradable's _paused\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         PausableUpgradable.\\n    bool private spacer_101_0_1;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer PausableUpgradable's __gap\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         PausableUpgradable.\\n    uint256[49] private spacer_102_0_1568;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer ReentrancyGuardUpgradeable's `_status` field.\\n    /// @notice Spacer for backwards compatibility.\\n    uint256 private spacer_151_0_32;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer ReentrancyGuardUpgradeable's __gap\\n    /// @notice Spacer for backwards compatibility.\\n    uint256[49] private spacer_152_0_1568;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer blockedMessages\\n    /// @notice Spacer for backwards compatibility.\\n    mapping(bytes32 => bool) private spacer_201_0_32;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer relayedMessages\\n    /// @notice Spacer for backwards compatibility.\\n    mapping(bytes32 => bool) private spacer_202_0_32;\\n}\\n\\n/// @custom:upgradeable\\n/// @title CrossDomainMessenger\\n/// @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\\n///         cross-chain messenger contracts. It's designed to be a universal interface that only\\n///         needs to be extended slightly to provide low-level message passing functionality on each\\n///         chain it's deployed on. Currently only designed for message passing between two paired\\n///         chains and does not support one-to-many interactions.\\n///         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\\nabstract contract CrossDomainMessenger is\\n    CrossDomainMessengerLegacySpacer0,\\n    Initializable,\\n    CrossDomainMessengerLegacySpacer1\\n{\\n    /// @notice Current message version identifier.\\n    uint16 public constant MESSAGE_VERSION = 1;\\n\\n    /// @notice Constant overhead added to the base gas for a message.\\n    uint64 public constant RELAY_CONSTANT_OVERHEAD = 200_000;\\n\\n    /// @notice Numerator for dynamic overhead added to the base gas for a message.\\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 64;\\n\\n    /// @notice Denominator for dynamic overhead added to the base gas for a message.\\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 63;\\n\\n    /// @notice Extra gas added to base gas for each byte of calldata in a message.\\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\\n\\n    /// @notice Gas reserved for performing the external call in `relayMessage`.\\n    uint64 public constant RELAY_CALL_OVERHEAD = 40_000;\\n\\n    /// @notice Gas reserved for finalizing the execution of `relayMessage` after the safe call.\\n    uint64 public constant RELAY_RESERVED_GAS = 40_000;\\n\\n    /// @notice Gas reserved for the execution between the `hasMinGas` check and the external\\n    ///         call in `relayMessage`.\\n    uint64 public constant RELAY_GAS_CHECK_BUFFER = 5_000;\\n\\n    /// @notice Base gas required for any transaction in the EVM.\\n    uint64 public constant TX_BASE_GAS = 21_000;\\n\\n    /// @notice Floor overhead per byte of non-zero calldata in a message. Calldata floor was\\n    ///         introduced in EIP-7623.\\n    uint64 public constant FLOOR_CALLDATA_OVERHEAD = 40;\\n\\n    /// @notice Overhead added to the internal message data when the full call to relayMessage is\\n    ///         ABI encoded. This is a constant value that is specific to the V1 message encoding\\n    ///         scheme. 260 is an upper bound, actual overhead can be as low as 228 bytes for an\\n    ///         empty message.\\n    uint64 public constant ENCODING_OVERHEAD = 260;\\n\\n    /// @notice Mapping of message hashes to boolean receipt values. Note that a message will only\\n    ///         be present in this mapping if it has successfully been relayed on this chain, and\\n    ///         can therefore not be relayed again.\\n    mapping(bytes32 => bool) public successfulMessages;\\n\\n    /// @notice Address of the sender of the currently executing message on the other chain. If the\\n    ///         value of this variable is the default value (0x00000000...dead) then no message is\\n    ///         currently being executed. Use the xDomainMessageSender getter which will throw an\\n    ///         error if this is the case.\\n    address internal xDomainMsgSender;\\n\\n    /// @notice Nonce for the next message to be sent, without the message version applied. Use the\\n    ///         messageNonce getter which will insert the message version into the nonce to give you\\n    ///         the actual nonce to be used for the message.\\n    uint240 internal msgNonce;\\n\\n    /// @notice Mapping of message hashes to a boolean if and only if the message has failed to be\\n    ///         executed at least once. A message will not be present in this mapping if it\\n    ///         successfully executed on the first attempt.\\n    mapping(bytes32 => bool) public failedMessages;\\n\\n    /// @notice CrossDomainMessenger contract on the other chain.\\n    /// @custom:network-specific\\n    CrossDomainMessenger public otherMessenger;\\n\\n    /// @notice Reserve extra slots in the storage layout for future upgrades.\\n    ///         A gap size of 43 was chosen here, so that the first slot used in a child contract\\n    ///         would be 1 plus a multiple of 50.\\n    uint256[43] private __gap;\\n\\n    /// @notice Emitted whenever a message is sent to the other chain.\\n    /// @param target       Address of the recipient of the message.\\n    /// @param sender       Address of the sender of the message.\\n    /// @param message      Message to trigger the recipient address with.\\n    /// @param messageNonce Unique nonce attached to the message.\\n    /// @param gasLimit     Minimum gas limit that the message can be executed with.\\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\\n\\n    /// @notice Additional event data to emit, required as of Bedrock. Cannot be merged with the\\n    ///         SentMessage event without breaking the ABI of this contract, this is good enough.\\n    /// @param sender Address of the sender of the message.\\n    /// @param value  ETH value sent along with the message to the recipient.\\n    event SentMessageExtension1(address indexed sender, uint256 value);\\n\\n    /// @notice Emitted whenever a message is successfully relayed on this chain.\\n    /// @param msgHash Hash of the message that was relayed.\\n    event RelayedMessage(bytes32 indexed msgHash);\\n\\n    /// @notice Emitted whenever a message fails to be relayed on this chain.\\n    /// @param msgHash Hash of the message that failed to be relayed.\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /// @notice Sends a message to some target address on the other chain. Note that if the call\\n    ///         always reverts, then the message will be unrelayable, and any ETH sent will be\\n    ///         permanently locked. The same will occur if the target on the other chain is\\n    ///         considered unsafe (see the _isUnsafeTarget() function).\\n    /// @param _target      Target contract or wallet address.\\n    /// @param _message     Message to trigger the target address with.\\n    /// @param _minGasLimit Minimum gas limit that the message can be executed with.\\n    function sendMessage(address _target, bytes calldata _message, uint32 _minGasLimit) external payable {\\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\\n        // guarantee the property that the call to the target contract will always have at least\\n        // the minimum gas limit specified by the user.\\n        _sendMessage({\\n            _to: address(otherMessenger),\\n            _gasLimit: baseGas(_message, _minGasLimit),\\n            _value: msg.value,\\n            _data: abi.encodeWithSelector(\\n                this.relayMessage.selector, messageNonce(), msg.sender, _target, msg.value, _minGasLimit, _message\\n            )\\n        });\\n\\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\\n        emit SentMessageExtension1(msg.sender, msg.value);\\n\\n        unchecked {\\n            ++msgNonce;\\n        }\\n    }\\n\\n    /// @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\\n    ///         be executed via cross-chain call from the other messenger OR if the message was\\n    ///         already received once and is currently being replayed.\\n    /// @param _nonce       Nonce of the message being relayed.\\n    /// @param _sender      Address of the user who sent the message.\\n    /// @param _target      Address that the message is targeted at.\\n    /// @param _value       ETH value to send with the message.\\n    /// @param _minGasLimit Minimum amount of gas that the message can be executed with.\\n    /// @param _message     Message to send to the target.\\n    function relayMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _minGasLimit,\\n        bytes calldata _message\\n    )\\n        external\\n        payable\\n    {\\n        // On L1 this function will check the Portal for its paused status.\\n        // On L2 this function should be a no-op, because paused will always return false.\\n        require(paused() == false, \\\"CrossDomainMessenger: paused\\\");\\n\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        require(version < 2, \\\"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\\\");\\n\\n        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\\n        // to check that the legacy version of the message has not already been relayed.\\n        if (version == 0) {\\n            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\\n            require(successfulMessages[oldHash] == false, \\\"CrossDomainMessenger: legacy withdrawal already relayed\\\");\\n        }\\n\\n        // We use the v1 message hash as the unique identifier for the message because it commits\\n        // to the value and minimum gas limit of the message.\\n        bytes32 versionedHash =\\n            Hashing.hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _minGasLimit, _message);\\n\\n        if (_isOtherMessenger()) {\\n            // These properties should always hold when the message is first submitted (as\\n            // opposed to being replayed).\\n            assert(msg.value == _value);\\n            assert(!failedMessages[versionedHash]);\\n        } else {\\n            require(msg.value == 0, \\\"CrossDomainMessenger: value must be zero unless message is from a system address\\\");\\n\\n            require(failedMessages[versionedHash], \\\"CrossDomainMessenger: message cannot be replayed\\\");\\n        }\\n\\n        require(\\n            _isUnsafeTarget(_target) == false, \\\"CrossDomainMessenger: cannot send message to blocked system address\\\"\\n        );\\n\\n        require(successfulMessages[versionedHash] == false, \\\"CrossDomainMessenger: message has already been relayed\\\");\\n\\n        // If there is not enough gas left to perform the external call and finish the execution,\\n        // return early and assign the message to the failedMessages mapping.\\n        // We are asserting that we have enough gas to:\\n        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)\\n        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.\\n        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).\\n        //\\n        // If `xDomainMsgSender` is not the default L2 sender, this function\\n        // is being re-entered. This marks the message as failed to allow it to be replayed.\\n        if (\\n            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER)\\n                || xDomainMsgSender != Constants.DEFAULT_L2_SENDER\\n        ) {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n\\n            return;\\n        }\\n\\n        xDomainMsgSender = _sender;\\n        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _value, _message);\\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\\n\\n        if (success) {\\n            // This check is identical to one above, but it ensures that the same message cannot be relayed\\n            // twice, and adds a layer of protection against rentrancy.\\n            assert(successfulMessages[versionedHash] == false);\\n            successfulMessages[versionedHash] = true;\\n            emit RelayedMessage(versionedHash);\\n        } else {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n        }\\n    }\\n\\n    /// @notice Retrieves the address of the contract or wallet that initiated the currently\\n    ///         executing message on the other chain. Will throw an error if there is no message\\n    ///         currently being executed. Allows the recipient of a call to see who triggered it.\\n    /// @return Address of the sender of the currently executing message on the other chain.\\n    function xDomainMessageSender() external view returns (address) {\\n        require(\\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER, \\\"CrossDomainMessenger: xDomainMessageSender is not set\\\"\\n        );\\n\\n        return xDomainMsgSender;\\n    }\\n\\n    /// @notice Retrieves the address of the paired CrossDomainMessenger contract on the other chain\\n    ///         Public getter is legacy and will be removed in the future. Use `otherMessenger()` instead.\\n    /// @return CrossDomainMessenger contract on the other chain.\\n    /// @custom:legacy\\n    function OTHER_MESSENGER() public view returns (CrossDomainMessenger) {\\n        return otherMessenger;\\n    }\\n\\n    /// @notice Retrieves the next message nonce. Message version will be added to the upper two\\n    ///         bytes of the message nonce. Message version allows us to treat messages as having\\n    ///         different structures.\\n    /// @return Nonce of the next message to be sent, with added message version.\\n    function messageNonce() public view returns (uint256) {\\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\\n    }\\n\\n    /// @notice Computes the amount of gas required to guarantee that a given message will be\\n    ///         received on the other chain without running out of gas. Guaranteeing that a message\\n    ///         will not run out of gas is important because this ensures that a message can always\\n    ///         be replayed on the other chain if it fails to execute completely.\\n    /// @param _message     Message to compute the amount of required gas for.\\n    /// @param _minGasLimit Minimum desired gas limit when message goes to target.\\n    /// @return Amount of gas required to guarantee message receipt.\\n    function baseGas(bytes memory _message, uint32 _minGasLimit) public pure returns (uint64) {\\n        // Base gas should really be computed on the fully encoded message but that would break the\\n        // expected API, so we instead just add the encoding overhead to the message length inside\\n        // of this function.\\n\\n        // We need a minimum amount of execution gas to ensure that the message will be received on\\n        // the other side without running out of gas (stored within the failedMessages mapping).\\n        // If we get beyond the hasMinGas check, then we *must* supply more than minGasLimit to\\n        // the external call.\\n        uint64 executionGas = uint64(\\n            // Constant costs for relayMessage\\n            RELAY_CONSTANT_OVERHEAD\\n            // Covers dynamic parts of the CALL opcode\\n            + RELAY_CALL_OVERHEAD\\n            // Ensures execution of relayMessage completes after call\\n            + RELAY_RESERVED_GAS\\n            // Buffer between hasMinGas check and the CALL\\n            + RELAY_GAS_CHECK_BUFFER\\n            // Minimum gas limit, multiplied by 64/63 to account for EIP-150.\\n            + ((_minGasLimit * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) / MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR)\\n        );\\n\\n        // Total message size is the result of properly ABI encoding the call to relayMessage.\\n        // Since we only get the message data and not the rest of the calldata, we use the\\n        // ENCODING_OVERHEAD constant to conservatively account for the remaining bytes.\\n        uint64 totalMessageSize = uint64(_message.length + ENCODING_OVERHEAD);\\n\\n        // Finally, replicate the transaction cost formula as defined after EIP-7623. This is\\n        // mostly relevant in the L1 -> L2 case because we need to be able to cover the intrinsic\\n        // cost of the message but it doesn't hurt in the L2 -> L1 case. After EIP-7623, the cost\\n        // of a transaction is floored by its calldata size. We don't need to account for the\\n        // contract creation case because this is always a call to relayMessage.\\n        return TX_BASE_GAS\\n            + uint64(\\n                Math.max(\\n                    executionGas + (totalMessageSize * MIN_GAS_CALLDATA_OVERHEAD),\\n                    (totalMessageSize * FLOOR_CALLDATA_OVERHEAD)\\n                )\\n            );\\n    }\\n\\n    /// @notice Initializer.\\n    /// @param _otherMessenger CrossDomainMessenger contract on the other chain.\\n    function __CrossDomainMessenger_init(CrossDomainMessenger _otherMessenger) internal onlyInitializing {\\n        // We only want to set the xDomainMsgSender to the default value if it hasn't been initialized yet,\\n        // meaning that this is a fresh contract deployment.\\n        // This prevents resetting the xDomainMsgSender to the default value during an upgrade, which would enable\\n        // a reentrant withdrawal to sandwhich the upgrade replay a withdrawal twice.\\n        if (xDomainMsgSender == address(0)) {\\n            xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\\n        }\\n        otherMessenger = _otherMessenger;\\n    }\\n\\n    /// @notice Sends a low-level message to the other messenger. Needs to be implemented by child\\n    ///         contracts because the logic for this depends on the network where the messenger is\\n    ///         being deployed.\\n    /// @param _to       Recipient of the message on the other chain.\\n    /// @param _gasLimit Minimum gas limit the message can be executed with.\\n    /// @param _value    Amount of ETH to send with the message.\\n    /// @param _data     Message data.\\n    function _sendMessage(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal virtual;\\n\\n    /// @notice Checks whether the message is coming from the other messenger. Implemented by child\\n    ///         contracts because the logic for this depends on the network where the messenger is\\n    ///         being deployed.\\n    /// @return Whether the message is coming from the other messenger.\\n    function _isOtherMessenger() internal view virtual returns (bool);\\n\\n    /// @notice Checks whether a given call target is a system address that could cause the\\n    ///         messenger to peform an unsafe action. This is NOT a mechanism for blocking user\\n    ///         addresses. This is ONLY used to prevent the execution of messages to specific\\n    ///         system addresses that could cause security issues, e.g., having the\\n    ///         CrossDomainMessenger send messages to itself.\\n    /// @param _target Address of the contract to check.\\n    /// @return Whether or not the address is an unsafe system address.\\n    function _isUnsafeTarget(address _target) internal view virtual returns (bool);\\n\\n    /// @notice This function should return true if the contract is paused.\\n    ///         On L1 this function will check the SuperchainConfig for its paused status.\\n    ///         On L2 this function should be a no-op.\\n    /// @return Whether or not the contract is paused.\\n    function paused() public view virtual returns (bool) {\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Predeploys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Predeploys\\n/// @notice Contains constant addresses for protocol contracts that are pre-deployed to the L2 system.\\n//          This excludes the preinstalls (non-protocol contracts).\\nlibrary Predeploys {\\n    /// @notice Number of predeploy-namespace addresses reserved for protocol usage.\\n    uint256 internal constant PREDEPLOY_COUNT = 2048;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the LegacyMessagePasser predeploy. Deprecate. Use the updated\\n    ///         L2ToL1MessagePasser contract instead.\\n    address internal constant LEGACY_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the L1MessageSender predeploy. Deprecated. Use L2CrossDomainMessenger\\n    ///         or access tx.origin (or msg.sender) in a L1 to L2 transaction instead.\\n    ///         Not embedded into new OP-Stack chains.\\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the DeployerWhitelist predeploy. No longer active.\\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\\n\\n    /// @notice Address of the canonical WETH contract.\\n    address internal constant WETH = 0x4200000000000000000000000000000000000006;\\n\\n    /// @notice Address of the L2CrossDomainMessenger predeploy.\\n    address internal constant L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000007;\\n\\n    /// @notice Address of the GasPriceOracle predeploy. Includes fee information\\n    ///         and helpers for computing the L1 portion of the transaction fee.\\n    address internal constant GAS_PRICE_ORACLE = 0x420000000000000000000000000000000000000F;\\n\\n    /// @notice Address of the L2StandardBridge predeploy.\\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\\n\\n    //// @notice Address of the SequencerFeeWallet predeploy.\\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\\n\\n    /// @notice Address of the OptimismMintableERC20Factory predeploy.\\n    address internal constant OPTIMISM_MINTABLE_ERC20_FACTORY = 0x4200000000000000000000000000000000000012;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the L1BlockNumber predeploy. Deprecated. Use the L1Block predeploy\\n    ///         instead, which exposes more information about the L1 state.\\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\\n\\n    /// @notice Address of the L2ERC721Bridge predeploy.\\n    address internal constant L2_ERC721_BRIDGE = 0x4200000000000000000000000000000000000014;\\n\\n    /// @notice Address of the L1Block predeploy.\\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;\\n\\n    /// @notice Address of the L2ToL1MessagePasser predeploy.\\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000016;\\n\\n    /// @notice Address of the OptimismMintableERC721Factory predeploy.\\n    address internal constant OPTIMISM_MINTABLE_ERC721_FACTORY = 0x4200000000000000000000000000000000000017;\\n\\n    /// @notice Address of the ProxyAdmin predeploy.\\n    address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000018;\\n\\n    /// @notice Address of the BaseFeeVault predeploy.\\n    address internal constant BASE_FEE_VAULT = 0x4200000000000000000000000000000000000019;\\n\\n    /// @notice Address of the L1FeeVault predeploy.\\n    address internal constant L1_FEE_VAULT = 0x420000000000000000000000000000000000001A;\\n\\n    /// @notice Address of the OperatorFeeVault predeploy.\\n    address internal constant OPERATOR_FEE_VAULT = 0x420000000000000000000000000000000000001b;\\n\\n    /// @notice Address of the SchemaRegistry predeploy.\\n    address internal constant SCHEMA_REGISTRY = 0x4200000000000000000000000000000000000020;\\n\\n    /// @notice Address of the EAS predeploy.\\n    address internal constant EAS = 0x4200000000000000000000000000000000000021;\\n\\n    /// @notice Address of the GovernanceToken predeploy.\\n    address internal constant GOVERNANCE_TOKEN = 0x4200000000000000000000000000000000000042;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the LegacyERC20ETH predeploy. Deprecated. Balances are migrated to the\\n    ///         state trie as of the Bedrock upgrade. Contract has been locked and write functions\\n    ///         can no longer be accessed.\\n    address internal constant LEGACY_ERC20_ETH = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;\\n\\n    /// @notice Address of the CrossL2Inbox predeploy.\\n    address internal constant CROSS_L2_INBOX = 0x4200000000000000000000000000000000000022;\\n\\n    /// @notice Address of the L2ToL2CrossDomainMessenger predeploy.\\n    address internal constant L2_TO_L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000023;\\n\\n    /// @notice Address of the SuperchainWETH predeploy.\\n    address internal constant SUPERCHAIN_WETH = 0x4200000000000000000000000000000000000024;\\n\\n    /// @notice Address of the ETHLiquidity predeploy.\\n    address internal constant ETH_LIQUIDITY = 0x4200000000000000000000000000000000000025;\\n\\n    /// @notice Address of the OptimismSuperchainERC20Factory predeploy.\\n    address internal constant OPTIMISM_SUPERCHAIN_ERC20_FACTORY = 0x4200000000000000000000000000000000000026;\\n\\n    /// @notice Address of the OptimismSuperchainERC20Beacon predeploy.\\n    address internal constant OPTIMISM_SUPERCHAIN_ERC20_BEACON = 0x4200000000000000000000000000000000000027;\\n\\n    // TODO: Precalculate the address of the implementation contract\\n    /// @notice Arbitrary address of the OptimismSuperchainERC20 implementation contract.\\n    address internal constant OPTIMISM_SUPERCHAIN_ERC20 = 0xB9415c6cA93bdC545D4c5177512FCC22EFa38F28;\\n\\n    /// @notice Address of the SuperchainTokenBridge predeploy.\\n    address internal constant SUPERCHAIN_TOKEN_BRIDGE = 0x4200000000000000000000000000000000000028;\\n\\n    /// @notice Returns the name of the predeploy at the given address.\\n    function getName(address _addr) internal pure returns (string memory out_) {\\n        require(isPredeployNamespace(_addr), \\\"Predeploys: address must be a predeploy\\\");\\n        if (_addr == LEGACY_MESSAGE_PASSER) return \\\"LegacyMessagePasser\\\";\\n        if (_addr == L1_MESSAGE_SENDER) return \\\"L1MessageSender\\\";\\n        if (_addr == DEPLOYER_WHITELIST) return \\\"DeployerWhitelist\\\";\\n        if (_addr == WETH) return \\\"WETH\\\";\\n        if (_addr == L2_CROSS_DOMAIN_MESSENGER) return \\\"L2CrossDomainMessenger\\\";\\n        if (_addr == GAS_PRICE_ORACLE) return \\\"GasPriceOracle\\\";\\n        if (_addr == L2_STANDARD_BRIDGE) return \\\"L2StandardBridge\\\";\\n        if (_addr == SEQUENCER_FEE_WALLET) return \\\"SequencerFeeVault\\\";\\n        if (_addr == OPTIMISM_MINTABLE_ERC20_FACTORY) return \\\"OptimismMintableERC20Factory\\\";\\n        if (_addr == L1_BLOCK_NUMBER) return \\\"L1BlockNumber\\\";\\n        if (_addr == L2_ERC721_BRIDGE) return \\\"L2ERC721Bridge\\\";\\n        if (_addr == L1_BLOCK_ATTRIBUTES) return \\\"L1Block\\\";\\n        if (_addr == L2_TO_L1_MESSAGE_PASSER) return \\\"L2ToL1MessagePasser\\\";\\n        if (_addr == OPTIMISM_MINTABLE_ERC721_FACTORY) return \\\"OptimismMintableERC721Factory\\\";\\n        if (_addr == PROXY_ADMIN) return \\\"ProxyAdmin\\\";\\n        if (_addr == BASE_FEE_VAULT) return \\\"BaseFeeVault\\\";\\n        if (_addr == L1_FEE_VAULT) return \\\"L1FeeVault\\\";\\n        if (_addr == OPERATOR_FEE_VAULT) return \\\"OperatorFeeVault\\\";\\n        if (_addr == SCHEMA_REGISTRY) return \\\"SchemaRegistry\\\";\\n        if (_addr == EAS) return \\\"EAS\\\";\\n        if (_addr == GOVERNANCE_TOKEN) return \\\"GovernanceToken\\\";\\n        if (_addr == LEGACY_ERC20_ETH) return \\\"LegacyERC20ETH\\\";\\n        if (_addr == CROSS_L2_INBOX) return \\\"CrossL2Inbox\\\";\\n        if (_addr == L2_TO_L2_CROSS_DOMAIN_MESSENGER) return \\\"L2ToL2CrossDomainMessenger\\\";\\n        if (_addr == SUPERCHAIN_WETH) return \\\"SuperchainWETH\\\";\\n        if (_addr == ETH_LIQUIDITY) return \\\"ETHLiquidity\\\";\\n        if (_addr == OPTIMISM_SUPERCHAIN_ERC20_FACTORY) return \\\"OptimismSuperchainERC20Factory\\\";\\n        if (_addr == OPTIMISM_SUPERCHAIN_ERC20_BEACON) return \\\"OptimismSuperchainERC20Beacon\\\";\\n        if (_addr == SUPERCHAIN_TOKEN_BRIDGE) return \\\"SuperchainTokenBridge\\\";\\n        revert(\\\"Predeploys: unnamed predeploy\\\");\\n    }\\n\\n    /// @notice Returns true if the predeploy is not proxied.\\n    function notProxied(address _addr) internal pure returns (bool) {\\n        return _addr == GOVERNANCE_TOKEN || _addr == WETH;\\n    }\\n\\n    /// @notice Returns true if the address is a defined predeploy that is embedded into new OP-Stack chains.\\n    function isSupportedPredeploy(address _addr, bool _useInterop) internal pure returns (bool) {\\n        return _addr == LEGACY_MESSAGE_PASSER || _addr == DEPLOYER_WHITELIST || _addr == WETH\\n            || _addr == L2_CROSS_DOMAIN_MESSENGER || _addr == GAS_PRICE_ORACLE || _addr == L2_STANDARD_BRIDGE\\n            || _addr == SEQUENCER_FEE_WALLET || _addr == OPTIMISM_MINTABLE_ERC20_FACTORY || _addr == L1_BLOCK_NUMBER\\n            || _addr == L2_ERC721_BRIDGE || _addr == L1_BLOCK_ATTRIBUTES || _addr == L2_TO_L1_MESSAGE_PASSER\\n            || _addr == OPTIMISM_MINTABLE_ERC721_FACTORY || _addr == PROXY_ADMIN || _addr == BASE_FEE_VAULT\\n            || _addr == L1_FEE_VAULT || _addr == OPERATOR_FEE_VAULT || _addr == SCHEMA_REGISTRY || _addr == EAS\\n            || _addr == GOVERNANCE_TOKEN || (_useInterop && _addr == CROSS_L2_INBOX)\\n            || (_useInterop && _addr == L2_TO_L2_CROSS_DOMAIN_MESSENGER) || (_useInterop && _addr == SUPERCHAIN_WETH)\\n            || (_useInterop && _addr == ETH_LIQUIDITY) || (_useInterop && _addr == SUPERCHAIN_TOKEN_BRIDGE);\\n    }\\n\\n    function isPredeployNamespace(address _addr) internal pure returns (bool) {\\n        return uint160(_addr) >> 11 == uint160(0x4200000000000000000000000000000000000000) >> 11;\\n    }\\n\\n    /// @notice Function to compute the expected address of the predeploy implementation\\n    ///         in the genesis state.\\n    function predeployToCodeNamespace(address _addr) internal pure returns (address) {\\n        require(\\n            isPredeployNamespace(_addr), \\\"Predeploys: can only derive code-namespace address for predeploy addresses\\\"\\n        );\\n        return address(\\n            uint160(uint256(uint160(_addr)) & 0xffff | uint256(uint160(0xc0D3C0d3C0d3C0D3c0d3C0d3c0D3C0d3c0d30000)))\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/universal/ISemver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ISemver\\n/// @notice ISemver is a simple contract for ensuring that contracts are\\n///         versioned using semantic versioning.\\ninterface ISemver {\\n    /// @notice Getter for the semantic version of the contract. This is not\\n    ///         meant to be used onchain but instead meant to be used by offchain\\n    ///         tooling.\\n    /// @return Semver contract version as a string.\\n    function version() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/ISuperchainConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ISuperchainConfig {\\n    enum UpdateType {\\n        GUARDIAN\\n    }\\n\\n    event ConfigUpdate(UpdateType indexed updateType, bytes data);\\n    event Initialized(uint8 version);\\n    event Paused(string identifier);\\n    event Unpaused();\\n\\n    function GUARDIAN_SLOT() external view returns (bytes32);\\n    function PAUSED_SLOT() external view returns (bytes32);\\n    function guardian() external view returns (address guardian_);\\n    function initialize(address _guardian, bool _paused) external;\\n    function pause(string memory _identifier) external;\\n    function paused() external view returns (bool paused_);\\n    function unpause() external;\\n    function version() external view returns (string memory);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/IOptimismPortal2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Types } from \\\"src/libraries/Types.sol\\\";\\nimport { GameType, Timestamp } from \\\"src/dispute/lib/LibUDT.sol\\\";\\nimport { IDisputeGame } from \\\"interfaces/dispute/IDisputeGame.sol\\\";\\nimport { IDisputeGameFactory } from \\\"interfaces/dispute/IDisputeGameFactory.sol\\\";\\nimport { ISystemConfig } from \\\"interfaces/L1/ISystemConfig.sol\\\";\\nimport { ISuperchainConfig } from \\\"interfaces/L1/ISuperchainConfig.sol\\\";\\n\\ninterface IOptimismPortal2 {\\n    error AlreadyFinalized();\\n    error BadTarget();\\n    error Blacklisted();\\n    error CallPaused();\\n    error ContentLengthMismatch();\\n    error EmptyItem();\\n    error GasEstimation();\\n    error InvalidDataRemainder();\\n    error InvalidDisputeGame();\\n    error InvalidGameType();\\n    error InvalidHeader();\\n    error InvalidMerkleProof();\\n    error InvalidProof();\\n    error LargeCalldata();\\n    error NonReentrant();\\n    error OutOfGas();\\n    error ProposalNotValidated();\\n    error SmallGasLimit();\\n    error Unauthorized();\\n    error UnexpectedList();\\n    error UnexpectedString();\\n    error Unproven();\\n    error LegacyGame();\\n\\n    event DisputeGameBlacklisted(IDisputeGame indexed disputeGame);\\n    event Initialized(uint8 version);\\n    event RespectedGameTypeSet(GameType indexed newGameType, Timestamp indexed updatedAt);\\n    event TransactionDeposited(address indexed from, address indexed to, uint256 indexed version, bytes opaqueData);\\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\\n    event WithdrawalProven(bytes32 indexed withdrawalHash, address indexed from, address indexed to);\\n    event WithdrawalProvenExtension1(bytes32 indexed withdrawalHash, address indexed proofSubmitter);\\n\\n    receive() external payable;\\n\\n    function blacklistDisputeGame(IDisputeGame _disputeGame) external;\\n    function checkWithdrawal(bytes32 _withdrawalHash, address _proofSubmitter) external view;\\n    function depositTransaction(\\n        address _to,\\n        uint256 _value,\\n        uint64 _gasLimit,\\n        bool _isCreation,\\n        bytes memory _data\\n    )\\n        external\\n        payable;\\n    function disputeGameBlacklist(IDisputeGame) external view returns (bool);\\n    function disputeGameFactory() external view returns (IDisputeGameFactory);\\n    function disputeGameFinalityDelaySeconds() external view returns (uint256);\\n    function donateETH() external payable;\\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx) external;\\n    function finalizeWithdrawalTransactionExternalProof(\\n        Types.WithdrawalTransaction memory _tx,\\n        address _proofSubmitter\\n    )\\n        external;\\n    function finalizedWithdrawals(bytes32) external view returns (bool);\\n    function guardian() external view returns (address);\\n    function initialize(\\n        IDisputeGameFactory _disputeGameFactory,\\n        ISystemConfig _systemConfig,\\n        ISuperchainConfig _superchainConfig,\\n        GameType _initialRespectedGameType\\n    )\\n        external;\\n    function l2Sender() external view returns (address);\\n    function minimumGasLimit(uint64 _byteCount) external pure returns (uint64);\\n    function numProofSubmitters(bytes32 _withdrawalHash) external view returns (uint256);\\n    function params() external view returns (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum); // nosemgrep\\n    function paused() external view returns (bool);\\n    function proofMaturityDelaySeconds() external view returns (uint256);\\n    function proofSubmitters(bytes32, uint256) external view returns (address);\\n    function proveWithdrawalTransaction(\\n        Types.WithdrawalTransaction memory _tx,\\n        uint256 _disputeGameIndex,\\n        Types.OutputRootProof memory _outputRootProof,\\n        bytes[] memory _withdrawalProof\\n    )\\n        external;\\n    function provenWithdrawals(\\n        bytes32,\\n        address\\n    )\\n        external\\n        view\\n        returns (IDisputeGame disputeGameProxy, uint64 timestamp); // nosemgrep\\n    function respectedGameType() external view returns (GameType);\\n    function respectedGameTypeUpdatedAt() external view returns (uint64);\\n    function setRespectedGameType(GameType _gameType) external;\\n    function superchainConfig() external view returns (ISuperchainConfig);\\n    function systemConfig() external view returns (ISystemConfig);\\n    function version() external pure returns (string memory);\\n\\n    function __constructor__(uint256 _proofMaturityDelaySeconds, uint256 _disputeGameFinalityDelaySeconds) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title SafeCall\\n/// @notice Perform low level safe calls\\nlibrary SafeCall {\\n    /// @notice Performs a low level call without copying any returndata.\\n    /// @dev Passes no calldata to the call context.\\n    /// @param _target   Address to call\\n    /// @param _gas      Amount of gas to pass to the call\\n    /// @param _value    Amount of value to pass to the call\\n    function send(address _target, uint256 _gas, uint256 _value) internal returns (bool success_) {\\n        assembly {\\n            success_ :=\\n                call(\\n                    _gas, // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    0, // inloc\\n                    0, // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n    }\\n\\n    /// @notice Perform a low level call with all gas without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _value    Amount of value to pass to the call\\n    function send(address _target, uint256 _value) internal returns (bool success_) {\\n        success_ = send(_target, gasleft(), _value);\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _gas      Amount of gas to pass to the call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(\\n        address _target,\\n        uint256 _gas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (bool success_)\\n    {\\n        assembly {\\n            success_ :=\\n                call(\\n                    _gas, // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    add(_calldata, 32), // inloc\\n                    mload(_calldata), // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(address _target, uint256 _value, bytes memory _calldata) internal returns (bool success_) {\\n        success_ = call({ _target: _target, _gas: gasleft(), _value: _value, _calldata: _calldata });\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(address _target, bytes memory _calldata) internal returns (bool success_) {\\n        success_ = call({ _target: _target, _gas: gasleft(), _value: 0, _calldata: _calldata });\\n    }\\n\\n    /// @notice Helper function to determine if there is sufficient gas remaining within the context\\n    ///         to guarantee that the minimum gas requirement for a call will be met as well as\\n    ///         optionally reserving a specified amount of gas for after the call has concluded.\\n    /// @param _minGas      The minimum amount of gas that may be passed to the target context.\\n    /// @param _reservedGas Optional amount of gas to reserve for the caller after the execution\\n    ///                     of the target context.\\n    /// @return `true` if there is enough gas remaining to safely supply `_minGas` to the target\\n    ///         context as well as reserve `_reservedGas` for the caller after the execution of\\n    ///         the target context.\\n    /// @dev !!!!! FOOTGUN ALERT !!!!!\\n    ///      1.) The 40_000 base buffer is to account for the worst case of the dynamic cost of the\\n    ///          `CALL` opcode's `address_access_cost`, `positive_value_cost`, and\\n    ///          `value_to_empty_account_cost` factors with an added buffer of 5,700 gas. It is\\n    ///          still possible to self-rekt by initiating a withdrawal with a minimum gas limit\\n    ///          that does not account for the `memory_expansion_cost` & `code_execution_cost`\\n    ///          factors of the dynamic cost of the `CALL` opcode.\\n    ///      2.) This function should *directly* precede the external call if possible. There is an\\n    ///          added buffer to account for gas consumed between this check and the call, but it\\n    ///          is only 5,700 gas.\\n    ///      3.) Because EIP-150 ensures that a maximum of 63/64ths of the remaining gas in the call\\n    ///          frame may be passed to a subcontext, we need to ensure that the gas will not be\\n    ///          truncated.\\n    ///      4.) Use wisely. This function is not a silver bullet.\\n    function hasMinGas(uint256 _minGas, uint256 _reservedGas) internal view returns (bool) {\\n        bool _hasMinGas;\\n        assembly {\\n            // Equation: gas × 63 ≥ minGas × 64 + 63(40_000 + reservedGas)\\n            _hasMinGas := iszero(lt(mul(gas(), 63), add(mul(_minGas, 64), mul(add(40000, _reservedGas), 63))))\\n        }\\n        return _hasMinGas;\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata. This function\\n    ///         will revert if the call cannot be performed with the specified minimum\\n    ///         gas.\\n    /// @param _target   Address to call\\n    /// @param _minGas   The minimum amount of gas that may be passed to the call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function callWithMinGas(\\n        address _target,\\n        uint256 _minGas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        bool _success;\\n        bool _hasMinGas = hasMinGas(_minGas, 0);\\n        assembly {\\n            // Assertion: gasleft() >= (_minGas * 64) / 63 + 40_000\\n            if iszero(_hasMinGas) {\\n                // Store the \\\"Error(string)\\\" selector in scratch space.\\n                mstore(0, 0x08c379a0)\\n                // Store the pointer to the string length in scratch space.\\n                mstore(32, 32)\\n                // Store the string.\\n                //\\n                // SAFETY:\\n                // - We pad the beginning of the string with two zero bytes as well as the\\n                // length (24) to ensure that we override the free memory pointer at offset\\n                // 0x40. This is necessary because the free memory pointer is likely to\\n                // be greater than 1 byte when this function is called, but it is incredibly\\n                // unlikely that it will be greater than 3 bytes. As for the data within\\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\\n                // - It's fine to clobber the free memory pointer, we're reverting.\\n                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\\n\\n                // Revert with 'Error(\\\"SafeCall: Not enough gas\\\")'\\n                revert(28, 100)\\n            }\\n\\n            // The call will be supplied at least ((_minGas * 64) / 63) gas due to the\\n            // above assertion. This ensures that, in all circumstances (except for when the\\n            // `_minGas` does not account for the `memory_expansion_cost` and `code_execution_cost`\\n            // factors of the dynamic cost of the `CALL` opcode), the call will receive at least\\n            // the minimum amount of gas specified.\\n            _success :=\\n                call(\\n                    gas(), // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    add(_calldata, 32), // inloc\\n                    mload(_calldata), // inlen\\n                    0x00, // outloc\\n                    0x00 // outlen\\n                )\\n        }\\n        return _success;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Hashing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport { Types } from \\\"src/libraries/Types.sol\\\";\\nimport { Encoding } from \\\"src/libraries/Encoding.sol\\\";\\n\\n/// @title Hashing\\n/// @notice Hashing handles Optimism's various different hashing schemes.\\nlibrary Hashing {\\n    /// @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\\n    ///         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\\n    ///         system.\\n    /// @param _tx User deposit transaction to hash.\\n    /// @return Hash of the RLP encoded L2 deposit transaction.\\n    function hashDepositTransaction(Types.UserDepositTransaction memory _tx) internal pure returns (bytes32) {\\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\\n    }\\n\\n    /// @notice Computes the deposit transaction's \\\"source hash\\\", a value that guarantees the hash\\n    ///         of the L2 transaction that corresponds to a deposit is unique and is\\n    ///         deterministically generated from L1 transaction data.\\n    /// @param _l1BlockHash Hash of the L1 block where the deposit was included.\\n    /// @param _logIndex    The index of the log that created the deposit transaction.\\n    /// @return Hash of the deposit transaction's \\\"source hash\\\".\\n    function hashDepositSource(bytes32 _l1BlockHash, uint256 _logIndex) internal pure returns (bytes32) {\\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\\n        return keccak256(abi.encode(bytes32(0), depositId));\\n    }\\n\\n    /// @notice Hashes the cross domain message based on the version that is encoded into the\\n    ///         message nonce.\\n    /// @param _nonce    Message nonce with version encoded into the first two bytes.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return hashCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Hashing: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /// @notice Hashes a cross domain message based on the V0 (legacy) encoding.\\n    /// @param _target Address of the target of the message.\\n    /// @param _sender Address of the sender of the message.\\n    /// @param _data   Data to send with the message.\\n    /// @param _nonce  Message nonce.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Encoding.encodeCrossDomainMessageV0(_target, _sender, _data, _nonce));\\n    }\\n\\n    /// @notice Hashes a cross domain message based on the V1 (current) encoding.\\n    /// @param _nonce    Message nonce.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Encoding.encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data));\\n    }\\n\\n    /// @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\\n    /// @param _tx Withdrawal transaction to hash.\\n    /// @return Hashed withdrawal transaction.\\n    function hashWithdrawal(Types.WithdrawalTransaction memory _tx) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data));\\n    }\\n\\n    /// @notice Hashes the various elements of an output root proof into an output root hash which\\n    ///         can be used to check if the proof is valid.\\n    /// @param _outputRootProof Output root proof which should hash to an output root.\\n    /// @return Hashed output root proof.\\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                _outputRootProof.version,\\n                _outputRootProof.stateRoot,\\n                _outputRootProof.messagePasserStorageRoot,\\n                _outputRootProof.latestBlockhash\\n            )\\n        );\\n    }\\n\\n    /// @notice Generates a unique hash for cross l2 messages. This hash is used to identify\\n    ///         the message and ensure it is not relayed more than once.\\n    /// @param _destination Chain ID of the destination chain.\\n    /// @param _source Chain ID of the source chain.\\n    /// @param _nonce Unique nonce associated with the message to prevent replay attacks.\\n    /// @param _sender Address of the user who originally sent the message.\\n    /// @param _target Address of the contract or wallet that the message is targeting on the destination chain.\\n    /// @param _message The message payload to be relayed to the target on the destination chain.\\n    /// @return Hash of the encoded message parameters, used to uniquely identify the message.\\n    function hashL2toL2CrossDomainMessage(\\n        uint256 _destination,\\n        uint256 _source,\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        bytes memory _message\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(_destination, _source, _nonce, _sender, _target, _message));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Encoding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport { Types } from \\\"src/libraries/Types.sol\\\";\\nimport { Hashing } from \\\"src/libraries/Hashing.sol\\\";\\nimport { RLPWriter } from \\\"src/libraries/rlp/RLPWriter.sol\\\";\\n\\n/// @title Encoding\\n/// @notice Encoding handles Optimism's various different encoding schemes.\\nlibrary Encoding {\\n    /// @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\\n    ///         to the L2 system. Useful for searching for a deposit in the L2 system. The\\n    ///         transaction is prefixed with 0x7e to identify its EIP-2718 type.\\n    /// @param _tx User deposit transaction to encode.\\n    /// @return RLP encoded L2 deposit transaction.\\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx) internal pure returns (bytes memory) {\\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\\n        bytes[] memory raw = new bytes[](8);\\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\\n        raw[1] = RLPWriter.writeAddress(_tx.from);\\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\\\"\\\") : RLPWriter.writeAddress(_tx.to);\\n        raw[3] = RLPWriter.writeUint(_tx.mint);\\n        raw[4] = RLPWriter.writeUint(_tx.value);\\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\\n        raw[6] = RLPWriter.writeBool(false);\\n        raw[7] = RLPWriter.writeBytes(_tx.data);\\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\\n    }\\n\\n    /// @notice Encodes the cross domain message based on the version that is encoded into the\\n    ///         message nonce.\\n    /// @param _nonce    Message nonce with version encoded into the first two bytes.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        (, uint16 version) = decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Encoding: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /// @notice Encodes a cross domain message based on the V0 (legacy) encoding.\\n    /// @param _target Address of the target of the message.\\n    /// @param _sender Address of the sender of the message.\\n    /// @param _data   Data to send with the message.\\n    /// @param _nonce  Message nonce.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        // nosemgrep: sol-style-use-abi-encodecall\\n        return abi.encodeWithSignature(\\\"relayMessage(address,address,bytes,uint256)\\\", _target, _sender, _data, _nonce);\\n    }\\n\\n    /// @notice Encodes a cross domain message based on the V1 (current) encoding.\\n    /// @param _nonce    Message nonce.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        // nosemgrep: sol-style-use-abi-encodecall\\n        return abi.encodeWithSignature(\\n            \\\"relayMessage(uint256,address,address,uint256,uint256,bytes)\\\",\\n            _nonce,\\n            _sender,\\n            _target,\\n            _value,\\n            _gasLimit,\\n            _data\\n        );\\n    }\\n\\n    /// @notice Adds a version number into the first two bytes of a message nonce.\\n    /// @param _nonce   Message nonce to encode into.\\n    /// @param _version Version number to encode into the message nonce.\\n    /// @return Message nonce with version encoded into the first two bytes.\\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\\n        uint256 nonce;\\n        assembly {\\n            nonce := or(shl(240, _version), _nonce)\\n        }\\n        return nonce;\\n    }\\n\\n    /// @notice Pulls the version out of a version-encoded nonce.\\n    /// @param _nonce Message nonce with version encoded into the first two bytes.\\n    /// @return Nonce without encoded version.\\n    /// @return Version of the message.\\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\\n        uint240 nonce;\\n        uint16 version;\\n        assembly {\\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            version := shr(240, _nonce)\\n        }\\n        return (nonce, version);\\n    }\\n\\n    /// @notice Returns an appropriately encoded call to L1Block.setL1BlockValuesEcotone\\n    /// @param _baseFeeScalar       L1 base fee Scalar\\n    /// @param _blobBaseFeeScalar   L1 blob base fee Scalar\\n    /// @param _sequenceNumber      Number of L2 blocks since epoch start.\\n    /// @param _timestamp           L1 timestamp.\\n    /// @param _number              L1 blocknumber.\\n    /// @param _baseFee             L1 base fee.\\n    /// @param _blobBaseFee         L1 blob base fee.\\n    /// @param _hash                L1 blockhash.\\n    /// @param _batcherHash         Versioned hash to authenticate batcher by.\\n    function encodeSetL1BlockValuesEcotone(\\n        uint32 _baseFeeScalar,\\n        uint32 _blobBaseFeeScalar,\\n        uint64 _sequenceNumber,\\n        uint64 _timestamp,\\n        uint64 _number,\\n        uint256 _baseFee,\\n        uint256 _blobBaseFee,\\n        bytes32 _hash,\\n        bytes32 _batcherHash\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes4 functionSignature = bytes4(keccak256(\\\"setL1BlockValuesEcotone()\\\"));\\n        return abi.encodePacked(\\n            functionSignature,\\n            _baseFeeScalar,\\n            _blobBaseFeeScalar,\\n            _sequenceNumber,\\n            _timestamp,\\n            _number,\\n            _baseFee,\\n            _blobBaseFee,\\n            _hash,\\n            _batcherHash\\n        );\\n    }\\n\\n    /// @notice Returns an appropriately encoded call to L1Block.setL1BlockValuesIsthmus\\n    /// @param _baseFeeScalar       L1 base fee Scalar\\n    /// @param _blobBaseFeeScalar   L1 blob base fee Scalar\\n    /// @param _sequenceNumber      Number of L2 blocks since epoch start.\\n    /// @param _timestamp           L1 timestamp.\\n    /// @param _number              L1 blocknumber.\\n    /// @param _baseFee             L1 base fee.\\n    /// @param _blobBaseFee         L1 blob base fee.\\n    /// @param _hash                L1 blockhash.\\n    /// @param _batcherHash         Versioned hash to authenticate batcher by.\\n    /// @param _operatorFeeScalar   Operator fee scalar.\\n    /// @param _operatorFeeConstant Operator fee constant.\\n    function encodeSetL1BlockValuesIsthmus(\\n        uint32 _baseFeeScalar,\\n        uint32 _blobBaseFeeScalar,\\n        uint64 _sequenceNumber,\\n        uint64 _timestamp,\\n        uint64 _number,\\n        uint256 _baseFee,\\n        uint256 _blobBaseFee,\\n        bytes32 _hash,\\n        bytes32 _batcherHash,\\n        uint32 _operatorFeeScalar,\\n        uint64 _operatorFeeConstant\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes4 functionSignature = bytes4(keccak256(\\\"setL1BlockValuesIsthmus()\\\"));\\n        return abi.encodePacked(\\n            functionSignature,\\n            _baseFeeScalar,\\n            _blobBaseFeeScalar,\\n            _sequenceNumber,\\n            _timestamp,\\n            _number,\\n            _baseFee,\\n            _blobBaseFee,\\n            _hash,\\n            _batcherHash,\\n            _operatorFeeScalar,\\n            _operatorFeeConstant\\n        );\\n    }\\n\\n    /// @notice Returns an appropriately encoded call to L1Block.setL1BlockValuesInterop\\n    /// @param _baseFeeScalar       L1 base fee Scalar\\n    /// @param _blobBaseFeeScalar   L1 blob base fee Scalar\\n    /// @param _sequenceNumber      Number of L2 blocks since epoch start.\\n    /// @param _timestamp           L1 timestamp.\\n    /// @param _number              L1 blocknumber.\\n    /// @param _baseFee             L1 base fee.\\n    /// @param _blobBaseFee         L1 blob base fee.\\n    /// @param _hash                L1 blockhash.\\n    /// @param _batcherHash         Versioned hash to authenticate batcher by.\\n    function encodeSetL1BlockValuesInterop(\\n        uint32 _baseFeeScalar,\\n        uint32 _blobBaseFeeScalar,\\n        uint64 _sequenceNumber,\\n        uint64 _timestamp,\\n        uint64 _number,\\n        uint256 _baseFee,\\n        uint256 _blobBaseFee,\\n        bytes32 _hash,\\n        bytes32 _batcherHash\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes4 functionSignature = bytes4(keccak256(\\\"setL1BlockValuesInterop()\\\"));\\n        return abi.encodePacked(\\n            functionSignature,\\n            _baseFeeScalar,\\n            _blobBaseFeeScalar,\\n            _sequenceNumber,\\n            _timestamp,\\n            _number,\\n            _baseFee,\\n            _blobBaseFee,\\n            _hash,\\n            _batcherHash\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Interfaces\\nimport { IResourceMetering } from \\\"interfaces/L1/IResourceMetering.sol\\\";\\n\\n/// @title Constants\\n/// @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\\n///         the stuff used in multiple contracts. Constants that only apply to a single contract\\n///         should be defined in that contract instead.\\nlibrary Constants {\\n    /// @notice Special address to be used as the tx origin for gas estimation calls in the\\n    ///         OptimismPortal and CrossDomainMessenger calls. You only need to use this address if\\n    ///         the minimum gas limit specified by the user is not actually enough to execute the\\n    ///         given message and you're attempting to estimate the actual necessary gas limit. We\\n    ///         use address(1) because it's the ecrecover precompile and therefore guaranteed to\\n    ///         never have any code on any EVM chain.\\n    address internal constant ESTIMATION_ADDRESS = address(1);\\n\\n    /// @notice Value used for the L2 sender storage slot in both the OptimismPortal and the\\n    ///         CrossDomainMessenger contracts before an actual sender is set. This value is\\n    ///         non-zero to reduce the gas cost of message passing transactions.\\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\\n\\n    /// @notice The storage slot that holds the address of a proxy implementation.\\n    /// @dev `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`\\n    bytes32 internal constant PROXY_IMPLEMENTATION_ADDRESS =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice The storage slot that holds the address of the owner.\\n    /// @dev `bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)`\\n    bytes32 internal constant PROXY_OWNER_ADDRESS = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice The address that represents ether when dealing with ERC20 token addresses.\\n    address internal constant ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice The address that represents the system caller responsible for L1 attributes\\n    ///         transactions.\\n    address internal constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\\n\\n    /// @notice Returns the default values for the ResourceConfig. These are the recommended values\\n    ///         for a production network.\\n    function DEFAULT_RESOURCE_CONFIG() internal pure returns (IResourceMetering.ResourceConfig memory) {\\n        IResourceMetering.ResourceConfig memory config = IResourceMetering.ResourceConfig({\\n            maxResourceLimit: 20_000_000,\\n            elasticityMultiplier: 10,\\n            baseFeeMaxChangeDenominator: 8,\\n            minimumBaseFee: 1 gwei,\\n            systemTxMaxGas: 1_000_000,\\n            maximumBaseFee: type(uint128).max\\n        });\\n        return config;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Types\\n/// @notice Contains various types used throughout the Optimism contract system.\\nlibrary Types {\\n    /// @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1\\n    ///         timestamp that the output root is posted. This timestamp is used to verify that the\\n    ///         finalization period has passed since the output root was submitted.\\n    /// @custom:field outputRoot    Hash of the L2 output.\\n    /// @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\\n    /// @custom:field l2BlockNumber L2 block number that the output corresponds to.\\n    struct OutputProposal {\\n        bytes32 outputRoot;\\n        uint128 timestamp;\\n        uint128 l2BlockNumber;\\n    }\\n\\n    /// @notice Struct representing the elements that are hashed together to generate an output root\\n    ///         which itself represents a snapshot of the L2 state.\\n    /// @custom:field version                  Version of the output root.\\n    /// @custom:field stateRoot                Root of the state trie at the block of this output.\\n    /// @custom:field messagePasserStorageRoot Root of the message passer storage trie.\\n    /// @custom:field latestBlockhash          Hash of the block this output was generated from.\\n    struct OutputRootProof {\\n        bytes32 version;\\n        bytes32 stateRoot;\\n        bytes32 messagePasserStorageRoot;\\n        bytes32 latestBlockhash;\\n    }\\n\\n    /// @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\\n    ///         user (as opposed to a system deposit transaction generated by the system).\\n    /// @custom:field from        Address of the sender of the transaction.\\n    /// @custom:field to          Address of the recipient of the transaction.\\n    /// @custom:field isCreation  True if the transaction is a contract creation.\\n    /// @custom:field value       Value to send to the recipient.\\n    /// @custom:field mint        Amount of ETH to mint.\\n    /// @custom:field gasLimit    Gas limit of the transaction.\\n    /// @custom:field data        Data of the transaction.\\n    /// @custom:field l1BlockHash Hash of the block the transaction was submitted in.\\n    /// @custom:field logIndex    Index of the log in the block the transaction was submitted in.\\n    struct UserDepositTransaction {\\n        address from;\\n        address to;\\n        bool isCreation;\\n        uint256 value;\\n        uint256 mint;\\n        uint64 gasLimit;\\n        bytes data;\\n        bytes32 l1BlockHash;\\n        uint256 logIndex;\\n    }\\n\\n    /// @notice Struct representing a withdrawal transaction.\\n    /// @custom:field nonce    Nonce of the withdrawal transaction\\n    /// @custom:field sender   Address of the sender of the transaction.\\n    /// @custom:field target   Address of the recipient of the transaction.\\n    /// @custom:field value    Value to send to the recipient.\\n    /// @custom:field gasLimit Gas limit of the transaction.\\n    /// @custom:field data     Data of the transaction.\\n    struct WithdrawalTransaction {\\n        uint256 nonce;\\n        address sender;\\n        address target;\\n        uint256 value;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    /// @notice Enum representing where the FeeVault withdraws funds to.\\n    /// @custom:value L1 FeeVault withdraws funds to L1.\\n    /// @custom:value L2 FeeVault withdraws funds to L2.\\n    enum WithdrawalNetwork {\\n        L1,\\n        L2\\n    }\\n}\\n\"\r\n    },\r\n    \"src/dispute/lib/LibUDT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n// Libraries\\nimport { Position } from \\\"src/dispute/lib/LibPosition.sol\\\";\\n\\nusing LibClaim for Claim global;\\nusing LibHash for Hash global;\\nusing LibDuration for Duration global;\\nusing LibClock for Clock global;\\nusing LibGameId for GameId global;\\nusing LibTimestamp for Timestamp global;\\nusing LibVMStatus for VMStatus global;\\nusing LibGameType for GameType global;\\n\\n/// @notice A `Clock` represents a packed `Duration` and `Timestamp`\\n/// @dev The packed layout of this type is as follows:\\n/// ┌────────────┬────────────────┐\\n/// │    Bits    │     Value      │\\n/// ├────────────┼────────────────┤\\n/// │ [0, 64)    │ Duration       │\\n/// │ [64, 128)  │ Timestamp      │\\n/// └────────────┴────────────────┘\\ntype Clock is uint128;\\n\\n/// @title LibClock\\n/// @notice This library contains helper functions for working with the `Clock` type.\\nlibrary LibClock {\\n    /// @notice Packs a `Duration` and `Timestamp` into a `Clock` type.\\n    /// @param _duration The `Duration` to pack into the `Clock` type.\\n    /// @param _timestamp The `Timestamp` to pack into the `Clock` type.\\n    /// @return clock_ The `Clock` containing the `_duration` and `_timestamp`.\\n    function wrap(Duration _duration, Timestamp _timestamp) internal pure returns (Clock clock_) {\\n        assembly {\\n            clock_ := or(shl(0x40, _duration), _timestamp)\\n        }\\n    }\\n\\n    /// @notice Pull the `Duration` out of a `Clock` type.\\n    /// @param _clock The `Clock` type to pull the `Duration` out of.\\n    /// @return duration_ The `Duration` pulled out of `_clock`.\\n    function duration(Clock _clock) internal pure returns (Duration duration_) {\\n        // Shift the high-order 64 bits into the low-order 64 bits, leaving only the `duration`.\\n        assembly {\\n            duration_ := shr(0x40, _clock)\\n        }\\n    }\\n\\n    /// @notice Pull the `Timestamp` out of a `Clock` type.\\n    /// @param _clock The `Clock` type to pull the `Timestamp` out of.\\n    /// @return timestamp_ The `Timestamp` pulled out of `_clock`.\\n    function timestamp(Clock _clock) internal pure returns (Timestamp timestamp_) {\\n        // Clean the high-order 192 bits by shifting the clock left and then right again, leaving\\n        // only the `timestamp`.\\n        assembly {\\n            timestamp_ := shr(0xC0, shl(0xC0, _clock))\\n        }\\n    }\\n\\n    /// @notice Get the value of a `Clock` type in the form of the underlying uint128.\\n    /// @param _clock The `Clock` type to get the value of.\\n    /// @return clock_ The value of the `Clock` type as a uint128 type.\\n    function raw(Clock _clock) internal pure returns (uint128 clock_) {\\n        assembly {\\n            clock_ := _clock\\n        }\\n    }\\n}\\n\\n/// @notice A `GameId` represents a packed 4 byte game ID, a 8 byte timestamp, and a 20 byte address.\\n/// @dev The packed layout of this type is as follows:\\n/// ┌───────────┬───────────┐\\n/// │   Bits    │   Value   │\\n/// ├───────────┼───────────┤\\n/// │ [0, 32)   │ Game Type │\\n/// │ [32, 96)  │ Timestamp │\\n/// │ [96, 256) │ Address   │\\n/// └───────────┴───────────┘\\ntype GameId is bytes32;\\n\\n/// @title LibGameId\\n/// @notice Utility functions for packing and unpacking GameIds.\\nlibrary LibGameId {\\n    /// @notice Packs values into a 32 byte GameId type.\\n    /// @param _gameType The game type.\\n    /// @param _timestamp The timestamp of the game's creation.\\n    /// @param _gameProxy The game proxy address.\\n    /// @return gameId_ The packed GameId.\\n    function pack(\\n        GameType _gameType,\\n        Timestamp _timestamp,\\n        address _gameProxy\\n    )\\n        internal\\n        pure\\n        returns (GameId gameId_)\\n    {\\n        assembly {\\n            gameId_ := or(or(shl(224, _gameType), shl(160, _timestamp)), _gameProxy)\\n        }\\n    }\\n\\n    /// @notice Unpacks values from a 32 byte GameId type.\\n    /// @param _gameId The packed GameId.\\n    /// @return gameType_ The game type.\\n    /// @return timestamp_ The timestamp of the game's creation.\\n    /// @return gameProxy_ The game proxy address.\\n    function unpack(GameId _gameId)\\n        internal\\n        pure\\n        returns (GameType gameType_, Timestamp timestamp_, address gameProxy_)\\n    {\\n        assembly {\\n            gameType_ := shr(224, _gameId)\\n            timestamp_ := and(shr(160, _gameId), 0xFFFFFFFFFFFFFFFF)\\n            gameProxy_ := and(_gameId, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        }\\n    }\\n}\\n\\n/// @notice A claim represents an MPT root representing the state of the fault proof program.\\ntype Claim is bytes32;\\n\\n/// @title LibClaim\\n/// @notice This library contains helper functions for working with the `Claim` type.\\nlibrary LibClaim {\\n    /// @notice Get the value of a `Claim` type in the form of the underlying bytes32.\\n    /// @param _claim The `Claim` type to get the value of.\\n    /// @return claim_ The value of the `Claim` type as a bytes32 type.\\n    function raw(Claim _claim) internal pure returns (bytes32 claim_) {\\n        assembly {\\n            claim_ := _claim\\n        }\\n    }\\n\\n    /// @notice Hashes a claim and a position together.\\n    /// @param _claim A Claim type.\\n    /// @param _position The position of `claim`.\\n    /// @param _challengeIndex The index of the claim being moved against.\\n    /// @return claimHash_ A hash of abi.encodePacked(claim, position|challengeIndex);\\n    function hashClaimPos(\\n        Claim _claim,\\n        Position _position,\\n        uint256 _challengeIndex\\n    )\\n        internal\\n        pure\\n        returns (Hash claimHash_)\\n    {\\n        assembly {\\n            mstore(0x00, _claim)\\n            mstore(0x20, or(shl(128, _position), and(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, _challengeIndex)))\\n            claimHash_ := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\\n/// @notice A dedicated duration type.\\n/// @dev Unit: seconds\\ntype Duration is uint64;\\n\\n/// @title LibDuration\\n/// @notice This library contains helper functions for working with the `Duration` type.\\nlibrary LibDuration {\\n    /// @notice Get the value of a `Duration` type in the form of the underlying uint64.\\n    /// @param _duration The `Duration` type to get the value of.\\n    /// @return duration_ The value of the `Duration` type as a uint64 type.\\n    function raw(Duration _duration) internal pure returns (uint64 duration_) {\\n        assembly {\\n            duration_ := _duration\\n        }\\n    }\\n}\\n\\n/// @notice A custom type for a generic hash.\\ntype Hash is bytes32;\\n\\n/// @title LibHash\\n/// @notice This library contains helper functions for working with the `Hash` type.\\nlibrary LibHash {\\n    /// @notice Get the value of a `Hash` type in the form of the underlying bytes32.\\n    /// @param _hash The `Hash` type to get the value of.\\n    /// @return hash_ The value of the `Hash` type as a bytes32 type.\\n    function raw(Hash _hash) internal pure returns (bytes32 hash_) {\\n        assembly {\\n            hash_ := _hash\\n        }\\n    }\\n}\\n\\n/// @notice A dedicated timestamp type.\\ntype Timestamp is uint64;\\n\\n/// @title LibTimestamp\\n/// @notice This library contains helper functions for working with the `Timestamp` type.\\nlibrary LibTimestamp {\\n    /// @notice Get the value of a `Timestamp` type in the form of the underlying uint64.\\n    /// @param _timestamp The `Timestamp` type to get the value of.\\n    /// @return timestamp_ The value of the `Timestamp` type as a uint64 type.\\n    function raw(Timestamp _timestamp) internal pure returns (uint64 timestamp_) {\\n        assembly {\\n            timestamp_ := _timestamp\\n        }\\n    }\\n}\\n\\n/// @notice A `VMStatus` represents the status of a VM execution.\\ntype VMStatus is uint8;\\n\\n/// @title LibVMStatus\\n/// @notice This library contains helper functions for working with the `VMStatus` type.\\nlibrary LibVMStatus {\\n    /// @notice Get the value of a `VMStatus` type in the form of the underlying uint8.\\n    /// @param _vmstatus The `VMStatus` type to get the value of.\\n    /// @return vmstatus_ The value of the `VMStatus` type as a uint8 type.\\n    function raw(VMStatus _vmstatus) internal pure returns (uint8 vmstatus_) {\\n        assembly {\\n            vmstatus_ := _vmstatus\\n        }\\n    }\\n}\\n\\n/// @notice A `GameType` represents the type of game being played.\\ntype GameType is uint32;\\n\\n/// @title LibGameType\\n/// @notice This library contains helper functions for working with the `GameType` type.\\nlibrary LibGameType {\\n    /// @notice Get the value of a `GameType` type in the form of the underlying uint32.\\n    /// @param _gametype The `GameType` type to get the value of.\\n    /// @return gametype_ The value of the `GameType` type as a uint32 type.\\n    function raw(GameType _gametype) internal pure returns (uint32 gametype_) {\\n        assembly {\\n            gametype_ := _gametype\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IDisputeGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IInitializable } from \\\"interfaces/dispute/IInitializable.sol\\\";\\nimport { Timestamp, GameStatus, GameType, Claim, Hash } from \\\"src/dispute/lib/Types.sol\\\";\\n\\ninterface IDisputeGame is IInitializable {\\n    event Resolved(GameStatus indexed status);\\n\\n    function createdAt() external view returns (Timestamp);\\n    function resolvedAt() external view returns (Timestamp);\\n    function status() external view returns (GameStatus);\\n    function gameType() external view returns (GameType gameType_);\\n    function gameCreator() external pure returns (address creator_);\\n    function rootClaim() external pure returns (Claim rootClaim_);\\n    function l1Head() external pure returns (Hash l1Head_);\\n    function l2BlockNumber() external pure returns (uint256 l2BlockNumber_);\\n    function extraData() external pure returns (bytes memory extraData_);\\n    function resolve() external returns (GameStatus status_);\\n    function gameData() external view returns (GameType gameType_, Claim rootClaim_, bytes memory extraData_);\\n    function wasRespectedGameTypeWhenCreated() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IDisputeGameFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IDisputeGame } from \\\"interfaces/dispute/IDisputeGame.sol\\\";\\nimport { GameId, Timestamp, Claim, Hash, GameType } from \\\"src/dispute/lib/Types.sol\\\";\\n\\ninterface IDisputeGameFactory {\\n    struct GameSearchResult {\\n        uint256 index;\\n        GameId metadata;\\n        Timestamp timestamp;\\n        Claim rootClaim;\\n        bytes extraData;\\n    }\\n\\n    error GameAlreadyExists(Hash uuid);\\n    error IncorrectBondAmount();\\n    error NoImplementation(GameType gameType);\\n\\n    event DisputeGameCreated(address indexed disputeProxy, GameType indexed gameType, Claim indexed rootClaim);\\n    event ImplementationSet(address indexed impl, GameType indexed gameType);\\n    event InitBondUpdated(GameType indexed gameType, uint256 indexed newBond);\\n    event Initialized(uint8 version);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function create(\\n        GameType _gameType,\\n        Claim _rootClaim,\\n        bytes memory _extraData\\n    )\\n        external\\n        payable\\n        returns (IDisputeGame proxy_);\\n    function findLatestGames(\\n        GameType _gameType,\\n        uint256 _start,\\n        uint256 _n\\n    )\\n        external\\n        view\\n        returns (GameSearchResult[] memory games_);\\n    function gameAtIndex(uint256 _index)\\n        external\\n        view\\n        returns (GameType gameType_, Timestamp timestamp_, IDisputeGame proxy_);\\n    function gameCount() external view returns (uint256 gameCount_);\\n    function gameImpls(GameType) external view returns (IDisputeGame);\\n    function games(\\n        GameType _gameType,\\n        Claim _rootClaim,\\n        bytes memory _extraData\\n    )\\n        external\\n        view\\n        returns (IDisputeGame proxy_, Timestamp timestamp_);\\n    function getGameUUID(\\n        GameType _gameType,\\n        Claim _rootClaim,\\n        bytes memory _extraData\\n    )\\n        external\\n        pure\\n        returns (Hash uuid_);\\n    function initBonds(GameType) external view returns (uint256);\\n    function initialize(address _owner) external;\\n    function owner() external view returns (address);\\n    function renounceOwnership() external;\\n    function setImplementation(GameType _gameType, IDisputeGame _impl) external;\\n    function setInitBond(GameType _gameType, uint256 _initBond) external;\\n    function transferOwnership(address newOwner) external; // nosemgrep\\n    function version() external view returns (string memory);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/ISystemConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IResourceMetering } from \\\"interfaces/L1/IResourceMetering.sol\\\";\\n\\ninterface ISystemConfig {\\n    enum UpdateType {\\n        BATCHER,\\n        FEE_SCALARS,\\n        GAS_LIMIT,\\n        UNSAFE_BLOCK_SIGNER,\\n        EIP_1559_PARAMS,\\n        OPERATOR_FEE_PARAMS\\n    }\\n\\n    struct Addresses {\\n        address l1CrossDomainMessenger;\\n        address l1ERC721Bridge;\\n        address l1StandardBridge;\\n        address disputeGameFactory;\\n        address optimismPortal;\\n        address optimismMintableERC20Factory;\\n    }\\n\\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\\n    event Initialized(uint8 version);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function BATCH_INBOX_SLOT() external view returns (bytes32);\\n    function DISPUTE_GAME_FACTORY_SLOT() external view returns (bytes32);\\n    function L1_CROSS_DOMAIN_MESSENGER_SLOT() external view returns (bytes32);\\n    function L1_ERC_721_BRIDGE_SLOT() external view returns (bytes32);\\n    function L1_STANDARD_BRIDGE_SLOT() external view returns (bytes32);\\n    function OPTIMISM_MINTABLE_ERC20_FACTORY_SLOT() external view returns (bytes32);\\n    function OPTIMISM_PORTAL_SLOT() external view returns (bytes32);\\n    function START_BLOCK_SLOT() external view returns (bytes32);\\n    function UNSAFE_BLOCK_SIGNER_SLOT() external view returns (bytes32);\\n    function VERSION() external view returns (uint256);\\n    function basefeeScalar() external view returns (uint32);\\n    function batchInbox() external view returns (address addr_);\\n    function batcherHash() external view returns (bytes32);\\n    function blobbasefeeScalar() external view returns (uint32);\\n    function disputeGameFactory() external view returns (address addr_);\\n    function gasLimit() external view returns (uint64);\\n    function eip1559Denominator() external view returns (uint32);\\n    function eip1559Elasticity() external view returns (uint32);\\n    function getAddresses() external view returns (Addresses memory);\\n    function initialize(\\n        address _owner,\\n        uint32 _basefeeScalar,\\n        uint32 _blobbasefeeScalar,\\n        bytes32 _batcherHash,\\n        uint64 _gasLimit,\\n        address _unsafeBlockSigner,\\n        IResourceMetering.ResourceConfig memory _config,\\n        address _batchInbox,\\n        Addresses memory _addresses\\n    )\\n        external;\\n    function l1CrossDomainMessenger() external view returns (address addr_);\\n    function l1ERC721Bridge() external view returns (address addr_);\\n    function l1StandardBridge() external view returns (address addr_);\\n    function maximumGasLimit() external pure returns (uint64);\\n    function minimumGasLimit() external view returns (uint64);\\n    function operatorFeeConstant() external view returns (uint64);\\n    function operatorFeeScalar() external view returns (uint32);\\n    function optimismMintableERC20Factory() external view returns (address addr_);\\n    function optimismPortal() external view returns (address addr_);\\n    function overhead() external view returns (uint256);\\n    function owner() external view returns (address);\\n    function renounceOwnership() external;\\n    function resourceConfig() external view returns (IResourceMetering.ResourceConfig memory);\\n    function scalar() external view returns (uint256);\\n    function setBatcherHash(bytes32 _batcherHash) external;\\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external;\\n    function setGasConfigEcotone(uint32 _basefeeScalar, uint32 _blobbasefeeScalar) external;\\n    function setGasLimit(uint64 _gasLimit) external;\\n    function setOperatorFeeScalars(uint32 _operatorFeeScalar, uint64 _operatorFeeConstant) external;\\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external;\\n    function setEIP1559Params(uint32 _denominator, uint32 _elasticity) external;\\n    function startBlock() external view returns (uint256 startBlock_);\\n    function transferOwnership(address newOwner) external; // nosemgrep\\n    function unsafeBlockSigner() external view returns (address addr_);\\n    function version() external pure returns (string memory);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/rlp/RLPWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n/// @title RLPWriter\\n/// @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n///         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n///         modifications to improve legibility.\\nlibrary RLPWriter {\\n    /// @notice RLP encodes a byte string.\\n    /// @param _in The byte string to encode.\\n    /// @return out_ The RLP encoded string in bytes.\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory out_) {\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            out_ = _in;\\n        } else {\\n            out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n    }\\n\\n    /// @notice RLP encodes a list of RLP encoded byte byte strings.\\n    /// @param _in The list of RLP encoded byte strings.\\n    /// @return list_ The RLP encoded list of items in bytes.\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory list_) {\\n        list_ = _flatten(_in);\\n        list_ = abi.encodePacked(_writeLength(list_.length, 192), list_);\\n    }\\n\\n    /// @notice RLP encodes a string.\\n    /// @param _in The string to encode.\\n    /// @return out_ The RLP encoded string in bytes.\\n    function writeString(string memory _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(bytes(_in));\\n    }\\n\\n    /// @notice RLP encodes an address.\\n    /// @param _in The address to encode.\\n    /// @return out_ The RLP encoded address in bytes.\\n    function writeAddress(address _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /// @notice RLP encodes a uint.\\n    /// @param _in The uint256 to encode.\\n    /// @return out_ The RLP encoded uint256 in bytes.\\n    function writeUint(uint256 _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(_toBinary(_in));\\n    }\\n\\n    /// @notice RLP encodes a bool.\\n    /// @param _in The bool to encode.\\n    /// @return out_ The RLP encoded bool in bytes.\\n    function writeBool(bool _in) internal pure returns (bytes memory out_) {\\n        out_ = new bytes(1);\\n        out_[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n    }\\n\\n    /// @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n    /// @param _len    The length of the string or the payload.\\n    /// @param _offset 128 if item is string, 192 if item is list.\\n    /// @return out_ RLP encoded bytes.\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory out_) {\\n        if (_len < 56) {\\n            out_ = new bytes(1);\\n            out_[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            out_ = new bytes(lenLen + 1);\\n            out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\\n            }\\n        }\\n    }\\n\\n    /// @notice Encode integer in big endian binary form with no leading zeroes.\\n    /// @param _x The integer to encode.\\n    /// @return out_ RLP encoded bytes.\\n    function _toBinary(uint256 _x) private pure returns (bytes memory out_) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        out_ = new bytes(32 - i);\\n        for (uint256 j = 0; j < out_.length; j++) {\\n            out_[j] = b[i++];\\n        }\\n    }\\n\\n    /// @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n    /// @notice Copies a piece of memory to another location.\\n    /// @param _dest Destination location.\\n    /// @param _src  Source location.\\n    /// @param _len  Length of memory to copy.\\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /// @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n    /// @notice Flattens a list of byte strings into one byte string.\\n    /// @param _list List of byte strings to flatten.\\n    /// @return out_ The flattened byte string.\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory out_) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        out_ = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(out_, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/IResourceMetering.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IResourceMetering {\\n    struct ResourceParams {\\n        uint128 prevBaseFee;\\n        uint64 prevBoughtGas;\\n        uint64 prevBlockNum;\\n    }\\n\\n    struct ResourceConfig {\\n        uint32 maxResourceLimit;\\n        uint8 elasticityMultiplier;\\n        uint8 baseFeeMaxChangeDenominator;\\n        uint32 minimumBaseFee;\\n        uint32 systemTxMaxGas;\\n        uint128 maximumBaseFee;\\n    }\\n\\n    error OutOfGas();\\n\\n    event Initialized(uint8 version);\\n\\n    function params() external view returns (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum); // nosemgrep\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"src/dispute/lib/LibPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nusing LibPosition for Position global;\\n\\n/// @notice A `Position` represents a position of a claim within the game tree.\\n/// @dev This is represented as a \\\"generalized index\\\" where the high-order bit\\n/// is the level in the tree and the remaining bits is a unique bit pattern, allowing\\n/// a unique identifier for each node in the tree. Mathematically, it is calculated\\n/// as 2^{depth} + indexAtDepth.\\ntype Position is uint128;\\n\\n/// @title LibPosition\\n/// @notice This library contains helper functions for working with the `Position` type.\\nlibrary LibPosition {\\n    /// @notice the `MAX_POSITION_BITLEN` is the number of bits that the `Position` type, and the implementation of\\n    ///         its behavior within this library, can safely support.\\n    uint8 internal constant MAX_POSITION_BITLEN = 126;\\n\\n    /// @notice Computes a generalized index (2^{depth} + indexAtDepth).\\n    /// @param _depth The depth of the position.\\n    /// @param _indexAtDepth The index at the depth of the position.\\n    /// @return position_ The computed generalized index.\\n    function wrap(uint8 _depth, uint128 _indexAtDepth) internal pure returns (Position position_) {\\n        assembly {\\n            // gindex = 2^{_depth} + _indexAtDepth\\n            position_ := add(shl(_depth, 1), _indexAtDepth)\\n        }\\n    }\\n\\n    /// @notice Pulls the `depth` out of a `Position` type.\\n    /// @param _position The generalized index to get the `depth` of.\\n    /// @return depth_ The `depth` of the `position` gindex.\\n    /// @custom:attribution Solady <https://github.com/Vectorized/Solady>\\n    function depth(Position _position) internal pure returns (uint8 depth_) {\\n        // Return the most significant bit offset, which signifies the depth of the gindex.\\n        assembly {\\n            depth_ := or(depth_, shl(6, lt(0xffffffffffffffff, shr(depth_, _position))))\\n            depth_ := or(depth_, shl(5, lt(0xffffffff, shr(depth_, _position))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            _position := shr(depth_, _position)\\n            _position := or(_position, shr(1, _position))\\n            _position := or(_position, shr(2, _position))\\n            _position := or(_position, shr(4, _position))\\n            _position := or(_position, shr(8, _position))\\n            _position := or(_position, shr(16, _position))\\n\\n            depth_ :=\\n                or(\\n                    depth_,\\n                    byte(\\n                        shr(251, mul(_position, shl(224, 0x07c4acdd))),\\n                        0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @notice Pulls the `indexAtDepth` out of a `Position` type.\\n    ///         The `indexAtDepth` is the left/right index of a position at a specific depth within\\n    ///         the binary tree, starting from index 0. For example, at gindex 2, the `depth` = 1\\n    ///         and the `indexAtDepth` = 0.\\n    /// @param _position The generalized index to get the `indexAtDepth` of.\\n    /// @return indexAtDepth_ The `indexAtDepth` of the `position` gindex.\\n    function indexAtDepth(Position _position) internal pure returns (uint128 indexAtDepth_) {\\n        // Return bits p_{msb-1}...p_{0}. This effectively pulls the 2^{depth} out of the gindex,\\n        // leaving only the `indexAtDepth`.\\n        uint256 msb = depth(_position);\\n        assembly {\\n            indexAtDepth_ := sub(_position, shl(msb, 1))\\n        }\\n    }\\n\\n    /// @notice Get the left child of `_position`.\\n    /// @param _position The position to get the left position of.\\n    /// @return left_ The position to the left of `position`.\\n    function left(Position _position) internal pure returns (Position left_) {\\n        assembly {\\n            left_ := shl(1, _position)\\n        }\\n    }\\n\\n    /// @notice Get the right child of `_position`\\n    /// @param _position The position to get the right position of.\\n    /// @return right_ The position to the right of `position`.\\n    function right(Position _position) internal pure returns (Position right_) {\\n        assembly {\\n            right_ := or(1, shl(1, _position))\\n        }\\n    }\\n\\n    /// @notice Get the parent position of `_position`.\\n    /// @param _position The position to get the parent position of.\\n    /// @return parent_ The parent position of `position`.\\n    function parent(Position _position) internal pure returns (Position parent_) {\\n        assembly {\\n            parent_ := shr(1, _position)\\n        }\\n    }\\n\\n    /// @notice Get the deepest, right most gindex relative to the `position`. This is equivalent to\\n    ///         calling `right` on a position until the maximum depth is reached.\\n    /// @param _position The position to get the relative deepest, right most gindex of.\\n    /// @param _maxDepth The maximum depth of the game.\\n    /// @return rightIndex_ The deepest, right most gindex relative to the `position`.\\n    function rightIndex(Position _position, uint256 _maxDepth) internal pure returns (Position rightIndex_) {\\n        uint256 msb = depth(_position);\\n        assembly {\\n            let remaining := sub(_maxDepth, msb)\\n            rightIndex_ := or(shl(remaining, _position), sub(shl(remaining, 1), 1))\\n        }\\n    }\\n\\n    /// @notice Get the deepest, right most trace index relative to the `position`. This is\\n    ///         equivalent to calling `right` on a position until the maximum depth is reached and\\n    ///         then finding its index at depth.\\n    /// @param _position The position to get the relative trace index of.\\n    /// @param _maxDepth The maximum depth of the game.\\n    /// @return traceIndex_ The trace index relative to the `position`.\\n    function traceIndex(Position _position, uint256 _maxDepth) internal pure returns (uint256 traceIndex_) {\\n        uint256 msb = depth(_position);\\n        assembly {\\n            let remaining := sub(_maxDepth, msb)\\n            traceIndex_ := sub(or(shl(remaining, _position), sub(shl(remaining, 1), 1)), shl(_maxDepth, 1))\\n        }\\n    }\\n\\n    /// @notice Gets the position of the highest ancestor of `_position` that commits to the same\\n    ///         trace index.\\n    /// @param _position The position to get the highest ancestor of.\\n    /// @return ancestor_ The highest ancestor of `position` that commits to the same trace index.\\n    function traceAncestor(Position _position) internal pure returns (Position ancestor_) {\\n        // Create a field with only the lowest unset bit of `_position` set.\\n        Position lsb;\\n        assembly {\\n            lsb := and(not(_position), add(_position, 1))\\n        }\\n        // Find the index of the lowest unset bit within the field.\\n        uint256 msb = depth(lsb);\\n        // The highest ancestor that commits to the same trace index is the original position\\n        // shifted right by the index of the lowest unset bit.\\n        assembly {\\n            let a := shr(msb, _position)\\n            // Bound the ancestor to the minimum gindex, 1.\\n            ancestor_ := or(a, iszero(a))\\n        }\\n    }\\n\\n    /// @notice Gets the position of the highest ancestor of `_position` that commits to the same\\n    ///         trace index, while still being below `_upperBoundExclusive`.\\n    /// @param _position The position to get the highest ancestor of.\\n    /// @param _upperBoundExclusive The exclusive upper depth bound, used to inform where to stop in order\\n    ///                             to not escape a sub-tree.\\n    /// @return ancestor_ The highest ancestor of `position` that commits to the same trace index.\\n    function traceAncestorBounded(\\n        Position _position,\\n        uint256 _upperBoundExclusive\\n    )\\n        internal\\n        pure\\n        returns (Position ancestor_)\\n    {\\n        // This function only works for positions that are below the upper bound.\\n        if (_position.depth() <= _upperBoundExclusive) {\\n            assembly {\\n                // Revert with `ClaimAboveSplit()`\\n                mstore(0x00, 0xb34b5c22)\\n                revert(0x1C, 0x04)\\n            }\\n        }\\n\\n        // Grab the global trace ancestor.\\n        ancestor_ = traceAncestor(_position);\\n\\n        // If the ancestor is above or at the upper bound, shift it to be below the upper bound.\\n        // This should be a special case that only covers positions that commit to the final leaf\\n        // in a sub-tree.\\n        if (ancestor_.depth() <= _upperBoundExclusive) {\\n            ancestor_ = ancestor_.rightIndex(_upperBoundExclusive + 1);\\n        }\\n    }\\n\\n    /// @notice Get the move position of `_position`, which is the left child of:\\n    ///         1. `_position` if `_isAttack` is true.\\n    ///         2. `_position | 1` if `_isAttack` is false.\\n    /// @param _position The position to get the relative attack/defense position of.\\n    /// @param _isAttack Whether or not the move is an attack move.\\n    /// @return move_ The move position relative to `position`.\\n    function move(Position _position, bool _isAttack) internal pure returns (Position move_) {\\n        assembly {\\n            move_ := shl(1, or(iszero(_isAttack), _position))\\n        }\\n    }\\n\\n    /// @notice Get the value of a `Position` type in the form of the underlying uint128.\\n    /// @param _position The position to get the value of.\\n    /// @return raw_ The value of the `position` as a uint128 type.\\n    function raw(Position _position) internal pure returns (uint128 raw_) {\\n        assembly {\\n            raw_ := _position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IInitializable {\\n    function initialize() external payable;\\n}\\n\"\r\n    },\r\n    \"src/dispute/lib/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n// Libraries\\nimport {\\n    Position,\\n    Hash,\\n    GameType,\\n    VMStatus,\\n    Timestamp,\\n    Duration,\\n    Clock,\\n    GameId,\\n    Claim,\\n    LibGameId,\\n    LibClock\\n} from \\\"src/dispute/lib/LibUDT.sol\\\";\\n\\n/// @notice The current status of the dispute game.\\nenum GameStatus {\\n    // The game is currently in progress, and has not been resolved.\\n    IN_PROGRESS,\\n    // The game has concluded, and the `rootClaim` was challenged successfully.\\n    CHALLENGER_WINS,\\n    // The game has concluded, and the `rootClaim` could not be contested.\\n    DEFENDER_WINS\\n}\\n\\n/// @notice The game's bond distribution type. Games are expected to start in the `UNDECIDED`\\n///         state, and then choose either `NORMAL` or `REFUND`.\\nenum BondDistributionMode {\\n    // Bond distribution strategy has not been chosen.\\n    UNDECIDED,\\n    // Bonds should be distributed as normal.\\n    NORMAL,\\n    // Bonds should be refunded to claimants.\\n    REFUND\\n}\\n\\n/// @notice Represents an L2 output root and the L2 block number at which it was generated.\\n/// @custom:field root The output root.\\n/// @custom:field l2BlockNumber The L2 block number at which the output root was generated.\\nstruct OutputRoot {\\n    Hash root;\\n    uint256 l2BlockNumber;\\n}\\n\\n/// @title GameTypes\\n/// @notice A library that defines the IDs of games that can be played.\\nlibrary GameTypes {\\n    /// @dev A dispute game type the uses the cannon vm.\\n    GameType internal constant CANNON = GameType.wrap(0);\\n\\n    /// @dev A permissioned dispute game type that uses the cannon vm.\\n    GameType internal constant PERMISSIONED_CANNON = GameType.wrap(1);\\n\\n    /// @notice A dispute game type that uses the asterisc vm.\\n    GameType internal constant ASTERISC = GameType.wrap(2);\\n\\n    /// @notice A dispute game type that uses the asterisc vm with Kona.\\n    GameType internal constant ASTERISC_KONA = GameType.wrap(3);\\n\\n    /// @notice A dispute game type that uses OP Succinct\\n    GameType internal constant OP_SUCCINCT = GameType.wrap(6);\\n\\n    /// @notice A dispute game type with short game duration for testing withdrawals.\\n    ///         Not intended for production use.\\n    GameType internal constant FAST = GameType.wrap(254);\\n\\n    /// @notice A dispute game type that uses an alphabet vm.\\n    ///         Not intended for production use.\\n    GameType internal constant ALPHABET = GameType.wrap(255);\\n\\n    /// @notice A dispute game type that uses RISC Zero's Kailua\\n    GameType internal constant KAILUA = GameType.wrap(1337);\\n}\\n\\n/// @title VMStatuses\\n/// @notice Named type aliases for the various valid VM status bytes.\\nlibrary VMStatuses {\\n    /// @notice The VM has executed successfully and the outcome is valid.\\n    VMStatus internal constant VALID = VMStatus.wrap(0);\\n\\n    /// @notice The VM has executed successfully and the outcome is invalid.\\n    VMStatus internal constant INVALID = VMStatus.wrap(1);\\n\\n    /// @notice The VM has paniced.\\n    VMStatus internal constant PANIC = VMStatus.wrap(2);\\n\\n    /// @notice The VM execution is still in progress.\\n    VMStatus internal constant UNFINISHED = VMStatus.wrap(3);\\n}\\n\\n/// @title LocalPreimageKey\\n/// @notice Named type aliases for local `PreimageOracle` key identifiers.\\nlibrary LocalPreimageKey {\\n    /// @notice The identifier for the L1 head hash.\\n    uint256 internal constant L1_HEAD_HASH = 0x01;\\n\\n    /// @notice The identifier for the starting output root.\\n    uint256 internal constant STARTING_OUTPUT_ROOT = 0x02;\\n\\n    /// @notice The identifier for the disputed output root.\\n    uint256 internal constant DISPUTED_OUTPUT_ROOT = 0x03;\\n\\n    /// @notice The identifier for the disputed L2 block number.\\n    uint256 internal constant DISPUTED_L2_BLOCK_NUMBER = 0x04;\\n\\n    /// @notice The identifier for the chain ID.\\n    uint256 internal constant CHAIN_ID = 0x05;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-v5/=lib/openzeppelin-contracts-v5/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"@lib-keccak/=lib/lib-keccak/contracts/lib/\",\r\n      \"@solady/=lib/solady/src/\",\r\n      \"@solady-v0.0.245/=lib/solady-v0.0.245/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"kontrol-cheatcodes/=lib/kontrol-cheatcodes/src/\",\r\n      \"interfaces/=interfaces/\",\r\n      \"@solady-test/=lib/lib-keccak/lib/solady/test/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-v5/lib/erc4626-tests/\",\r\n      \"lib-keccak/=lib/lib-keccak/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts-v5/=lib/openzeppelin-contracts-v5/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solady-v0.0.245/=lib/solady-v0.0.245/src/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"FailedRelayedMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"RelayedMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"SentMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SentMessageExtension1\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ENCODING_OVERHEAD\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLOOR_CALLDATA_OVERHEAD\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MESSAGE_VERSION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_GAS_CALLDATA_OVERHEAD\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OTHER_MESSENGER\",\"outputs\":[{\"internalType\":\"contract CrossDomainMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PORTAL\",\"outputs\":[{\"internalType\":\"contract IOptimismPortal2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAY_CALL_OVERHEAD\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAY_CONSTANT_OVERHEAD\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAY_GAS_CHECK_BUFFER\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAY_RESERVED_GAS\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TX_BASE_GAS\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"_minGasLimit\",\"type\":\"uint32\"}],\"name\":\"baseGas\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"failedMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISuperchainConfig\",\"name\":\"_superchainConfig\",\"type\":\"address\"},{\"internalType\":\"contract IOptimismPortal2\",\"name\":\"_portal\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherMessenger\",\"outputs\":[{\"internalType\":\"contract CrossDomainMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"portal\",\"outputs\":[{\"internalType\":\"contract IOptimismPortal2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"relayMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"_minGasLimit\",\"type\":\"uint32\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"successfulMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superchainConfig\",\"outputs\":[{\"internalType\":\"contract ISuperchainConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xDomainMessageSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
      "contract_name": "L1CrossDomainMessenger",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "optimization_used": "1",
      "runs": "999999",
      "constructor_arguments": "",
      "evm_version": "london",
      "library": "",
      "license_type": "",
      "proxy": "0",
      "implementation": "",
      "bytecode": null
    },
    "0xb443da3e07052204a02d630a8933dac05a0d6fb4": {
      "address": "0xb443da3e07052204a02d630a8933dac05a0d6fb4",
      "has_source_code": true,
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/L1/OptimismPortal2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n// Contracts\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport { ResourceMetering } from \\\"src/L1/ResourceMetering.sol\\\";\\n\\n// Libraries\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { EOA } from \\\"src/libraries/EOA.sol\\\";\\nimport { SafeCall } from \\\"src/libraries/SafeCall.sol\\\";\\nimport { Constants } from \\\"src/libraries/Constants.sol\\\";\\nimport { Types } from \\\"src/libraries/Types.sol\\\";\\nimport { Hashing } from \\\"src/libraries/Hashing.sol\\\";\\nimport { SecureMerkleTrie } from \\\"src/libraries/trie/SecureMerkleTrie.sol\\\";\\nimport { AddressAliasHelper } from \\\"src/vendor/AddressAliasHelper.sol\\\";\\nimport {\\n    BadTarget,\\n    LargeCalldata,\\n    SmallGasLimit,\\n    Unauthorized,\\n    CallPaused,\\n    GasEstimation,\\n    NonReentrant,\\n    InvalidProof,\\n    InvalidGameType,\\n    InvalidDisputeGame,\\n    InvalidMerkleProof,\\n    Blacklisted,\\n    Unproven,\\n    ProposalNotValidated,\\n    AlreadyFinalized,\\n    LegacyGame\\n} from \\\"src/libraries/PortalErrors.sol\\\";\\nimport { GameStatus, GameType, Claim, Timestamp } from \\\"src/dispute/lib/Types.sol\\\";\\n\\n// Interfaces\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ISemver } from \\\"interfaces/universal/ISemver.sol\\\";\\nimport { ISystemConfig } from \\\"interfaces/L1/ISystemConfig.sol\\\";\\nimport { IResourceMetering } from \\\"interfaces/L1/IResourceMetering.sol\\\";\\nimport { ISuperchainConfig } from \\\"interfaces/L1/ISuperchainConfig.sol\\\";\\nimport { IDisputeGameFactory } from \\\"interfaces/dispute/IDisputeGameFactory.sol\\\";\\nimport { IDisputeGame } from \\\"interfaces/dispute/IDisputeGame.sol\\\";\\n\\n/// @custom:proxied true\\n/// @title OptimismPortal2\\n/// @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\\n///         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\\n///         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\\ncontract OptimismPortal2 is Initializable, ResourceMetering, ISemver {\\n    /// @notice Allows for interactions with non standard ERC20 tokens.\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice Represents a proven withdrawal.\\n    /// @custom:field disputeGameProxy The address of the dispute game proxy that the withdrawal was proven against.\\n    /// @custom:field timestamp        Timestamp at which the withdrawal was proven.\\n    struct ProvenWithdrawal {\\n        IDisputeGame disputeGameProxy;\\n        uint64 timestamp;\\n    }\\n\\n    /// @notice The delay between when a withdrawal transaction is proven and when it may be finalized.\\n    uint256 internal immutable PROOF_MATURITY_DELAY_SECONDS;\\n\\n    /// @notice The delay between when a dispute game is resolved and when a withdrawal proven against it may be\\n    ///         finalized.\\n    uint256 internal immutable DISPUTE_GAME_FINALITY_DELAY_SECONDS;\\n\\n    /// @notice Version of the deposit event.\\n    uint256 internal constant DEPOSIT_VERSION = 0;\\n\\n    /// @notice The L2 gas limit set when eth is deposited using the receive() function.\\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\\n\\n    /// @notice The L2 gas limit for system deposit transactions that are initiated from L1.\\n    uint32 internal constant SYSTEM_DEPOSIT_GAS_LIMIT = 200_000;\\n\\n    /// @notice Address of the L2 account which initiated a withdrawal in this transaction.\\n    ///         If the of this variable is the default L2 sender address, then we are NOT inside of\\n    ///         a call to finalizeWithdrawalTransaction.\\n    address public l2Sender;\\n\\n    /// @notice A list of withdrawal hashes which have been successfully finalized.\\n    mapping(bytes32 => bool) public finalizedWithdrawals;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer provenWithdrawals\\n    /// @notice Spacer taking up the legacy `provenWithdrawals` mapping slot.\\n    bytes32 private spacer_52_0_32;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer paused\\n    /// @notice Spacer for backwards compatibility.\\n    bool private spacer_53_0_1;\\n\\n    /// @notice Contract of the Superchain Config.\\n    ISuperchainConfig public superchainConfig;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer l2Oracle\\n    /// @notice Spacer taking up the legacy `l2Oracle` address slot.\\n    address private spacer_54_0_20;\\n\\n    /// @notice Contract of the SystemConfig.\\n    /// @custom:network-specific\\n    ISystemConfig public systemConfig;\\n\\n    /// @notice Address of the DisputeGameFactory.\\n    /// @custom:network-specific\\n    IDisputeGameFactory public disputeGameFactory;\\n\\n    /// @notice A mapping of withdrawal hashes to proof submitters to `ProvenWithdrawal` data.\\n    mapping(bytes32 => mapping(address => ProvenWithdrawal)) public provenWithdrawals;\\n\\n    /// @notice A mapping of dispute game addresses to whether or not they are blacklisted.\\n    mapping(IDisputeGame => bool) public disputeGameBlacklist;\\n\\n    /// @notice The game type that the OptimismPortal consults for output proposals.\\n    GameType public respectedGameType;\\n\\n    /// @notice The timestamp at which the respected game type was last updated.\\n    uint64 public respectedGameTypeUpdatedAt;\\n\\n    /// @notice Mapping of withdrawal hashes to addresses that have submitted a proof for the\\n    ///         withdrawal. Original OptimismPortal contract only allowed one proof to be submitted\\n    ///         for any given withdrawal hash. Fault Proofs version of this contract must allow\\n    ///         multiple proofs for the same withdrawal hash to prevent a malicious user from\\n    ///         blocking other withdrawals by proving them against invalid proposals. Submitters\\n    ///         are tracked in an array to simplify the off-chain process of determining which\\n    ///         proof submission should be used when finalizing a withdrawal.\\n    mapping(bytes32 => address[]) public proofSubmitters;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer _balance\\n    /// @notice Spacer taking up the legacy `_balance` slot.\\n    uint256 private spacer_61_0_32;\\n\\n    /// @notice Emitted when a transaction is deposited from L1 to L2.\\n    ///         The parameters of this event are read by the rollup node and used to derive deposit\\n    ///         transactions on L2.\\n    /// @param from       Address that triggered the deposit transaction.\\n    /// @param to         Address that the deposit transaction is directed to.\\n    /// @param version    Version of this deposit transaction event.\\n    /// @param opaqueData ABI encoded deposit data to be parsed off-chain.\\n    event TransactionDeposited(address indexed from, address indexed to, uint256 indexed version, bytes opaqueData);\\n\\n    /// @notice Emitted when a withdrawal transaction is proven.\\n    /// @param withdrawalHash Hash of the withdrawal transaction.\\n    /// @param from           Address that triggered the withdrawal transaction.\\n    /// @param to             Address that the withdrawal transaction is directed to.\\n    event WithdrawalProven(bytes32 indexed withdrawalHash, address indexed from, address indexed to);\\n\\n    /// @notice Emitted when a withdrawal transaction is proven. Exists as a separate event to allow for backwards\\n    ///         compatibility for tooling that observes the `WithdrawalProven` event.\\n    /// @param withdrawalHash Hash of the withdrawal transaction.\\n    /// @param proofSubmitter Address of the proof submitter.\\n    event WithdrawalProvenExtension1(bytes32 indexed withdrawalHash, address indexed proofSubmitter);\\n\\n    /// @notice Emitted when a withdrawal transaction is finalized.\\n    /// @param withdrawalHash Hash of the withdrawal transaction.\\n    /// @param success        Whether the withdrawal transaction was successful.\\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\\n\\n    /// @notice Emitted when a dispute game is blacklisted by the Guardian.\\n    /// @param disputeGame Address of the dispute game that was blacklisted.\\n    event DisputeGameBlacklisted(IDisputeGame indexed disputeGame);\\n\\n    /// @notice Emitted when the Guardian changes the respected game type in the portal.\\n    /// @param newGameType The new respected game type.\\n    /// @param updatedAt   The timestamp at which the respected game type was updated.\\n    event RespectedGameTypeSet(GameType indexed newGameType, Timestamp indexed updatedAt);\\n\\n    /// @notice Reverts when paused.\\n    modifier whenNotPaused() {\\n        if (paused()) revert CallPaused();\\n        _;\\n    }\\n\\n    /// @notice Semantic version.\\n    /// @custom:semver 3.14.0\\n    function version() public pure virtual returns (string memory) {\\n        return \\\"3.14.0\\\";\\n    }\\n\\n    /// @notice Constructs the OptimismPortal contract.\\n    constructor(uint256 _proofMaturityDelaySeconds, uint256 _disputeGameFinalityDelaySeconds) {\\n        PROOF_MATURITY_DELAY_SECONDS = _proofMaturityDelaySeconds;\\n        DISPUTE_GAME_FINALITY_DELAY_SECONDS = _disputeGameFinalityDelaySeconds;\\n\\n        _disableInitializers();\\n    }\\n\\n    /// @notice Initializer.\\n    /// @param _disputeGameFactory Contract of the DisputeGameFactory.\\n    /// @param _systemConfig Contract of the SystemConfig.\\n    /// @param _superchainConfig Contract of the SuperchainConfig.\\n    function initialize(\\n        IDisputeGameFactory _disputeGameFactory,\\n        ISystemConfig _systemConfig,\\n        ISuperchainConfig _superchainConfig,\\n        GameType _initialRespectedGameType\\n    )\\n        external\\n        initializer\\n    {\\n        disputeGameFactory = _disputeGameFactory;\\n        systemConfig = _systemConfig;\\n        superchainConfig = _superchainConfig;\\n\\n        // Set the `l2Sender` slot, only if it is currently empty. This signals the first initialization of the\\n        // contract.\\n        if (l2Sender == address(0)) {\\n            l2Sender = Constants.DEFAULT_L2_SENDER;\\n\\n            // Set the `respectedGameTypeUpdatedAt` timestamp, to ignore all games of the respected type prior\\n            // to this operation.\\n            respectedGameTypeUpdatedAt = uint64(block.timestamp);\\n\\n            // Set the initial respected game type\\n            respectedGameType = _initialRespectedGameType;\\n        }\\n\\n        __ResourceMetering_init();\\n    }\\n\\n    /// @notice Getter function for the address of the guardian.\\n    ///         Public getter is legacy and will be removed in the future. Use `SuperchainConfig.guardian()` instead.\\n    /// @return Address of the guardian.\\n    /// @custom:legacy\\n    function guardian() public view returns (address) {\\n        return superchainConfig.guardian();\\n    }\\n\\n    /// @notice Getter for the current paused status.\\n    function paused() public view returns (bool) {\\n        return superchainConfig.paused();\\n    }\\n\\n    /// @notice Getter for the proof maturity delay.\\n    function proofMaturityDelaySeconds() public view returns (uint256) {\\n        return PROOF_MATURITY_DELAY_SECONDS;\\n    }\\n\\n    /// @notice Getter for the dispute game finality delay.\\n    function disputeGameFinalityDelaySeconds() public view returns (uint256) {\\n        return DISPUTE_GAME_FINALITY_DELAY_SECONDS;\\n    }\\n\\n    /// @notice Computes the minimum gas limit for a deposit.\\n    ///         The minimum gas limit linearly increases based on the size of the calldata.\\n    ///         This is to prevent users from creating L2 resource usage without paying for it.\\n    ///         This function can be used when interacting with the portal to ensure forwards\\n    ///         compatibility.\\n    /// @param _byteCount Number of bytes in the calldata.\\n    /// @return The minimum gas limit for a deposit.\\n    function minimumGasLimit(uint64 _byteCount) public pure returns (uint64) {\\n        return _byteCount * 40 + 21000;\\n    }\\n\\n    /// @notice Accepts value so that users can send ETH directly to this contract and have the\\n    ///         funds be deposited to their address on L2. This is intended as a convenience\\n    ///         function for EOAs. Contracts should call the depositTransaction() function directly\\n    ///         otherwise any deposited funds will be lost due to address aliasing.\\n    receive() external payable {\\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\\\"\\\"));\\n    }\\n\\n    /// @notice Accepts ETH value without triggering a deposit to L2.\\n    ///         This function mainly exists for the sake of the migration between the legacy\\n    ///         Optimism system and Bedrock.\\n    function donateETH() external payable {\\n        // Intentionally empty.\\n    }\\n\\n    /// @notice Getter for the resource config.\\n    ///         Used internally by the ResourceMetering contract.\\n    ///         The SystemConfig is the source of truth for the resource config.\\n    /// @return config_ ResourceMetering ResourceConfig\\n    function _resourceConfig() internal view override returns (ResourceMetering.ResourceConfig memory config_) {\\n        IResourceMetering.ResourceConfig memory config = systemConfig.resourceConfig();\\n        assembly (\\\"memory-safe\\\") {\\n            config_ := config\\n        }\\n    }\\n\\n    /// @notice Proves a withdrawal transaction.\\n    /// @param _tx               Withdrawal transaction to finalize.\\n    /// @param _disputeGameIndex Index of the dispute game to prove the withdrawal against.\\n    /// @param _outputRootProof  Inclusion proof of the L2ToL1MessagePasser contract's storage root.\\n    /// @param _withdrawalProof  Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\\n    function proveWithdrawalTransaction(\\n        Types.WithdrawalTransaction memory _tx,\\n        uint256 _disputeGameIndex,\\n        Types.OutputRootProof calldata _outputRootProof,\\n        bytes[] calldata _withdrawalProof\\n    )\\n        external\\n        whenNotPaused\\n    {\\n        // Prevent users from creating a deposit transaction where this address is the message\\n        // sender on L2. Because this is checked here, we do not need to check again in\\n        // `finalizeWithdrawalTransaction`.\\n        if (_tx.target == address(this)) revert BadTarget();\\n\\n        // Fetch the dispute game proxy from the `DisputeGameFactory` contract.\\n        (GameType gameType,, IDisputeGame gameProxy) = disputeGameFactory.gameAtIndex(_disputeGameIndex);\\n        Claim outputRoot = gameProxy.rootClaim();\\n\\n        // The game type of the dispute game must be the respected game type.\\n        if (gameType.raw() != respectedGameType.raw()) revert InvalidGameType();\\n\\n        // The game type of the DisputeGame must have been the respected game type at creation.\\n        // eip150-safe\\n        try gameProxy.wasRespectedGameTypeWhenCreated() returns (bool wasRespected_) {\\n            if (!wasRespected_) revert InvalidGameType();\\n        } catch {\\n            revert LegacyGame();\\n        }\\n\\n        // Game must have been created after the respected game type was updated. This check is a\\n        // strict inequality because we want to prevent users from being able to prove or finalize\\n        // withdrawals against games that were created in the same block that the retirement\\n        // timestamp was set. If the retirement timestamp and game type are changed in the same\\n        // block, such games could still be considered valid even if they used the old game type\\n        // that we intended to invalidate.\\n        require(\\n            gameProxy.createdAt().raw() > respectedGameTypeUpdatedAt,\\n            \\\"OptimismPortal: dispute game created before respected game type was updated\\\"\\n        );\\n\\n        // Verify that the output root can be generated with the elements in the proof.\\n        if (outputRoot.raw() != Hashing.hashOutputRootProof(_outputRootProof)) revert InvalidProof();\\n\\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\\n\\n        // We do not allow for proving withdrawals against dispute games that have resolved against the favor\\n        // of the root claim.\\n        if (gameProxy.status() == GameStatus.CHALLENGER_WINS) revert InvalidDisputeGame();\\n\\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\\n        // Refer to the Solidity documentation for more information on how storage layouts are\\n        // computed for mappings.\\n        bytes32 storageKey = keccak256(\\n            abi.encode(\\n                withdrawalHash,\\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\\n            )\\n        );\\n\\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\\n        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have\\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\\n        // be relayed on L1.\\n        if (\\n            SecureMerkleTrie.verifyInclusionProof({\\n                _key: abi.encode(storageKey),\\n                _value: hex\\\"01\\\",\\n                _proof: _withdrawalProof,\\n                _root: _outputRootProof.messagePasserStorageRoot\\n            }) == false\\n        ) revert InvalidMerkleProof();\\n\\n        // Designate the withdrawalHash as proven by storing the `disputeGameProxy` & `timestamp` in the\\n        // `provenWithdrawals` mapping. A `withdrawalHash` can only be proven once unless the dispute game it proved\\n        // against resolves against the favor of the root claim.\\n        provenWithdrawals[withdrawalHash][msg.sender] =\\n            ProvenWithdrawal({ disputeGameProxy: gameProxy, timestamp: uint64(block.timestamp) });\\n\\n        // Emit a `WithdrawalProven` event.\\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\\n        // Emit a `WithdrawalProvenExtension1` event.\\n        emit WithdrawalProvenExtension1(withdrawalHash, msg.sender);\\n\\n        // Add the proof submitter to the list of proof submitters for this withdrawal hash.\\n        proofSubmitters[withdrawalHash].push(msg.sender);\\n    }\\n\\n    /// @notice Finalizes a withdrawal transaction.\\n    /// @param _tx Withdrawal transaction to finalize.\\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx) external whenNotPaused {\\n        finalizeWithdrawalTransactionExternalProof(_tx, msg.sender);\\n    }\\n\\n    /// @notice Finalizes a withdrawal transaction, using an external proof submitter.\\n    /// @param _tx Withdrawal transaction to finalize.\\n    /// @param _proofSubmitter Address of the proof submitter.\\n    function finalizeWithdrawalTransactionExternalProof(\\n        Types.WithdrawalTransaction memory _tx,\\n        address _proofSubmitter\\n    )\\n        public\\n        whenNotPaused\\n    {\\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\\n        // than the default value when a withdrawal transaction is being finalized. This check is\\n        // a defacto reentrancy guard.\\n        if (l2Sender != Constants.DEFAULT_L2_SENDER) revert NonReentrant();\\n\\n        // Compute the withdrawal hash.\\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\\n\\n        // Check that the withdrawal can be finalized.\\n        checkWithdrawal(withdrawalHash, _proofSubmitter);\\n\\n        // Mark the withdrawal as finalized so it can't be replayed.\\n        finalizedWithdrawals[withdrawalHash] = true;\\n\\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\\n        l2Sender = _tx.sender;\\n\\n        // Trigger the call to the target contract. We use a custom low level method\\n        // SafeCall.callWithMinGas to ensure two key properties\\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\\n        //      amount of data (and this is OK because we don't care about the returndata here).\\n        //   2. The amount of gas provided to the execution context of the target is at least the\\n        //      gas limit specified by the user. If there is not enough gas in the current context\\n        //      to accomplish this, `callWithMinGas` will revert.\\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\\n\\n        // Reset the l2Sender back to the default value.\\n        l2Sender = Constants.DEFAULT_L2_SENDER;\\n\\n        // All withdrawals are immediately finalized. Replayability can\\n        // be achieved through contracts built on top of this contract\\n        emit WithdrawalFinalized(withdrawalHash, success);\\n\\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\\n        // sub call to the target contract if the minimum gas limit specified by the user would not\\n        // be sufficient to execute the sub call.\\n        if (!success && tx.origin == Constants.ESTIMATION_ADDRESS) {\\n            revert GasEstimation();\\n        }\\n    }\\n\\n    /// @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\\n    ///         deriving deposit transactions. Note that if a deposit is made by a contract, its\\n    ///         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\\n    ///         using the CrossDomainMessenger contracts for a simpler developer experience.\\n    /// @param _to         Target address on L2.\\n    /// @param _value      ETH value to send to the recipient.\\n    /// @param _gasLimit   Amount of L2 gas to purchase by burning gas on L1.\\n    /// @param _isCreation Whether or not the transaction is a contract creation.\\n    /// @param _data       Data to trigger the recipient with.\\n    function depositTransaction(\\n        address _to,\\n        uint256 _value,\\n        uint64 _gasLimit,\\n        bool _isCreation,\\n        bytes memory _data\\n    )\\n        public\\n        payable\\n        metered(_gasLimit)\\n    {\\n        // Just to be safe, make sure that people specify address(0) as the target when doing\\n        // contract creations.\\n        if (_isCreation && _to != address(0)) revert BadTarget();\\n\\n        // Prevent depositing transactions that have too small of a gas limit. Users should pay\\n        // more for more resource usage.\\n        if (_gasLimit < minimumGasLimit(uint64(_data.length))) revert SmallGasLimit();\\n\\n        // Prevent the creation of deposit transactions that have too much calldata. This gives an\\n        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure\\n        // that the transaction can fit into the p2p network policy of 128kb even though deposit\\n        // transactions are not gossipped over the p2p network.\\n        if (_data.length > 120_000) revert LargeCalldata();\\n\\n        // Transform the from-address to its alias if the caller is a contract.\\n        address from = msg.sender;\\n        if (!EOA.isSenderEOA()) {\\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\\n        }\\n\\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\\n        // We use opaque data so that we can update the TransactionDeposited event in the future\\n        // without breaking the current interface.\\n        bytes memory opaqueData = abi.encodePacked(msg.value, _value, _gasLimit, _isCreation, _data);\\n\\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\\n        // transaction for this deposit.\\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\\n    }\\n\\n    /// @notice Blacklists a dispute game. Should only be used in the event that a dispute game resolves incorrectly.\\n    /// @param _disputeGame Dispute game to blacklist.\\n    function blacklistDisputeGame(IDisputeGame _disputeGame) external {\\n        if (msg.sender != guardian()) revert Unauthorized();\\n        disputeGameBlacklist[_disputeGame] = true;\\n        emit DisputeGameBlacklisted(_disputeGame);\\n    }\\n\\n    /// @notice Sets the respected game type. Changing this value can alter the security properties of the system,\\n    ///         depending on the new game's behavior.\\n    /// @param _gameType The game type to consult for output proposals.\\n    function setRespectedGameType(GameType _gameType) external {\\n        if (msg.sender != guardian()) revert Unauthorized();\\n        // respectedGameTypeUpdatedAt is now no longer set by default. We want to avoid modifying\\n        // this function's signature as that would result in changes to the DeputyGuardianModule.\\n        // We use type(uint32).max as a temporary solution to allow us to update the\\n        // respectedGameTypeUpdatedAt timestamp without modifying this function's signature.\\n        if (_gameType.raw() == type(uint32).max) {\\n            respectedGameTypeUpdatedAt = uint64(block.timestamp);\\n        } else {\\n            respectedGameType = _gameType;\\n        }\\n        emit RespectedGameTypeSet(respectedGameType, Timestamp.wrap(respectedGameTypeUpdatedAt));\\n    }\\n\\n    /// @notice Checks if a withdrawal can be finalized. This function will revert if the withdrawal cannot be\\n    ///         finalized, and otherwise has no side-effects.\\n    /// @param _withdrawalHash Hash of the withdrawal to check.\\n    /// @param _proofSubmitter The submitter of the proof for the withdrawal hash\\n    function checkWithdrawal(bytes32 _withdrawalHash, address _proofSubmitter) public view {\\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[_withdrawalHash][_proofSubmitter];\\n        IDisputeGame disputeGameProxy = provenWithdrawal.disputeGameProxy;\\n\\n        // The dispute game must not be blacklisted.\\n        if (disputeGameBlacklist[disputeGameProxy]) revert Blacklisted();\\n\\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\\n        // a timestamp of zero.\\n        if (provenWithdrawal.timestamp == 0) revert Unproven();\\n\\n        // Grab the createdAt timestamp once.\\n        uint64 createdAt = disputeGameProxy.createdAt().raw();\\n\\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\\n        // starting timestamp inside the Dispute Game. Not strictly necessary but extra layer of\\n        // safety against weird bugs in the proving step.\\n        require(\\n            provenWithdrawal.timestamp > createdAt,\\n            \\\"OptimismPortal: withdrawal timestamp less than dispute game creation timestamp\\\"\\n        );\\n\\n        // A proven withdrawal must wait at least `PROOF_MATURITY_DELAY_SECONDS` before finalizing.\\n        require(\\n            block.timestamp - provenWithdrawal.timestamp > PROOF_MATURITY_DELAY_SECONDS,\\n            \\\"OptimismPortal: proven withdrawal has not matured yet\\\"\\n        );\\n\\n        // A proven withdrawal must wait until the dispute game it was proven against has been\\n        // resolved in favor of the root claim (the output proposal). This is to prevent users\\n        // from finalizing withdrawals proven against non-finalized output roots.\\n        if (disputeGameProxy.status() != GameStatus.DEFENDER_WINS) revert ProposalNotValidated();\\n\\n        // The game type of the dispute game must have been the respected game type at creation\\n        // time. We check that the game type is the respected game type at proving time, but it's\\n        // possible that the respected game type has since changed. Users can still use this game\\n        // to finalize a withdrawal as long as it has not been otherwise invalidated.\\n        // The game type of the DisputeGame must have been the respected game type at creation.\\n        // eip150-safe\\n        try disputeGameProxy.wasRespectedGameTypeWhenCreated() returns (bool wasRespected_) {\\n            if (!wasRespected_) revert InvalidGameType();\\n        } catch {\\n            revert LegacyGame();\\n        }\\n\\n        // Game must have been created after the respected game type was updated. This check is a\\n        // strict inequality because we want to prevent users from being able to prove or finalize\\n        // withdrawals against games that were created in the same block that the retirement\\n        // timestamp was set. If the retirement timestamp and game type are changed in the same\\n        // block, such games could still be considered valid even if they used the old game type\\n        // that we intended to invalidate.\\n        require(\\n            createdAt > respectedGameTypeUpdatedAt,\\n            \\\"OptimismPortal: dispute game created before respected game type was updated\\\"\\n        );\\n\\n        // Before a withdrawal can be finalized, the dispute game it was proven against must have been\\n        // resolved for at least `DISPUTE_GAME_FINALITY_DELAY_SECONDS`. This is to allow for manual\\n        // intervention in the event that a dispute game is resolved incorrectly.\\n        require(\\n            block.timestamp - disputeGameProxy.resolvedAt().raw() > DISPUTE_GAME_FINALITY_DELAY_SECONDS,\\n            \\\"OptimismPortal: output proposal in air-gap\\\"\\n        );\\n\\n        // Check that this withdrawal has not already been finalized, this is replay protection.\\n        if (finalizedWithdrawals[_withdrawalHash]) revert AlreadyFinalized();\\n    }\\n\\n    /// @notice External getter for the number of proof submitters for a withdrawal hash.\\n    /// @param _withdrawalHash Hash of the withdrawal.\\n    /// @return The number of proof submitters for the withdrawal hash.\\n    function numProofSubmitters(bytes32 _withdrawalHash) external view returns (uint256) {\\n        return proofSubmitters[_withdrawalHash].length;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/L1/ResourceMetering.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n// Contracts\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\n// Libraries\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { Burn } from \\\"src/libraries/Burn.sol\\\";\\nimport { Arithmetic } from \\\"src/libraries/Arithmetic.sol\\\";\\n\\n/// @custom:upgradeable\\n/// @title ResourceMetering\\n/// @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\\n///         updates automatically based on current demand.\\nabstract contract ResourceMetering is Initializable {\\n    /// @notice Error returned when too much gas resource is consumed.\\n    error OutOfGas();\\n\\n    /// @notice Represents the various parameters that control the way in which resources are\\n    ///         metered. Corresponds to the EIP-1559 resource metering system.\\n    /// @custom:field prevBaseFee   Base fee from the previous block(s).\\n    /// @custom:field prevBoughtGas Amount of gas bought so far in the current block.\\n    /// @custom:field prevBlockNum  Last block number that the base fee was updated.\\n    struct ResourceParams {\\n        uint128 prevBaseFee;\\n        uint64 prevBoughtGas;\\n        uint64 prevBlockNum;\\n    }\\n\\n    /// @notice Represents the configuration for the EIP-1559 based curve for the deposit gas\\n    ///         market. These values should be set with care as it is possible to set them in\\n    ///         a way that breaks the deposit gas market. The target resource limit is defined as\\n    ///         maxResourceLimit / elasticityMultiplier. This struct was designed to fit within a\\n    ///         single word. There is additional space for additions in the future.\\n    /// @custom:field maxResourceLimit             Represents the maximum amount of deposit gas that\\n    ///                                            can be purchased per block.\\n    /// @custom:field elasticityMultiplier         Determines the target resource limit along with\\n    ///                                            the resource limit.\\n    /// @custom:field baseFeeMaxChangeDenominator  Determines max change on fee per block.\\n    /// @custom:field minimumBaseFee               The min deposit base fee, it is clamped to this\\n    ///                                            value.\\n    /// @custom:field systemTxMaxGas               The amount of gas supplied to the system\\n    ///                                            transaction. This should be set to the same\\n    ///                                            number that the op-node sets as the gas limit\\n    ///                                            for the system transaction.\\n    /// @custom:field maximumBaseFee               The max deposit base fee, it is clamped to this\\n    ///                                            value.\\n    struct ResourceConfig {\\n        uint32 maxResourceLimit;\\n        uint8 elasticityMultiplier;\\n        uint8 baseFeeMaxChangeDenominator;\\n        uint32 minimumBaseFee;\\n        uint32 systemTxMaxGas;\\n        uint128 maximumBaseFee;\\n    }\\n\\n    /// @notice EIP-1559 style gas parameters.\\n    ResourceParams public params;\\n\\n    /// @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\\n    uint256[48] private __gap;\\n\\n    /// @notice Meters access to a function based an amount of a requested resource.\\n    /// @param _amount Amount of the resource requested.\\n    modifier metered(uint64 _amount) {\\n        // Record initial gas amount so we can refund for it later.\\n        uint256 initialGas = gasleft();\\n\\n        // Run the underlying function.\\n        _;\\n\\n        // Run the metering function.\\n        _metered(_amount, initialGas);\\n    }\\n\\n    /// @notice An internal function that holds all of the logic for metering a resource.\\n    /// @param _amount     Amount of the resource requested.\\n    /// @param _initialGas The amount of gas before any modifier execution.\\n    function _metered(uint64 _amount, uint256 _initialGas) internal {\\n        // Update block number and base fee if necessary.\\n        uint256 blockDiff = block.number - params.prevBlockNum;\\n\\n        ResourceConfig memory config = _resourceConfig();\\n        int256 targetResourceLimit =\\n            int256(uint256(config.maxResourceLimit)) / int256(uint256(config.elasticityMultiplier));\\n\\n        if (blockDiff > 0) {\\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\\n            // at which deposits can be created and therefore limit the potential for deposits to\\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - targetResourceLimit;\\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta)\\n                / (targetResourceLimit * int256(uint256(config.baseFeeMaxChangeDenominator)));\\n\\n            // Update base fee by adding the base fee delta and clamp the resulting value between\\n            // min and max.\\n            int256 newBaseFee = Arithmetic.clamp({\\n                _value: int256(uint256(params.prevBaseFee)) + baseFeeDelta,\\n                _min: int256(uint256(config.minimumBaseFee)),\\n                _max: int256(uint256(config.maximumBaseFee))\\n            });\\n\\n            // If we skipped more than one block, we also need to account for every empty block.\\n            // Empty block means there was no demand for deposits in that block, so we should\\n            // reflect this lack of demand in the fee.\\n            if (blockDiff > 1) {\\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\\n                // between min and max.\\n                newBaseFee = Arithmetic.clamp({\\n                    _value: Arithmetic.cdexp({\\n                        _coefficient: newBaseFee,\\n                        _denominator: int256(uint256(config.baseFeeMaxChangeDenominator)),\\n                        _exponent: int256(blockDiff - 1)\\n                    }),\\n                    _min: int256(uint256(config.minimumBaseFee)),\\n                    _max: int256(uint256(config.maximumBaseFee))\\n                });\\n            }\\n\\n            // Update new base fee, reset bought gas, and update block number.\\n            params.prevBaseFee = uint128(uint256(newBaseFee));\\n            params.prevBoughtGas = 0;\\n            params.prevBlockNum = uint64(block.number);\\n        }\\n\\n        // Make sure we can actually buy the resource amount requested by the user.\\n        params.prevBoughtGas += _amount;\\n        if (int256(uint256(params.prevBoughtGas)) > int256(uint256(config.maxResourceLimit))) {\\n            revert OutOfGas();\\n        }\\n\\n        // Determine the amount of ETH to be paid.\\n        uint256 resourceCost = uint256(_amount) * uint256(params.prevBaseFee);\\n\\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\\n        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\\n        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\\n        // during any 1 day period in the last 5 years, so should be fine.\\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1 gwei);\\n\\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\\n        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\\n        // effectively like a dynamic stipend (with a minimum value).\\n        uint256 usedGas = _initialGas - gasleft();\\n        if (gasCost > usedGas) {\\n            Burn.gas(gasCost - usedGas);\\n        }\\n    }\\n\\n    /// @notice Adds an amount of L2 gas consumed to the prev bought gas params. This is meant to be used\\n    ///         when L2 system transactions are generated from L1.\\n    /// @param _amount Amount of the L2 gas resource requested.\\n    function useGas(uint32 _amount) internal {\\n        params.prevBoughtGas += uint64(_amount);\\n    }\\n\\n    /// @notice Virtual function that returns the resource config.\\n    ///         Contracts that inherit this contract must implement this function.\\n    /// @return ResourceConfig\\n    function _resourceConfig() internal virtual returns (ResourceConfig memory);\\n\\n    /// @notice Sets initial resource parameter values.\\n    ///         This function must either be called by the initializer function of an upgradeable\\n    ///         child contract.\\n    function __ResourceMetering_init() internal onlyInitializing {\\n        if (params.prevBlockNum == 0) {\\n            params = ResourceParams({ prevBaseFee: 1 gwei, prevBoughtGas: 0, prevBlockNum: uint64(block.number) });\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/EOA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title EOA\\n/// @notice A library for detecting if an address is an EOA.\\nlibrary EOA {\\n    /// @notice Returns true if sender address is an EOA.\\n    /// @return isEOA_ True if the sender address is an EOA.\\n    function isSenderEOA() internal view returns (bool isEOA_) {\\n        if (msg.sender == tx.origin) {\\n            isEOA_ = true;\\n        } else if (address(msg.sender).code.length == 23) {\\n            // If the sender is not the origin, check for 7702 delegated EOAs.\\n            assembly {\\n                let ptr := mload(0x40)\\n                mstore(0x40, add(ptr, 0x20))\\n                extcodecopy(caller(), ptr, 0, 0x20)\\n                isEOA_ := eq(shr(232, mload(ptr)), 0xEF0100)\\n            }\\n        } else {\\n            // If more or less than 23 bytes of code, not a 7702 delegated EOA.\\n            isEOA_ = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title SafeCall\\n/// @notice Perform low level safe calls\\nlibrary SafeCall {\\n    /// @notice Performs a low level call without copying any returndata.\\n    /// @dev Passes no calldata to the call context.\\n    /// @param _target   Address to call\\n    /// @param _gas      Amount of gas to pass to the call\\n    /// @param _value    Amount of value to pass to the call\\n    function send(address _target, uint256 _gas, uint256 _value) internal returns (bool success_) {\\n        assembly {\\n            success_ :=\\n                call(\\n                    _gas, // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    0, // inloc\\n                    0, // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n    }\\n\\n    /// @notice Perform a low level call with all gas without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _value    Amount of value to pass to the call\\n    function send(address _target, uint256 _value) internal returns (bool success_) {\\n        success_ = send(_target, gasleft(), _value);\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _gas      Amount of gas to pass to the call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(\\n        address _target,\\n        uint256 _gas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (bool success_)\\n    {\\n        assembly {\\n            success_ :=\\n                call(\\n                    _gas, // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    add(_calldata, 32), // inloc\\n                    mload(_calldata), // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(address _target, uint256 _value, bytes memory _calldata) internal returns (bool success_) {\\n        success_ = call({ _target: _target, _gas: gasleft(), _value: _value, _calldata: _calldata });\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(address _target, bytes memory _calldata) internal returns (bool success_) {\\n        success_ = call({ _target: _target, _gas: gasleft(), _value: 0, _calldata: _calldata });\\n    }\\n\\n    /// @notice Helper function to determine if there is sufficient gas remaining within the context\\n    ///         to guarantee that the minimum gas requirement for a call will be met as well as\\n    ///         optionally reserving a specified amount of gas for after the call has concluded.\\n    /// @param _minGas      The minimum amount of gas that may be passed to the target context.\\n    /// @param _reservedGas Optional amount of gas to reserve for the caller after the execution\\n    ///                     of the target context.\\n    /// @return `true` if there is enough gas remaining to safely supply `_minGas` to the target\\n    ///         context as well as reserve `_reservedGas` for the caller after the execution of\\n    ///         the target context.\\n    /// @dev !!!!! FOOTGUN ALERT !!!!!\\n    ///      1.) The 40_000 base buffer is to account for the worst case of the dynamic cost of the\\n    ///          `CALL` opcode's `address_access_cost`, `positive_value_cost`, and\\n    ///          `value_to_empty_account_cost` factors with an added buffer of 5,700 gas. It is\\n    ///          still possible to self-rekt by initiating a withdrawal with a minimum gas limit\\n    ///          that does not account for the `memory_expansion_cost` & `code_execution_cost`\\n    ///          factors of the dynamic cost of the `CALL` opcode.\\n    ///      2.) This function should *directly* precede the external call if possible. There is an\\n    ///          added buffer to account for gas consumed between this check and the call, but it\\n    ///          is only 5,700 gas.\\n    ///      3.) Because EIP-150 ensures that a maximum of 63/64ths of the remaining gas in the call\\n    ///          frame may be passed to a subcontext, we need to ensure that the gas will not be\\n    ///          truncated.\\n    ///      4.) Use wisely. This function is not a silver bullet.\\n    function hasMinGas(uint256 _minGas, uint256 _reservedGas) internal view returns (bool) {\\n        bool _hasMinGas;\\n        assembly {\\n            // Equation: gas × 63 ≥ minGas × 64 + 63(40_000 + reservedGas)\\n            _hasMinGas := iszero(lt(mul(gas(), 63), add(mul(_minGas, 64), mul(add(40000, _reservedGas), 63))))\\n        }\\n        return _hasMinGas;\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata. This function\\n    ///         will revert if the call cannot be performed with the specified minimum\\n    ///         gas.\\n    /// @param _target   Address to call\\n    /// @param _minGas   The minimum amount of gas that may be passed to the call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function callWithMinGas(\\n        address _target,\\n        uint256 _minGas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        bool _success;\\n        bool _hasMinGas = hasMinGas(_minGas, 0);\\n        assembly {\\n            // Assertion: gasleft() >= (_minGas * 64) / 63 + 40_000\\n            if iszero(_hasMinGas) {\\n                // Store the \\\"Error(string)\\\" selector in scratch space.\\n                mstore(0, 0x08c379a0)\\n                // Store the pointer to the string length in scratch space.\\n                mstore(32, 32)\\n                // Store the string.\\n                //\\n                // SAFETY:\\n                // - We pad the beginning of the string with two zero bytes as well as the\\n                // length (24) to ensure that we override the free memory pointer at offset\\n                // 0x40. This is necessary because the free memory pointer is likely to\\n                // be greater than 1 byte when this function is called, but it is incredibly\\n                // unlikely that it will be greater than 3 bytes. As for the data within\\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\\n                // - It's fine to clobber the free memory pointer, we're reverting.\\n                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\\n\\n                // Revert with 'Error(\\\"SafeCall: Not enough gas\\\")'\\n                revert(28, 100)\\n            }\\n\\n            // The call will be supplied at least ((_minGas * 64) / 63) gas due to the\\n            // above assertion. This ensures that, in all circumstances (except for when the\\n            // `_minGas` does not account for the `memory_expansion_cost` and `code_execution_cost`\\n            // factors of the dynamic cost of the `CALL` opcode), the call will receive at least\\n            // the minimum amount of gas specified.\\n            _success :=\\n                call(\\n                    gas(), // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    add(_calldata, 32), // inloc\\n                    mload(_calldata), // inlen\\n                    0x00, // outloc\\n                    0x00 // outlen\\n                )\\n        }\\n        return _success;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Interfaces\\nimport { IResourceMetering } from \\\"interfaces/L1/IResourceMetering.sol\\\";\\n\\n/// @title Constants\\n/// @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\\n///         the stuff used in multiple contracts. Constants that only apply to a single contract\\n///         should be defined in that contract instead.\\nlibrary Constants {\\n    /// @notice Special address to be used as the tx origin for gas estimation calls in the\\n    ///         OptimismPortal and CrossDomainMessenger calls. You only need to use this address if\\n    ///         the minimum gas limit specified by the user is not actually enough to execute the\\n    ///         given message and you're attempting to estimate the actual necessary gas limit. We\\n    ///         use address(1) because it's the ecrecover precompile and therefore guaranteed to\\n    ///         never have any code on any EVM chain.\\n    address internal constant ESTIMATION_ADDRESS = address(1);\\n\\n    /// @notice Value used for the L2 sender storage slot in both the OptimismPortal and the\\n    ///         CrossDomainMessenger contracts before an actual sender is set. This value is\\n    ///         non-zero to reduce the gas cost of message passing transactions.\\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\\n\\n    /// @notice The storage slot that holds the address of a proxy implementation.\\n    /// @dev `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`\\n    bytes32 internal constant PROXY_IMPLEMENTATION_ADDRESS =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice The storage slot that holds the address of the owner.\\n    /// @dev `bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)`\\n    bytes32 internal constant PROXY_OWNER_ADDRESS = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice The address that represents ether when dealing with ERC20 token addresses.\\n    address internal constant ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice The address that represents the system caller responsible for L1 attributes\\n    ///         transactions.\\n    address internal constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\\n\\n    /// @notice Returns the default values for the ResourceConfig. These are the recommended values\\n    ///         for a production network.\\n    function DEFAULT_RESOURCE_CONFIG() internal pure returns (IResourceMetering.ResourceConfig memory) {\\n        IResourceMetering.ResourceConfig memory config = IResourceMetering.ResourceConfig({\\n            maxResourceLimit: 20_000_000,\\n            elasticityMultiplier: 10,\\n            baseFeeMaxChangeDenominator: 8,\\n            minimumBaseFee: 1 gwei,\\n            systemTxMaxGas: 1_000_000,\\n            maximumBaseFee: type(uint128).max\\n        });\\n        return config;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Types\\n/// @notice Contains various types used throughout the Optimism contract system.\\nlibrary Types {\\n    /// @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1\\n    ///         timestamp that the output root is posted. This timestamp is used to verify that the\\n    ///         finalization period has passed since the output root was submitted.\\n    /// @custom:field outputRoot    Hash of the L2 output.\\n    /// @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\\n    /// @custom:field l2BlockNumber L2 block number that the output corresponds to.\\n    struct OutputProposal {\\n        bytes32 outputRoot;\\n        uint128 timestamp;\\n        uint128 l2BlockNumber;\\n    }\\n\\n    /// @notice Struct representing the elements that are hashed together to generate an output root\\n    ///         which itself represents a snapshot of the L2 state.\\n    /// @custom:field version                  Version of the output root.\\n    /// @custom:field stateRoot                Root of the state trie at the block of this output.\\n    /// @custom:field messagePasserStorageRoot Root of the message passer storage trie.\\n    /// @custom:field latestBlockhash          Hash of the block this output was generated from.\\n    struct OutputRootProof {\\n        bytes32 version;\\n        bytes32 stateRoot;\\n        bytes32 messagePasserStorageRoot;\\n        bytes32 latestBlockhash;\\n    }\\n\\n    /// @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\\n    ///         user (as opposed to a system deposit transaction generated by the system).\\n    /// @custom:field from        Address of the sender of the transaction.\\n    /// @custom:field to          Address of the recipient of the transaction.\\n    /// @custom:field isCreation  True if the transaction is a contract creation.\\n    /// @custom:field value       Value to send to the recipient.\\n    /// @custom:field mint        Amount of ETH to mint.\\n    /// @custom:field gasLimit    Gas limit of the transaction.\\n    /// @custom:field data        Data of the transaction.\\n    /// @custom:field l1BlockHash Hash of the block the transaction was submitted in.\\n    /// @custom:field logIndex    Index of the log in the block the transaction was submitted in.\\n    struct UserDepositTransaction {\\n        address from;\\n        address to;\\n        bool isCreation;\\n        uint256 value;\\n        uint256 mint;\\n        uint64 gasLimit;\\n        bytes data;\\n        bytes32 l1BlockHash;\\n        uint256 logIndex;\\n    }\\n\\n    /// @notice Struct representing a withdrawal transaction.\\n    /// @custom:field nonce    Nonce of the withdrawal transaction\\n    /// @custom:field sender   Address of the sender of the transaction.\\n    /// @custom:field target   Address of the recipient of the transaction.\\n    /// @custom:field value    Value to send to the recipient.\\n    /// @custom:field gasLimit Gas limit of the transaction.\\n    /// @custom:field data     Data of the transaction.\\n    struct WithdrawalTransaction {\\n        uint256 nonce;\\n        address sender;\\n        address target;\\n        uint256 value;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    /// @notice Enum representing where the FeeVault withdraws funds to.\\n    /// @custom:value L1 FeeVault withdraws funds to L1.\\n    /// @custom:value L2 FeeVault withdraws funds to L2.\\n    enum WithdrawalNetwork {\\n        L1,\\n        L2\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Hashing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport { Types } from \\\"src/libraries/Types.sol\\\";\\nimport { Encoding } from \\\"src/libraries/Encoding.sol\\\";\\n\\n/// @title Hashing\\n/// @notice Hashing handles Optimism's various different hashing schemes.\\nlibrary Hashing {\\n    /// @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\\n    ///         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\\n    ///         system.\\n    /// @param _tx User deposit transaction to hash.\\n    /// @return Hash of the RLP encoded L2 deposit transaction.\\n    function hashDepositTransaction(Types.UserDepositTransaction memory _tx) internal pure returns (bytes32) {\\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\\n    }\\n\\n    /// @notice Computes the deposit transaction's \\\"source hash\\\", a value that guarantees the hash\\n    ///         of the L2 transaction that corresponds to a deposit is unique and is\\n    ///         deterministically generated from L1 transaction data.\\n    /// @param _l1BlockHash Hash of the L1 block where the deposit was included.\\n    /// @param _logIndex    The index of the log that created the deposit transaction.\\n    /// @return Hash of the deposit transaction's \\\"source hash\\\".\\n    function hashDepositSource(bytes32 _l1BlockHash, uint256 _logIndex) internal pure returns (bytes32) {\\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\\n        return keccak256(abi.encode(bytes32(0), depositId));\\n    }\\n\\n    /// @notice Hashes the cross domain message based on the version that is encoded into the\\n    ///         message nonce.\\n    /// @param _nonce    Message nonce with version encoded into the first two bytes.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return hashCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Hashing: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /// @notice Hashes a cross domain message based on the V0 (legacy) encoding.\\n    /// @param _target Address of the target of the message.\\n    /// @param _sender Address of the sender of the message.\\n    /// @param _data   Data to send with the message.\\n    /// @param _nonce  Message nonce.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Encoding.encodeCrossDomainMessageV0(_target, _sender, _data, _nonce));\\n    }\\n\\n    /// @notice Hashes a cross domain message based on the V1 (current) encoding.\\n    /// @param _nonce    Message nonce.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Encoding.encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data));\\n    }\\n\\n    /// @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\\n    /// @param _tx Withdrawal transaction to hash.\\n    /// @return Hashed withdrawal transaction.\\n    function hashWithdrawal(Types.WithdrawalTransaction memory _tx) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data));\\n    }\\n\\n    /// @notice Hashes the various elements of an output root proof into an output root hash which\\n    ///         can be used to check if the proof is valid.\\n    /// @param _outputRootProof Output root proof which should hash to an output root.\\n    /// @return Hashed output root proof.\\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                _outputRootProof.version,\\n                _outputRootProof.stateRoot,\\n                _outputRootProof.messagePasserStorageRoot,\\n                _outputRootProof.latestBlockhash\\n            )\\n        );\\n    }\\n\\n    /// @notice Generates a unique hash for cross l2 messages. This hash is used to identify\\n    ///         the message and ensure it is not relayed more than once.\\n    /// @param _destination Chain ID of the destination chain.\\n    /// @param _source Chain ID of the source chain.\\n    /// @param _nonce Unique nonce associated with the message to prevent replay attacks.\\n    /// @param _sender Address of the user who originally sent the message.\\n    /// @param _target Address of the contract or wallet that the message is targeting on the destination chain.\\n    /// @param _message The message payload to be relayed to the target on the destination chain.\\n    /// @return Hash of the encoded message parameters, used to uniquely identify the message.\\n    function hashL2toL2CrossDomainMessage(\\n        uint256 _destination,\\n        uint256 _source,\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        bytes memory _message\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(_destination, _source, _nonce, _sender, _target, _message));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/trie/SecureMerkleTrie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport { MerkleTrie } from \\\"src/libraries/trie/MerkleTrie.sol\\\";\\n\\n/// @title SecureMerkleTrie\\n/// @notice SecureMerkleTrie is a thin wrapper around the MerkleTrie library that hashes the input\\n///         keys. Ethereum's state trie hashes input keys before storing them.\\nlibrary SecureMerkleTrie {\\n    /// @notice Verifies a proof that a given key/value pair is present in the Merkle trie.\\n    /// @param _key   Key of the node to search for, as a hex string.\\n    /// @param _value Value of the node to search for, as a hex string.\\n    /// @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\\n    ///               trees, this proof is executed top-down and consists of a list of RLP-encoded\\n    ///               nodes that make a path down to the target node.\\n    /// @param _root  Known root of the Merkle trie. Used to verify that the included proof is\\n    ///               correctly constructed.\\n    /// @return valid_ Whether or not the proof is valid.\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (bool valid_)\\n    {\\n        bytes memory key = _getSecureKey(_key);\\n        valid_ = MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\\n    }\\n\\n    /// @notice Retrieves the value associated with a given key.\\n    /// @param _key   Key to search for, as hex bytes.\\n    /// @param _proof Merkle trie inclusion proof for the key.\\n    /// @param _root  Known root of the Merkle trie.\\n    /// @return value_ Value of the key if it exists.\\n    function get(bytes memory _key, bytes[] memory _proof, bytes32 _root) internal pure returns (bytes memory value_) {\\n        bytes memory key = _getSecureKey(_key);\\n        value_ = MerkleTrie.get(key, _proof, _root);\\n    }\\n\\n    /// @notice Computes the hashed version of the input key.\\n    /// @param _key Key to hash.\\n    /// @return hash_ Hashed version of the key.\\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory hash_) {\\n        hash_ = abi.encodePacked(keccak256(_key));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/vendor/AddressAliasHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressAliasHelper {\\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n    /// the inbox to the msg.sender viewed in the L2\\n    /// @param l1Address the address in the L1 that triggered the tx to L2\\n    /// @return l2Address L2 address as viewed in msg.sender\\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address) + offset);\\n        }\\n    }\\n\\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n    /// address in the L1 that submitted a tx to the inbox\\n    /// @param l2Address L2 address as viewed in msg.sender\\n    /// @return l1Address the address in the L1 that triggered the tx to L2\\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n        unchecked {\\n            l1Address = address(uint160(l2Address) - offset);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/PortalErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Error for when a deposit or withdrawal is to a bad target.\\nerror BadTarget();\\n/// @notice Error for when a deposit has too much calldata.\\nerror LargeCalldata();\\n/// @notice Error for when a deposit has too small of a gas limit.\\nerror SmallGasLimit();\\n/// @notice Error for when a withdrawal transfer fails.\\nerror TransferFailed();\\n/// @notice Error for when a method cannot be called with non zero CALLVALUE.\\nerror NoValue();\\n/// @notice Error for an unauthorized CALLER.\\nerror Unauthorized();\\n/// @notice Error for when a method cannot be called when paused. This could be renamed\\n///         to `Paused` in the future, but it collides with the `Paused` event.\\nerror CallPaused();\\n/// @notice Error for special gas estimation.\\nerror GasEstimation();\\n/// @notice Error for when a method is being reentered.\\nerror NonReentrant();\\n/// @notice Error for invalid proof.\\nerror InvalidProof();\\n/// @notice Error for invalid game type.\\nerror InvalidGameType();\\n/// @notice Error for an invalid dispute game.\\nerror InvalidDisputeGame();\\n/// @notice Error for an invalid merkle proof.\\nerror InvalidMerkleProof();\\n/// @notice Error for when a dispute game has been blacklisted.\\nerror Blacklisted();\\n/// @notice Error for when trying to withdrawal without first proven.\\nerror Unproven();\\n/// @notice Error for when a proposal is not validated.\\nerror ProposalNotValidated();\\n/// @notice Error for when a withdrawal has already been finalized.\\nerror AlreadyFinalized();\\n/// @notice Error for when a game is a legacy game.\\nerror LegacyGame();\\n\"\r\n    },\r\n    \"src/dispute/lib/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n// Libraries\\nimport {\\n    Position,\\n    Hash,\\n    GameType,\\n    VMStatus,\\n    Timestamp,\\n    Duration,\\n    Clock,\\n    GameId,\\n    Claim,\\n    LibGameId,\\n    LibClock\\n} from \\\"src/dispute/lib/LibUDT.sol\\\";\\n\\n/// @notice The current status of the dispute game.\\nenum GameStatus {\\n    // The game is currently in progress, and has not been resolved.\\n    IN_PROGRESS,\\n    // The game has concluded, and the `rootClaim` was challenged successfully.\\n    CHALLENGER_WINS,\\n    // The game has concluded, and the `rootClaim` could not be contested.\\n    DEFENDER_WINS\\n}\\n\\n/// @notice The game's bond distribution type. Games are expected to start in the `UNDECIDED`\\n///         state, and then choose either `NORMAL` or `REFUND`.\\nenum BondDistributionMode {\\n    // Bond distribution strategy has not been chosen.\\n    UNDECIDED,\\n    // Bonds should be distributed as normal.\\n    NORMAL,\\n    // Bonds should be refunded to claimants.\\n    REFUND\\n}\\n\\n/// @notice Represents an L2 output root and the L2 block number at which it was generated.\\n/// @custom:field root The output root.\\n/// @custom:field l2BlockNumber The L2 block number at which the output root was generated.\\nstruct OutputRoot {\\n    Hash root;\\n    uint256 l2BlockNumber;\\n}\\n\\n/// @title GameTypes\\n/// @notice A library that defines the IDs of games that can be played.\\nlibrary GameTypes {\\n    /// @dev A dispute game type the uses the cannon vm.\\n    GameType internal constant CANNON = GameType.wrap(0);\\n\\n    /// @dev A permissioned dispute game type that uses the cannon vm.\\n    GameType internal constant PERMISSIONED_CANNON = GameType.wrap(1);\\n\\n    /// @notice A dispute game type that uses the asterisc vm.\\n    GameType internal constant ASTERISC = GameType.wrap(2);\\n\\n    /// @notice A dispute game type that uses the asterisc vm with Kona.\\n    GameType internal constant ASTERISC_KONA = GameType.wrap(3);\\n\\n    /// @notice A dispute game type that uses OP Succinct\\n    GameType internal constant OP_SUCCINCT = GameType.wrap(6);\\n\\n    /// @notice A dispute game type with short game duration for testing withdrawals.\\n    ///         Not intended for production use.\\n    GameType internal constant FAST = GameType.wrap(254);\\n\\n    /// @notice A dispute game type that uses an alphabet vm.\\n    ///         Not intended for production use.\\n    GameType internal constant ALPHABET = GameType.wrap(255);\\n\\n    /// @notice A dispute game type that uses RISC Zero's Kailua\\n    GameType internal constant KAILUA = GameType.wrap(1337);\\n}\\n\\n/// @title VMStatuses\\n/// @notice Named type aliases for the various valid VM status bytes.\\nlibrary VMStatuses {\\n    /// @notice The VM has executed successfully and the outcome is valid.\\n    VMStatus internal constant VALID = VMStatus.wrap(0);\\n\\n    /// @notice The VM has executed successfully and the outcome is invalid.\\n    VMStatus internal constant INVALID = VMStatus.wrap(1);\\n\\n    /// @notice The VM has paniced.\\n    VMStatus internal constant PANIC = VMStatus.wrap(2);\\n\\n    /// @notice The VM execution is still in progress.\\n    VMStatus internal constant UNFINISHED = VMStatus.wrap(3);\\n}\\n\\n/// @title LocalPreimageKey\\n/// @notice Named type aliases for local `PreimageOracle` key identifiers.\\nlibrary LocalPreimageKey {\\n    /// @notice The identifier for the L1 head hash.\\n    uint256 internal constant L1_HEAD_HASH = 0x01;\\n\\n    /// @notice The identifier for the starting output root.\\n    uint256 internal constant STARTING_OUTPUT_ROOT = 0x02;\\n\\n    /// @notice The identifier for the disputed output root.\\n    uint256 internal constant DISPUTED_OUTPUT_ROOT = 0x03;\\n\\n    /// @notice The identifier for the disputed L2 block number.\\n    uint256 internal constant DISPUTED_L2_BLOCK_NUMBER = 0x04;\\n\\n    /// @notice The identifier for the chain ID.\\n    uint256 internal constant CHAIN_ID = 0x05;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"interfaces/universal/ISemver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ISemver\\n/// @notice ISemver is a simple contract for ensuring that contracts are\\n///         versioned using semantic versioning.\\ninterface ISemver {\\n    /// @notice Getter for the semantic version of the contract. This is not\\n    ///         meant to be used onchain but instead meant to be used by offchain\\n    ///         tooling.\\n    /// @return Semver contract version as a string.\\n    function version() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/ISystemConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IResourceMetering } from \\\"interfaces/L1/IResourceMetering.sol\\\";\\n\\ninterface ISystemConfig {\\n    enum UpdateType {\\n        BATCHER,\\n        FEE_SCALARS,\\n        GAS_LIMIT,\\n        UNSAFE_BLOCK_SIGNER,\\n        EIP_1559_PARAMS,\\n        OPERATOR_FEE_PARAMS\\n    }\\n\\n    struct Addresses {\\n        address l1CrossDomainMessenger;\\n        address l1ERC721Bridge;\\n        address l1StandardBridge;\\n        address disputeGameFactory;\\n        address optimismPortal;\\n        address optimismMintableERC20Factory;\\n    }\\n\\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\\n    event Initialized(uint8 version);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function BATCH_INBOX_SLOT() external view returns (bytes32);\\n    function DISPUTE_GAME_FACTORY_SLOT() external view returns (bytes32);\\n    function L1_CROSS_DOMAIN_MESSENGER_SLOT() external view returns (bytes32);\\n    function L1_ERC_721_BRIDGE_SLOT() external view returns (bytes32);\\n    function L1_STANDARD_BRIDGE_SLOT() external view returns (bytes32);\\n    function OPTIMISM_MINTABLE_ERC20_FACTORY_SLOT() external view returns (bytes32);\\n    function OPTIMISM_PORTAL_SLOT() external view returns (bytes32);\\n    function START_BLOCK_SLOT() external view returns (bytes32);\\n    function UNSAFE_BLOCK_SIGNER_SLOT() external view returns (bytes32);\\n    function VERSION() external view returns (uint256);\\n    function basefeeScalar() external view returns (uint32);\\n    function batchInbox() external view returns (address addr_);\\n    function batcherHash() external view returns (bytes32);\\n    function blobbasefeeScalar() external view returns (uint32);\\n    function disputeGameFactory() external view returns (address addr_);\\n    function gasLimit() external view returns (uint64);\\n    function eip1559Denominator() external view returns (uint32);\\n    function eip1559Elasticity() external view returns (uint32);\\n    function getAddresses() external view returns (Addresses memory);\\n    function initialize(\\n        address _owner,\\n        uint32 _basefeeScalar,\\n        uint32 _blobbasefeeScalar,\\n        bytes32 _batcherHash,\\n        uint64 _gasLimit,\\n        address _unsafeBlockSigner,\\n        IResourceMetering.ResourceConfig memory _config,\\n        address _batchInbox,\\n        Addresses memory _addresses\\n    )\\n        external;\\n    function l1CrossDomainMessenger() external view returns (address addr_);\\n    function l1ERC721Bridge() external view returns (address addr_);\\n    function l1StandardBridge() external view returns (address addr_);\\n    function maximumGasLimit() external pure returns (uint64);\\n    function minimumGasLimit() external view returns (uint64);\\n    function operatorFeeConstant() external view returns (uint64);\\n    function operatorFeeScalar() external view returns (uint32);\\n    function optimismMintableERC20Factory() external view returns (address addr_);\\n    function optimismPortal() external view returns (address addr_);\\n    function overhead() external view returns (uint256);\\n    function owner() external view returns (address);\\n    function renounceOwnership() external;\\n    function resourceConfig() external view returns (IResourceMetering.ResourceConfig memory);\\n    function scalar() external view returns (uint256);\\n    function setBatcherHash(bytes32 _batcherHash) external;\\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external;\\n    function setGasConfigEcotone(uint32 _basefeeScalar, uint32 _blobbasefeeScalar) external;\\n    function setGasLimit(uint64 _gasLimit) external;\\n    function setOperatorFeeScalars(uint32 _operatorFeeScalar, uint64 _operatorFeeConstant) external;\\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external;\\n    function setEIP1559Params(uint32 _denominator, uint32 _elasticity) external;\\n    function startBlock() external view returns (uint256 startBlock_);\\n    function transferOwnership(address newOwner) external; // nosemgrep\\n    function unsafeBlockSigner() external view returns (address addr_);\\n    function version() external pure returns (string memory);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/IResourceMetering.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IResourceMetering {\\n    struct ResourceParams {\\n        uint128 prevBaseFee;\\n        uint64 prevBoughtGas;\\n        uint64 prevBlockNum;\\n    }\\n\\n    struct ResourceConfig {\\n        uint32 maxResourceLimit;\\n        uint8 elasticityMultiplier;\\n        uint8 baseFeeMaxChangeDenominator;\\n        uint32 minimumBaseFee;\\n        uint32 systemTxMaxGas;\\n        uint128 maximumBaseFee;\\n    }\\n\\n    error OutOfGas();\\n\\n    event Initialized(uint8 version);\\n\\n    function params() external view returns (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum); // nosemgrep\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/ISuperchainConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ISuperchainConfig {\\n    enum UpdateType {\\n        GUARDIAN\\n    }\\n\\n    event ConfigUpdate(UpdateType indexed updateType, bytes data);\\n    event Initialized(uint8 version);\\n    event Paused(string identifier);\\n    event Unpaused();\\n\\n    function GUARDIAN_SLOT() external view returns (bytes32);\\n    function PAUSED_SLOT() external view returns (bytes32);\\n    function guardian() external view returns (address guardian_);\\n    function initialize(address _guardian, bool _paused) external;\\n    function pause(string memory _identifier) external;\\n    function paused() external view returns (bool paused_);\\n    function unpause() external;\\n    function version() external view returns (string memory);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IDisputeGameFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IDisputeGame } from \\\"interfaces/dispute/IDisputeGame.sol\\\";\\nimport { GameId, Timestamp, Claim, Hash, GameType } from \\\"src/dispute/lib/Types.sol\\\";\\n\\ninterface IDisputeGameFactory {\\n    struct GameSearchResult {\\n        uint256 index;\\n        GameId metadata;\\n        Timestamp timestamp;\\n        Claim rootClaim;\\n        bytes extraData;\\n    }\\n\\n    error GameAlreadyExists(Hash uuid);\\n    error IncorrectBondAmount();\\n    error NoImplementation(GameType gameType);\\n\\n    event DisputeGameCreated(address indexed disputeProxy, GameType indexed gameType, Claim indexed rootClaim);\\n    event ImplementationSet(address indexed impl, GameType indexed gameType);\\n    event InitBondUpdated(GameType indexed gameType, uint256 indexed newBond);\\n    event Initialized(uint8 version);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function create(\\n        GameType _gameType,\\n        Claim _rootClaim,\\n        bytes memory _extraData\\n    )\\n        external\\n        payable\\n        returns (IDisputeGame proxy_);\\n    function findLatestGames(\\n        GameType _gameType,\\n        uint256 _start,\\n        uint256 _n\\n    )\\n        external\\n        view\\n        returns (GameSearchResult[] memory games_);\\n    function gameAtIndex(uint256 _index)\\n        external\\n        view\\n        returns (GameType gameType_, Timestamp timestamp_, IDisputeGame proxy_);\\n    function gameCount() external view returns (uint256 gameCount_);\\n    function gameImpls(GameType) external view returns (IDisputeGame);\\n    function games(\\n        GameType _gameType,\\n        Claim _rootClaim,\\n        bytes memory _extraData\\n    )\\n        external\\n        view\\n        returns (IDisputeGame proxy_, Timestamp timestamp_);\\n    function getGameUUID(\\n        GameType _gameType,\\n        Claim _rootClaim,\\n        bytes memory _extraData\\n    )\\n        external\\n        pure\\n        returns (Hash uuid_);\\n    function initBonds(GameType) external view returns (uint256);\\n    function initialize(address _owner) external;\\n    function owner() external view returns (address);\\n    function renounceOwnership() external;\\n    function setImplementation(GameType _gameType, IDisputeGame _impl) external;\\n    function setInitBond(GameType _gameType, uint256 _initBond) external;\\n    function transferOwnership(address newOwner) external; // nosemgrep\\n    function version() external view returns (string memory);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IDisputeGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IInitializable } from \\\"interfaces/dispute/IInitializable.sol\\\";\\nimport { Timestamp, GameStatus, GameType, Claim, Hash } from \\\"src/dispute/lib/Types.sol\\\";\\n\\ninterface IDisputeGame is IInitializable {\\n    event Resolved(GameStatus indexed status);\\n\\n    function createdAt() external view returns (Timestamp);\\n    function resolvedAt() external view returns (Timestamp);\\n    function status() external view returns (GameStatus);\\n    function gameType() external view returns (GameType gameType_);\\n    function gameCreator() external pure returns (address creator_);\\n    function rootClaim() external pure returns (Claim rootClaim_);\\n    function l1Head() external pure returns (Hash l1Head_);\\n    function l2BlockNumber() external pure returns (uint256 l2BlockNumber_);\\n    function extraData() external pure returns (bytes memory extraData_);\\n    function resolve() external returns (GameStatus status_);\\n    function gameData() external view returns (GameType gameType_, Claim rootClaim_, bytes memory extraData_);\\n    function wasRespectedGameTypeWhenCreated() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Burn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/// @title Burn\\n/// @notice Utilities for burning stuff.\\nlibrary Burn {\\n    /// @notice Burns a given amount of ETH.\\n    /// @param _amount Amount of ETH to burn.\\n    function eth(uint256 _amount) internal {\\n        new Burner{ value: _amount }();\\n    }\\n\\n    /// @notice Burns a given amount of gas.\\n    /// @param _amount Amount of gas to burn.\\n    function gas(uint256 _amount) internal view {\\n        uint256 i = 0;\\n        uint256 initialGas = gasleft();\\n        while (initialGas - gasleft() < _amount) {\\n            ++i;\\n        }\\n    }\\n}\\n\\n/// @title Burner\\n/// @notice Burner self-destructs on creation and sends all ETH to itself, removing all ETH given to\\n///         the contract from the circulating supply. Self-destructing is the only way to remove ETH\\n///         from the circulating supply.\\ncontract Burner {\\n    constructor() payable {\\n        selfdestruct(payable(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Arithmetic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport { SignedMath } from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport { FixedPointMathLib } from \\\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\n/// @title Arithmetic\\n/// @notice Even more math than before.\\nlibrary Arithmetic {\\n    /// @notice Clamps a value between a minimum and maximum.\\n    /// @param _value The value to clamp.\\n    /// @param _min   The minimum value.\\n    /// @param _max   The maximum value.\\n    /// @return The clamped value.\\n    function clamp(int256 _value, int256 _min, int256 _max) internal pure returns (int256) {\\n        return SignedMath.min(SignedMath.max(_value, _min), _max);\\n    }\\n\\n    /// @notice (c)oefficient (d)enominator (exp)onentiation function.\\n    ///         Returns the result of: c * (1 - 1/d)^exp.\\n    /// @param _coefficient Coefficient of the function.\\n    /// @param _denominator Fractional denominator.\\n    /// @param _exponent    Power function exponent.\\n    /// @return Result of c * (1 - 1/d)^exp.\\n    function cdexp(int256 _coefficient, int256 _denominator, int256 _exponent) internal pure returns (int256) {\\n        return (_coefficient * (FixedPointMathLib.powWad(1e18 - (1e18 / _denominator), _exponent * 1e18))) / 1e18;\\n    }\\n\\n    /// @notice Saturating addition.\\n    /// @param _x The first value.\\n    /// @param _y The second value.\\n    /// @return z_ The sum of the two values, or the maximum value if the sum overflows.\\n    /// @dev Returns `min(2 ** 256 - 1, x + y)`.\\n    /// @dev Taken from Solady\\n    /// https://github.com/Vectorized/solady/blob/63416d60c78aba70a12ca1b3c11125d1061caa12/src/utils/FixedPointMathLib.sol#L673\\n    function saturatingAdd(uint256 _x, uint256 _y) internal pure returns (uint256 z_) {\\n        assembly (\\\"memory-safe\\\") {\\n            z_ := or(sub(0, lt(add(_x, _y), _x)), add(_x, _y))\\n        }\\n    }\\n\\n    /// @notice Saturating multiplication.\\n    /// @param _x The first value.\\n    /// @param _y The second value.\\n    /// @return z_ The product of the two values, or the maximum value if the product overflows.\\n    /// @dev Returns `min(2 ** 256 - 1, x * y).\\n    /// @dev Taken from Solady\\n    /// https://github.com/Vectorized/solady/blob/63416d60c78aba70a12ca1b3c11125d1061caa12/src/utils/FixedPointMathLib.sol#L681\\n    function saturatingMul(uint256 _x, uint256 _y) internal pure returns (uint256 z_) {\\n        assembly (\\\"memory-safe\\\") {\\n            z_ := or(sub(or(iszero(_x), eq(div(mul(_x, _y), _x), _y)), 1), mul(_x, _y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/libraries/Encoding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport { Types } from \\\"src/libraries/Types.sol\\\";\\nimport { Hashing } from \\\"src/libraries/Hashing.sol\\\";\\nimport { RLPWriter } from \\\"src/libraries/rlp/RLPWriter.sol\\\";\\n\\n/// @title Encoding\\n/// @notice Encoding handles Optimism's various different encoding schemes.\\nlibrary Encoding {\\n    /// @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\\n    ///         to the L2 system. Useful for searching for a deposit in the L2 system. The\\n    ///         transaction is prefixed with 0x7e to identify its EIP-2718 type.\\n    /// @param _tx User deposit transaction to encode.\\n    /// @return RLP encoded L2 deposit transaction.\\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx) internal pure returns (bytes memory) {\\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\\n        bytes[] memory raw = new bytes[](8);\\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\\n        raw[1] = RLPWriter.writeAddress(_tx.from);\\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\\\"\\\") : RLPWriter.writeAddress(_tx.to);\\n        raw[3] = RLPWriter.writeUint(_tx.mint);\\n        raw[4] = RLPWriter.writeUint(_tx.value);\\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\\n        raw[6] = RLPWriter.writeBool(false);\\n        raw[7] = RLPWriter.writeBytes(_tx.data);\\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\\n    }\\n\\n    /// @notice Encodes the cross domain message based on the version that is encoded into the\\n    ///         message nonce.\\n    /// @param _nonce    Message nonce with version encoded into the first two bytes.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        (, uint16 version) = decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Encoding: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /// @notice Encodes a cross domain message based on the V0 (legacy) encoding.\\n    /// @param _target Address of the target of the message.\\n    /// @param _sender Address of the sender of the message.\\n    /// @param _data   Data to send with the message.\\n    /// @param _nonce  Message nonce.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        // nosemgrep: sol-style-use-abi-encodecall\\n        return abi.encodeWithSignature(\\\"relayMessage(address,address,bytes,uint256)\\\", _target, _sender, _data, _nonce);\\n    }\\n\\n    /// @notice Encodes a cross domain message based on the V1 (current) encoding.\\n    /// @param _nonce    Message nonce.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        // nosemgrep: sol-style-use-abi-encodecall\\n        return abi.encodeWithSignature(\\n            \\\"relayMessage(uint256,address,address,uint256,uint256,bytes)\\\",\\n            _nonce,\\n            _sender,\\n            _target,\\n            _value,\\n            _gasLimit,\\n            _data\\n        );\\n    }\\n\\n    /// @notice Adds a version number into the first two bytes of a message nonce.\\n    /// @param _nonce   Message nonce to encode into.\\n    /// @param _version Version number to encode into the message nonce.\\n    /// @return Message nonce with version encoded into the first two bytes.\\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\\n        uint256 nonce;\\n        assembly {\\n            nonce := or(shl(240, _version), _nonce)\\n        }\\n        return nonce;\\n    }\\n\\n    /// @notice Pulls the version out of a version-encoded nonce.\\n    /// @param _nonce Message nonce with version encoded into the first two bytes.\\n    /// @return Nonce without encoded version.\\n    /// @return Version of the message.\\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\\n        uint240 nonce;\\n        uint16 version;\\n        assembly {\\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            version := shr(240, _nonce)\\n        }\\n        return (nonce, version);\\n    }\\n\\n    /// @notice Returns an appropriately encoded call to L1Block.setL1BlockValuesEcotone\\n    /// @param _baseFeeScalar       L1 base fee Scalar\\n    /// @param _blobBaseFeeScalar   L1 blob base fee Scalar\\n    /// @param _sequenceNumber      Number of L2 blocks since epoch start.\\n    /// @param _timestamp           L1 timestamp.\\n    /// @param _number              L1 blocknumber.\\n    /// @param _baseFee             L1 base fee.\\n    /// @param _blobBaseFee         L1 blob base fee.\\n    /// @param _hash                L1 blockhash.\\n    /// @param _batcherHash         Versioned hash to authenticate batcher by.\\n    function encodeSetL1BlockValuesEcotone(\\n        uint32 _baseFeeScalar,\\n        uint32 _blobBaseFeeScalar,\\n        uint64 _sequenceNumber,\\n        uint64 _timestamp,\\n        uint64 _number,\\n        uint256 _baseFee,\\n        uint256 _blobBaseFee,\\n        bytes32 _hash,\\n        bytes32 _batcherHash\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes4 functionSignature = bytes4(keccak256(\\\"setL1BlockValuesEcotone()\\\"));\\n        return abi.encodePacked(\\n            functionSignature,\\n            _baseFeeScalar,\\n            _blobBaseFeeScalar,\\n            _sequenceNumber,\\n            _timestamp,\\n            _number,\\n            _baseFee,\\n            _blobBaseFee,\\n            _hash,\\n            _batcherHash\\n        );\\n    }\\n\\n    /// @notice Returns an appropriately encoded call to L1Block.setL1BlockValuesIsthmus\\n    /// @param _baseFeeScalar       L1 base fee Scalar\\n    /// @param _blobBaseFeeScalar   L1 blob base fee Scalar\\n    /// @param _sequenceNumber      Number of L2 blocks since epoch start.\\n    /// @param _timestamp           L1 timestamp.\\n    /// @param _number              L1 blocknumber.\\n    /// @param _baseFee             L1 base fee.\\n    /// @param _blobBaseFee         L1 blob base fee.\\n    /// @param _hash                L1 blockhash.\\n    /// @param _batcherHash         Versioned hash to authenticate batcher by.\\n    /// @param _operatorFeeScalar   Operator fee scalar.\\n    /// @param _operatorFeeConstant Operator fee constant.\\n    function encodeSetL1BlockValuesIsthmus(\\n        uint32 _baseFeeScalar,\\n        uint32 _blobBaseFeeScalar,\\n        uint64 _sequenceNumber,\\n        uint64 _timestamp,\\n        uint64 _number,\\n        uint256 _baseFee,\\n        uint256 _blobBaseFee,\\n        bytes32 _hash,\\n        bytes32 _batcherHash,\\n        uint32 _operatorFeeScalar,\\n        uint64 _operatorFeeConstant\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes4 functionSignature = bytes4(keccak256(\\\"setL1BlockValuesIsthmus()\\\"));\\n        return abi.encodePacked(\\n            functionSignature,\\n            _baseFeeScalar,\\n            _blobBaseFeeScalar,\\n            _sequenceNumber,\\n            _timestamp,\\n            _number,\\n            _baseFee,\\n            _blobBaseFee,\\n            _hash,\\n            _batcherHash,\\n            _operatorFeeScalar,\\n            _operatorFeeConstant\\n        );\\n    }\\n\\n    /// @notice Returns an appropriately encoded call to L1Block.setL1BlockValuesInterop\\n    /// @param _baseFeeScalar       L1 base fee Scalar\\n    /// @param _blobBaseFeeScalar   L1 blob base fee Scalar\\n    /// @param _sequenceNumber      Number of L2 blocks since epoch start.\\n    /// @param _timestamp           L1 timestamp.\\n    /// @param _number              L1 blocknumber.\\n    /// @param _baseFee             L1 base fee.\\n    /// @param _blobBaseFee         L1 blob base fee.\\n    /// @param _hash                L1 blockhash.\\n    /// @param _batcherHash         Versioned hash to authenticate batcher by.\\n    function encodeSetL1BlockValuesInterop(\\n        uint32 _baseFeeScalar,\\n        uint32 _blobBaseFeeScalar,\\n        uint64 _sequenceNumber,\\n        uint64 _timestamp,\\n        uint64 _number,\\n        uint256 _baseFee,\\n        uint256 _blobBaseFee,\\n        bytes32 _hash,\\n        bytes32 _batcherHash\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes4 functionSignature = bytes4(keccak256(\\\"setL1BlockValuesInterop()\\\"));\\n        return abi.encodePacked(\\n            functionSignature,\\n            _baseFeeScalar,\\n            _blobBaseFeeScalar,\\n            _sequenceNumber,\\n            _timestamp,\\n            _number,\\n            _baseFee,\\n            _blobBaseFee,\\n            _hash,\\n            _batcherHash\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/trie/MerkleTrie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport { Bytes } from \\\"src/libraries/Bytes.sol\\\";\\nimport { RLPReader } from \\\"src/libraries/rlp/RLPReader.sol\\\";\\n\\n/// @title MerkleTrie\\n/// @notice MerkleTrie is a small library for verifying standard Ethereum Merkle-Patricia trie\\n///         inclusion proofs. By default, this library assumes a hexary trie. One can change the\\n///         trie radix constant to support other trie radixes.\\nlibrary MerkleTrie {\\n    /// @notice Struct representing a node in the trie.\\n    /// @custom:field encoded The RLP-encoded node.\\n    /// @custom:field decoded The RLP-decoded node.\\n    struct TrieNode {\\n        bytes encoded;\\n        RLPReader.RLPItem[] decoded;\\n    }\\n\\n    /// @notice Determines the number of elements per branch node.\\n    uint256 internal constant TREE_RADIX = 16;\\n\\n    /// @notice Branch nodes have TREE_RADIX elements and one value element.\\n    uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\\n\\n    /// @notice Leaf nodes and extension nodes have two elements, a `path` and a `value`.\\n    uint256 internal constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\\n\\n    /// @notice Prefix for even-nibbled extension node paths.\\n    uint8 internal constant PREFIX_EXTENSION_EVEN = 0;\\n\\n    /// @notice Prefix for odd-nibbled extension node paths.\\n    uint8 internal constant PREFIX_EXTENSION_ODD = 1;\\n\\n    /// @notice Prefix for even-nibbled leaf node paths.\\n    uint8 internal constant PREFIX_LEAF_EVEN = 2;\\n\\n    /// @notice Prefix for odd-nibbled leaf node paths.\\n    uint8 internal constant PREFIX_LEAF_ODD = 3;\\n\\n    /// @notice Verifies a proof that a given key/value pair is present in the trie.\\n    /// @param _key   Key of the node to search for, as a hex string.\\n    /// @param _value Value of the node to search for, as a hex string.\\n    /// @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\\n    ///               trees, this proof is executed top-down and consists of a list of RLP-encoded\\n    ///               nodes that make a path down to the target node.\\n    /// @param _root  Known root of the Merkle trie. Used to verify that the included proof is\\n    ///               correctly constructed.\\n    /// @return valid_ Whether or not the proof is valid.\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes[] memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (bool valid_)\\n    {\\n        valid_ = Bytes.equal(_value, get(_key, _proof, _root));\\n    }\\n\\n    /// @notice Retrieves the value associated with a given key.\\n    /// @param _key   Key to search for, as hex bytes.\\n    /// @param _proof Merkle trie inclusion proof for the key.\\n    /// @param _root  Known root of the Merkle trie.\\n    /// @return value_ Value of the key if it exists.\\n    function get(bytes memory _key, bytes[] memory _proof, bytes32 _root) internal pure returns (bytes memory value_) {\\n        require(_key.length > 0, \\\"MerkleTrie: empty key\\\");\\n\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        bytes memory key = Bytes.toNibbles(_key);\\n        bytes memory currentNodeID = abi.encodePacked(_root);\\n        uint256 currentKeyIndex = 0;\\n\\n        // Proof is top-down, so we start at the first element (root).\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            TrieNode memory currentNode = proof[i];\\n\\n            // Key index should never exceed total key length or we'll be out of bounds.\\n            require(currentKeyIndex <= key.length, \\\"MerkleTrie: key index exceeds total key length\\\");\\n\\n            if (currentKeyIndex == 0) {\\n                // First proof element is always the root node.\\n                require(\\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\\n                    \\\"MerkleTrie: invalid root hash\\\"\\n                );\\n            } else if (currentNode.encoded.length >= 32) {\\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\\n                require(\\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\\n                    \\\"MerkleTrie: invalid large internal hash\\\"\\n                );\\n            } else {\\n                // Nodes smaller than 32 bytes aren't hashed.\\n                require(Bytes.equal(currentNode.encoded, currentNodeID), \\\"MerkleTrie: invalid internal node hash\\\");\\n            }\\n\\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\\n                if (currentKeyIndex == key.length) {\\n                    // Value is the last element of the decoded list (for branch nodes). There's\\n                    // some ambiguity in the Merkle trie specification because bytes(0) is a\\n                    // valid value to place into the trie, but for branch nodes bytes(0) can exist\\n                    // even when the value wasn't explicitly placed there. Geth treats a value of\\n                    // bytes(0) as \\\"key does not exist\\\" and so we do the same.\\n                    value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);\\n                    require(value_.length > 0, \\\"MerkleTrie: value length must be greater than zero (branch)\\\");\\n\\n                    // Extra proof elements are not allowed.\\n                    require(i == proof.length - 1, \\\"MerkleTrie: value node must be last node in proof (branch)\\\");\\n\\n                    return value_;\\n                } else {\\n                    // We're not at the end of the key yet.\\n                    // Figure out what the next node ID should be and continue.\\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\\n                    RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\\n                    currentNodeID = _getNodeID(nextNode);\\n                    currentKeyIndex += 1;\\n                }\\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n                bytes memory path = _getNodePath(currentNode);\\n                uint8 prefix = uint8(path[0]);\\n                uint8 offset = 2 - (prefix % 2);\\n                bytes memory pathRemainder = Bytes.slice(path, offset);\\n                bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);\\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\\n\\n                // Whether this is a leaf node or an extension node, the path remainder MUST be a\\n                // prefix of the key remainder (or be equal to the key remainder) or the proof is\\n                // considered invalid.\\n                require(\\n                    pathRemainder.length == sharedNibbleLength,\\n                    \\\"MerkleTrie: path remainder must share all nibbles with key\\\"\\n                );\\n\\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                    // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,\\n                    // the key remainder must be exactly equal to the path remainder. We already\\n                    // did the necessary byte comparison, so it's more efficient here to check that\\n                    // the key remainder length equals the shared nibble length, which implies\\n                    // equality with the path remainder (since we already did the same check with\\n                    // the path remainder and the shared nibble length).\\n                    require(\\n                        keyRemainder.length == sharedNibbleLength,\\n                        \\\"MerkleTrie: key remainder must be identical to path remainder\\\"\\n                    );\\n\\n                    // Our Merkle Trie is designed specifically for the purposes of the Ethereum\\n                    // state trie. Empty values are not allowed in the state trie, so we can safely\\n                    // say that if the value is empty, the key should not exist and the proof is\\n                    // invalid.\\n                    value_ = RLPReader.readBytes(currentNode.decoded[1]);\\n                    require(value_.length > 0, \\\"MerkleTrie: value length must be greater than zero (leaf)\\\");\\n\\n                    // Extra proof elements are not allowed.\\n                    require(i == proof.length - 1, \\\"MerkleTrie: value node must be last node in proof (leaf)\\\");\\n\\n                    return value_;\\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                    // Prefix of 0 or 1 means this is an extension node. We move onto the next node\\n                    // in the proof and increment the key index by the length of the path remainder\\n                    // which is equal to the shared nibble length.\\n                    currentNodeID = _getNodeID(currentNode.decoded[1]);\\n                    currentKeyIndex += sharedNibbleLength;\\n                } else {\\n                    revert(\\\"MerkleTrie: received a node with an unknown prefix\\\");\\n                }\\n            } else {\\n                revert(\\\"MerkleTrie: received an unparseable node\\\");\\n            }\\n        }\\n\\n        revert(\\\"MerkleTrie: ran out of proof elements\\\");\\n    }\\n\\n    /// @notice Parses an array of proof elements into a new array that contains both the original\\n    ///         encoded element and the RLP-decoded element.\\n    /// @param _proof Array of proof elements to parse.\\n    /// @return proof_ Proof parsed into easily accessible structs.\\n    function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory proof_) {\\n        uint256 length = _proof.length;\\n        proof_ = new TrieNode[](length);\\n        for (uint256 i = 0; i < length;) {\\n            proof_[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Picks out the ID for a node. Node ID is referred to as the \\\"hash\\\" within the\\n    ///         specification, but nodes < 32 bytes are not actually hashed.\\n    /// @param _node Node to pull an ID for.\\n    /// @return id_ ID for the node, depending on the size of its contents.\\n    function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory id_) {\\n        id_ = _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);\\n    }\\n\\n    /// @notice Gets the path for a leaf or extension node.\\n    /// @param _node Node to get a path for.\\n    /// @return nibbles_ Node path, converted to an array of nibbles.\\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory nibbles_) {\\n        nibbles_ = Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));\\n    }\\n\\n    /// @notice Utility; determines the number of nibbles shared between two nibble arrays.\\n    /// @param _a First nibble array.\\n    /// @param _b Second nibble array.\\n    /// @return shared_ Number of shared nibbles.\\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b) private pure returns (uint256 shared_) {\\n        uint256 max = (_a.length < _b.length) ? _a.length : _b.length;\\n        for (; shared_ < max && _a[shared_] == _b[shared_];) {\\n            unchecked {\\n                ++shared_;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/dispute/lib/LibUDT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n// Libraries\\nimport { Position } from \\\"src/dispute/lib/LibPosition.sol\\\";\\n\\nusing LibClaim for Claim global;\\nusing LibHash for Hash global;\\nusing LibDuration for Duration global;\\nusing LibClock for Clock global;\\nusing LibGameId for GameId global;\\nusing LibTimestamp for Timestamp global;\\nusing LibVMStatus for VMStatus global;\\nusing LibGameType for GameType global;\\n\\n/// @notice A `Clock` represents a packed `Duration` and `Timestamp`\\n/// @dev The packed layout of this type is as follows:\\n/// ┌────────────┬────────────────┐\\n/// │    Bits    │     Value      │\\n/// ├────────────┼────────────────┤\\n/// │ [0, 64)    │ Duration       │\\n/// │ [64, 128)  │ Timestamp      │\\n/// └────────────┴────────────────┘\\ntype Clock is uint128;\\n\\n/// @title LibClock\\n/// @notice This library contains helper functions for working with the `Clock` type.\\nlibrary LibClock {\\n    /// @notice Packs a `Duration` and `Timestamp` into a `Clock` type.\\n    /// @param _duration The `Duration` to pack into the `Clock` type.\\n    /// @param _timestamp The `Timestamp` to pack into the `Clock` type.\\n    /// @return clock_ The `Clock` containing the `_duration` and `_timestamp`.\\n    function wrap(Duration _duration, Timestamp _timestamp) internal pure returns (Clock clock_) {\\n        assembly {\\n            clock_ := or(shl(0x40, _duration), _timestamp)\\n        }\\n    }\\n\\n    /// @notice Pull the `Duration` out of a `Clock` type.\\n    /// @param _clock The `Clock` type to pull the `Duration` out of.\\n    /// @return duration_ The `Duration` pulled out of `_clock`.\\n    function duration(Clock _clock) internal pure returns (Duration duration_) {\\n        // Shift the high-order 64 bits into the low-order 64 bits, leaving only the `duration`.\\n        assembly {\\n            duration_ := shr(0x40, _clock)\\n        }\\n    }\\n\\n    /// @notice Pull the `Timestamp` out of a `Clock` type.\\n    /// @param _clock The `Clock` type to pull the `Timestamp` out of.\\n    /// @return timestamp_ The `Timestamp` pulled out of `_clock`.\\n    function timestamp(Clock _clock) internal pure returns (Timestamp timestamp_) {\\n        // Clean the high-order 192 bits by shifting the clock left and then right again, leaving\\n        // only the `timestamp`.\\n        assembly {\\n            timestamp_ := shr(0xC0, shl(0xC0, _clock))\\n        }\\n    }\\n\\n    /// @notice Get the value of a `Clock` type in the form of the underlying uint128.\\n    /// @param _clock The `Clock` type to get the value of.\\n    /// @return clock_ The value of the `Clock` type as a uint128 type.\\n    function raw(Clock _clock) internal pure returns (uint128 clock_) {\\n        assembly {\\n            clock_ := _clock\\n        }\\n    }\\n}\\n\\n/// @notice A `GameId` represents a packed 4 byte game ID, a 8 byte timestamp, and a 20 byte address.\\n/// @dev The packed layout of this type is as follows:\\n/// ┌───────────┬───────────┐\\n/// │   Bits    │   Value   │\\n/// ├───────────┼───────────┤\\n/// │ [0, 32)   │ Game Type │\\n/// │ [32, 96)  │ Timestamp │\\n/// │ [96, 256) │ Address   │\\n/// └───────────┴───────────┘\\ntype GameId is bytes32;\\n\\n/// @title LibGameId\\n/// @notice Utility functions for packing and unpacking GameIds.\\nlibrary LibGameId {\\n    /// @notice Packs values into a 32 byte GameId type.\\n    /// @param _gameType The game type.\\n    /// @param _timestamp The timestamp of the game's creation.\\n    /// @param _gameProxy The game proxy address.\\n    /// @return gameId_ The packed GameId.\\n    function pack(\\n        GameType _gameType,\\n        Timestamp _timestamp,\\n        address _gameProxy\\n    )\\n        internal\\n        pure\\n        returns (GameId gameId_)\\n    {\\n        assembly {\\n            gameId_ := or(or(shl(224, _gameType), shl(160, _timestamp)), _gameProxy)\\n        }\\n    }\\n\\n    /// @notice Unpacks values from a 32 byte GameId type.\\n    /// @param _gameId The packed GameId.\\n    /// @return gameType_ The game type.\\n    /// @return timestamp_ The timestamp of the game's creation.\\n    /// @return gameProxy_ The game proxy address.\\n    function unpack(GameId _gameId)\\n        internal\\n        pure\\n        returns (GameType gameType_, Timestamp timestamp_, address gameProxy_)\\n    {\\n        assembly {\\n            gameType_ := shr(224, _gameId)\\n            timestamp_ := and(shr(160, _gameId), 0xFFFFFFFFFFFFFFFF)\\n            gameProxy_ := and(_gameId, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        }\\n    }\\n}\\n\\n/// @notice A claim represents an MPT root representing the state of the fault proof program.\\ntype Claim is bytes32;\\n\\n/// @title LibClaim\\n/// @notice This library contains helper functions for working with the `Claim` type.\\nlibrary LibClaim {\\n    /// @notice Get the value of a `Claim` type in the form of the underlying bytes32.\\n    /// @param _claim The `Claim` type to get the value of.\\n    /// @return claim_ The value of the `Claim` type as a bytes32 type.\\n    function raw(Claim _claim) internal pure returns (bytes32 claim_) {\\n        assembly {\\n            claim_ := _claim\\n        }\\n    }\\n\\n    /// @notice Hashes a claim and a position together.\\n    /// @param _claim A Claim type.\\n    /// @param _position The position of `claim`.\\n    /// @param _challengeIndex The index of the claim being moved against.\\n    /// @return claimHash_ A hash of abi.encodePacked(claim, position|challengeIndex);\\n    function hashClaimPos(\\n        Claim _claim,\\n        Position _position,\\n        uint256 _challengeIndex\\n    )\\n        internal\\n        pure\\n        returns (Hash claimHash_)\\n    {\\n        assembly {\\n            mstore(0x00, _claim)\\n            mstore(0x20, or(shl(128, _position), and(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, _challengeIndex)))\\n            claimHash_ := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\\n/// @notice A dedicated duration type.\\n/// @dev Unit: seconds\\ntype Duration is uint64;\\n\\n/// @title LibDuration\\n/// @notice This library contains helper functions for working with the `Duration` type.\\nlibrary LibDuration {\\n    /// @notice Get the value of a `Duration` type in the form of the underlying uint64.\\n    /// @param _duration The `Duration` type to get the value of.\\n    /// @return duration_ The value of the `Duration` type as a uint64 type.\\n    function raw(Duration _duration) internal pure returns (uint64 duration_) {\\n        assembly {\\n            duration_ := _duration\\n        }\\n    }\\n}\\n\\n/// @notice A custom type for a generic hash.\\ntype Hash is bytes32;\\n\\n/// @title LibHash\\n/// @notice This library contains helper functions for working with the `Hash` type.\\nlibrary LibHash {\\n    /// @notice Get the value of a `Hash` type in the form of the underlying bytes32.\\n    /// @param _hash The `Hash` type to get the value of.\\n    /// @return hash_ The value of the `Hash` type as a bytes32 type.\\n    function raw(Hash _hash) internal pure returns (bytes32 hash_) {\\n        assembly {\\n            hash_ := _hash\\n        }\\n    }\\n}\\n\\n/// @notice A dedicated timestamp type.\\ntype Timestamp is uint64;\\n\\n/// @title LibTimestamp\\n/// @notice This library contains helper functions for working with the `Timestamp` type.\\nlibrary LibTimestamp {\\n    /// @notice Get the value of a `Timestamp` type in the form of the underlying uint64.\\n    /// @param _timestamp The `Timestamp` type to get the value of.\\n    /// @return timestamp_ The value of the `Timestamp` type as a uint64 type.\\n    function raw(Timestamp _timestamp) internal pure returns (uint64 timestamp_) {\\n        assembly {\\n            timestamp_ := _timestamp\\n        }\\n    }\\n}\\n\\n/// @notice A `VMStatus` represents the status of a VM execution.\\ntype VMStatus is uint8;\\n\\n/// @title LibVMStatus\\n/// @notice This library contains helper functions for working with the `VMStatus` type.\\nlibrary LibVMStatus {\\n    /// @notice Get the value of a `VMStatus` type in the form of the underlying uint8.\\n    /// @param _vmstatus The `VMStatus` type to get the value of.\\n    /// @return vmstatus_ The value of the `VMStatus` type as a uint8 type.\\n    function raw(VMStatus _vmstatus) internal pure returns (uint8 vmstatus_) {\\n        assembly {\\n            vmstatus_ := _vmstatus\\n        }\\n    }\\n}\\n\\n/// @notice A `GameType` represents the type of game being played.\\ntype GameType is uint32;\\n\\n/// @title LibGameType\\n/// @notice This library contains helper functions for working with the `GameType` type.\\nlibrary LibGameType {\\n    /// @notice Get the value of a `GameType` type in the form of the underlying uint32.\\n    /// @param _gametype The `GameType` type to get the value of.\\n    /// @return gametype_ The value of the `GameType` type as a uint32 type.\\n    function raw(GameType _gametype) internal pure returns (uint32 gametype_) {\\n        assembly {\\n            gametype_ := _gametype\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IInitializable {\\n    function initialize() external payable;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\\n    }\\n\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return 0;\\n\\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n            if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5**18;\\n\\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            require(x > 0, \\\"UNDEFINED\\\");\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            int256 k = int256(log2(uint256(x))) - 96;\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549…\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/rlp/RLPWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n/// @title RLPWriter\\n/// @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n///         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n///         modifications to improve legibility.\\nlibrary RLPWriter {\\n    /// @notice RLP encodes a byte string.\\n    /// @param _in The byte string to encode.\\n    /// @return out_ The RLP encoded string in bytes.\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory out_) {\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            out_ = _in;\\n        } else {\\n            out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n    }\\n\\n    /// @notice RLP encodes a list of RLP encoded byte byte strings.\\n    /// @param _in The list of RLP encoded byte strings.\\n    /// @return list_ The RLP encoded list of items in bytes.\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory list_) {\\n        list_ = _flatten(_in);\\n        list_ = abi.encodePacked(_writeLength(list_.length, 192), list_);\\n    }\\n\\n    /// @notice RLP encodes a string.\\n    /// @param _in The string to encode.\\n    /// @return out_ The RLP encoded string in bytes.\\n    function writeString(string memory _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(bytes(_in));\\n    }\\n\\n    /// @notice RLP encodes an address.\\n    /// @param _in The address to encode.\\n    /// @return out_ The RLP encoded address in bytes.\\n    function writeAddress(address _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /// @notice RLP encodes a uint.\\n    /// @param _in The uint256 to encode.\\n    /// @return out_ The RLP encoded uint256 in bytes.\\n    function writeUint(uint256 _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(_toBinary(_in));\\n    }\\n\\n    /// @notice RLP encodes a bool.\\n    /// @param _in The bool to encode.\\n    /// @return out_ The RLP encoded bool in bytes.\\n    function writeBool(bool _in) internal pure returns (bytes memory out_) {\\n        out_ = new bytes(1);\\n        out_[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n    }\\n\\n    /// @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n    /// @param _len    The length of the string or the payload.\\n    /// @param _offset 128 if item is string, 192 if item is list.\\n    /// @return out_ RLP encoded bytes.\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory out_) {\\n        if (_len < 56) {\\n            out_ = new bytes(1);\\n            out_[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            out_ = new bytes(lenLen + 1);\\n            out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\\n            }\\n        }\\n    }\\n\\n    /// @notice Encode integer in big endian binary form with no leading zeroes.\\n    /// @param _x The integer to encode.\\n    /// @return out_ RLP encoded bytes.\\n    function _toBinary(uint256 _x) private pure returns (bytes memory out_) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        out_ = new bytes(32 - i);\\n        for (uint256 j = 0; j < out_.length; j++) {\\n            out_[j] = b[i++];\\n        }\\n    }\\n\\n    /// @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n    /// @notice Copies a piece of memory to another location.\\n    /// @param _dest Destination location.\\n    /// @param _src  Source location.\\n    /// @param _len  Length of memory to copy.\\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /// @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n    /// @notice Flattens a list of byte strings into one byte string.\\n    /// @param _list List of byte strings to flatten.\\n    /// @return out_ The flattened byte string.\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory out_) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        out_ = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(out_, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Bytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Bytes\\n/// @notice Bytes is a library for manipulating byte arrays.\\nlibrary Bytes {\\n    /// @custom:attribution https://github.com/GNSPS/solidity-bytes-utils\\n    /// @notice Slices a byte array with a given starting index and length. Returns a new byte array\\n    ///         as opposed to a pointer to the original array. Will throw if trying to slice more\\n    ///         bytes than exist in the array.\\n    /// @param _bytes Byte array to slice.\\n    /// @param _start Starting index of the slice.\\n    /// @param _length Length of the slice.\\n    /// @return Slice of the input byte array.\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        unchecked {\\n            require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n            require(_start + _length >= _start, \\\"slice_overflow\\\");\\n            require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n        }\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } { mstore(mc, mload(cc)) }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// @notice Slices a byte array with a given starting index up to the end of the original byte\\n    ///         array. Returns a new array rathern than a pointer to the original.\\n    /// @param _bytes Byte array to slice.\\n    /// @param _start Starting index of the slice.\\n    /// @return Slice of the input byte array.\\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    /// @notice Converts a byte array into a nibble array by splitting each byte into two nibbles.\\n    ///         Resulting nibble array will be exactly twice as long as the input byte array.\\n    /// @param _bytes Input byte array to convert.\\n    /// @return Resulting nibble array.\\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory _nibbles;\\n        assembly {\\n            // Grab a free memory offset for the new array\\n            _nibbles := mload(0x40)\\n\\n            // Load the length of the passed bytes array from memory\\n            let bytesLength := mload(_bytes)\\n\\n            // Calculate the length of the new nibble array\\n            // This is the length of the input array times 2\\n            let nibblesLength := shl(0x01, bytesLength)\\n\\n            // Update the free memory pointer to allocate memory for the new array.\\n            // To do this, we add the length of the new array + 32 bytes for the array length\\n            // rounded up to the nearest 32 byte boundary to the current free memory pointer.\\n            mstore(0x40, add(_nibbles, and(not(0x1F), add(nibblesLength, 0x3F))))\\n\\n            // Store the length of the new array in memory\\n            mstore(_nibbles, nibblesLength)\\n\\n            // Store the memory offset of the _bytes array's contents on the stack\\n            let bytesStart := add(_bytes, 0x20)\\n\\n            // Store the memory offset of the nibbles array's contents on the stack\\n            let nibblesStart := add(_nibbles, 0x20)\\n\\n            // Loop through each byte in the input array\\n            for { let i := 0x00 } lt(i, bytesLength) { i := add(i, 0x01) } {\\n                // Get the starting offset of the next 2 bytes in the nibbles array\\n                let offset := add(nibblesStart, shl(0x01, i))\\n                // Load the byte at the current index within the `_bytes` array\\n                let b := byte(0x00, mload(add(bytesStart, i)))\\n\\n                // Pull out the first nibble and store it in the new array\\n                mstore8(offset, shr(0x04, b))\\n                // Pull out the second nibble and store it in the new array\\n                mstore8(add(offset, 0x01), and(b, 0x0F))\\n            }\\n        }\\n        return _nibbles;\\n    }\\n\\n    /// @notice Compares two byte arrays by comparing their keccak256 hashes.\\n    /// @param _bytes First byte array to compare.\\n    /// @param _other Second byte array to compare.\\n    /// @return True if the two byte arrays are equal, false otherwise.\\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/rlp/RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n// Libraries\\nimport {\\n    EmptyItem,\\n    UnexpectedString,\\n    InvalidDataRemainder,\\n    ContentLengthMismatch,\\n    InvalidHeader,\\n    UnexpectedList\\n} from \\\"src/libraries/rlp/RLPErrors.sol\\\";\\n\\n/// @custom:attribution https://github.com/hamdiallam/Solidity-RLP\\n/// @title RLPReader\\n/// @notice RLPReader is a library for parsing RLP-encoded byte arrays into Solidity types. Adapted\\n///         from Solidity-RLP (https://github.com/hamdiallam/Solidity-RLP) by Hamdi Allam with\\n///         various tweaks to improve readability.\\nlibrary RLPReader {\\n    /// @notice Custom pointer type to avoid confusion between pointers and uint256s.\\n    type MemoryPointer is uint256;\\n\\n    /// @notice RLP item types.\\n    /// @custom:value DATA_ITEM Represents an RLP data item (NOT a list).\\n    /// @custom:value LIST_ITEM Represents an RLP list item.\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /// @notice Struct representing an RLP item.\\n    /// @custom:field length Length of the RLP item.\\n    /// @custom:field ptr    Pointer to the RLP item in memory.\\n    struct RLPItem {\\n        uint256 length;\\n        MemoryPointer ptr;\\n    }\\n\\n    /// @notice Max list length that this library will accept.\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /// @notice Converts bytes to a reference to memory position and length.\\n    /// @param _in Input bytes to convert.\\n    /// @return out_ Output memory reference.\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory out_) {\\n        // Empty arrays are not RLP items.\\n        if (_in.length == 0) revert EmptyItem();\\n\\n        MemoryPointer ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        out_ = RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /// @notice Reads an RLP list value into a list of RLP items.\\n    /// @param _in RLP list value.\\n    /// @return out_ Decoded RLP list items.\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory out_) {\\n        (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        if (itemType != RLPItemType.LIST_ITEM) revert UnexpectedString();\\n\\n        if (listOffset + listLength != _in.length) revert InvalidDataRemainder();\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        out_ = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            (uint256 itemOffset, uint256 itemLength,) = _decodeLength(\\n                RLPItem({ length: _in.length - offset, ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset) })\\n            );\\n\\n            // We don't need to check itemCount < out.length explicitly because Solidity already\\n            // handles this check on our behalf, we'd just be wasting gas.\\n            out_[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out_, itemCount)\\n        }\\n    }\\n\\n    /// @notice Reads an RLP list value into a list of RLP items.\\n    /// @param _in RLP list value.\\n    /// @return out_ Decoded RLP list items.\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory out_) {\\n        out_ = readList(toRLPItem(_in));\\n    }\\n\\n    /// @notice Reads an RLP bytes value into bytes.\\n    /// @param _in RLP bytes value.\\n    /// @return out_ Decoded bytes.\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        if (itemType != RLPItemType.DATA_ITEM) revert UnexpectedList();\\n\\n        if (_in.length != itemOffset + itemLength) revert InvalidDataRemainder();\\n\\n        out_ = _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /// @notice Reads an RLP bytes value into bytes.\\n    /// @param _in RLP bytes value.\\n    /// @return out_ Decoded bytes.\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory out_) {\\n        out_ = readBytes(toRLPItem(_in));\\n    }\\n\\n    /// @notice Reads the raw bytes of an RLP item.\\n    /// @param _in RLP item to read.\\n    /// @return out_ Raw RLP bytes.\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {\\n        out_ = _copy(_in.ptr, 0, _in.length);\\n    }\\n\\n    /// @notice Decodes the length of an RLP item.\\n    /// @param _in RLP item to decode.\\n    /// @return offset_ Offset of the encoded data.\\n    /// @return length_ Length of the encoded data.\\n    /// @return type_ RLP item type (LIST_ITEM or DATA_ITEM).\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (uint256 offset_, uint256 length_, RLPItemType type_)\\n    {\\n        // Short-circuit if there's nothing to decode, note that we perform this check when\\n        // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass\\n        // that function and create an RLP item directly. So we need to check this anyway.\\n        if (_in.length == 0) revert EmptyItem();\\n\\n        MemoryPointer ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            // slither-disable-next-line variable-scope\\n            uint256 strLen = prefix - 0x80;\\n\\n            if (_in.length <= strLen) revert ContentLengthMismatch();\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            if (strLen == 1 && firstByteOfContent < 0x80) revert InvalidHeader();\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            if (_in.length <= lenOfStrLen) revert ContentLengthMismatch();\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            if (firstByteOfContent == 0x00) revert InvalidHeader();\\n\\n            uint256 strLen;\\n            assembly {\\n                strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))\\n            }\\n\\n            if (strLen <= 55) revert InvalidHeader();\\n\\n            if (_in.length <= lenOfStrLen + strLen) revert ContentLengthMismatch();\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            // slither-disable-next-line variable-scope\\n            uint256 listLen = prefix - 0xc0;\\n\\n            if (_in.length <= listLen) revert ContentLengthMismatch();\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            if (_in.length <= lenOfListLen) revert ContentLengthMismatch();\\n\\n            bytes1 firstByteOfContent;\\n            assembly {\\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\\n            }\\n\\n            if (firstByteOfContent == 0x00) revert InvalidHeader();\\n\\n            uint256 listLen;\\n            assembly {\\n                listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))\\n            }\\n\\n            if (listLen <= 55) revert InvalidHeader();\\n\\n            if (_in.length <= lenOfListLen + listLen) revert ContentLengthMismatch();\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /// @notice Copies the bytes from a memory location.\\n    /// @param _src    Pointer to the location to read from.\\n    /// @param _offset Offset to start reading from.\\n    /// @param _length Number of bytes to read.\\n    /// @return out_ Copied bytes.\\n    function _copy(MemoryPointer _src, uint256 _offset, uint256 _length) private pure returns (bytes memory out_) {\\n        out_ = new bytes(_length);\\n        if (_length == 0) {\\n            return out_;\\n        }\\n\\n        // Mostly based on Solidity's copy_memory_to_memory:\\n        // https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114\\n        uint256 src = MemoryPointer.unwrap(_src) + _offset;\\n        assembly {\\n            let dest := add(out_, 32)\\n            let i := 0\\n            for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }\\n\\n            if gt(i, _length) { mstore(add(dest, _length), 0) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/dispute/lib/LibPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nusing LibPosition for Position global;\\n\\n/// @notice A `Position` represents a position of a claim within the game tree.\\n/// @dev This is represented as a \\\"generalized index\\\" where the high-order bit\\n/// is the level in the tree and the remaining bits is a unique bit pattern, allowing\\n/// a unique identifier for each node in the tree. Mathematically, it is calculated\\n/// as 2^{depth} + indexAtDepth.\\ntype Position is uint128;\\n\\n/// @title LibPosition\\n/// @notice This library contains helper functions for working with the `Position` type.\\nlibrary LibPosition {\\n    /// @notice the `MAX_POSITION_BITLEN` is the number of bits that the `Position` type, and the implementation of\\n    ///         its behavior within this library, can safely support.\\n    uint8 internal constant MAX_POSITION_BITLEN = 126;\\n\\n    /// @notice Computes a generalized index (2^{depth} + indexAtDepth).\\n    /// @param _depth The depth of the position.\\n    /// @param _indexAtDepth The index at the depth of the position.\\n    /// @return position_ The computed generalized index.\\n    function wrap(uint8 _depth, uint128 _indexAtDepth) internal pure returns (Position position_) {\\n        assembly {\\n            // gindex = 2^{_depth} + _indexAtDepth\\n            position_ := add(shl(_depth, 1), _indexAtDepth)\\n        }\\n    }\\n\\n    /// @notice Pulls the `depth` out of a `Position` type.\\n    /// @param _position The generalized index to get the `depth` of.\\n    /// @return depth_ The `depth` of the `position` gindex.\\n    /// @custom:attribution Solady <https://github.com/Vectorized/Solady>\\n    function depth(Position _position) internal pure returns (uint8 depth_) {\\n        // Return the most significant bit offset, which signifies the depth of the gindex.\\n        assembly {\\n            depth_ := or(depth_, shl(6, lt(0xffffffffffffffff, shr(depth_, _position))))\\n            depth_ := or(depth_, shl(5, lt(0xffffffff, shr(depth_, _position))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            _position := shr(depth_, _position)\\n            _position := or(_position, shr(1, _position))\\n            _position := or(_position, shr(2, _position))\\n            _position := or(_position, shr(4, _position))\\n            _position := or(_position, shr(8, _position))\\n            _position := or(_position, shr(16, _position))\\n\\n            depth_ :=\\n                or(\\n                    depth_,\\n                    byte(\\n                        shr(251, mul(_position, shl(224, 0x07c4acdd))),\\n                        0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @notice Pulls the `indexAtDepth` out of a `Position` type.\\n    ///         The `indexAtDepth` is the left/right index of a position at a specific depth within\\n    ///         the binary tree, starting from index 0. For example, at gindex 2, the `depth` = 1\\n    ///         and the `indexAtDepth` = 0.\\n    /// @param _position The generalized index to get the `indexAtDepth` of.\\n    /// @return indexAtDepth_ The `indexAtDepth` of the `position` gindex.\\n    function indexAtDepth(Position _position) internal pure returns (uint128 indexAtDepth_) {\\n        // Return bits p_{msb-1}...p_{0}. This effectively pulls the 2^{depth} out of the gindex,\\n        // leaving only the `indexAtDepth`.\\n        uint256 msb = depth(_position);\\n        assembly {\\n            indexAtDepth_ := sub(_position, shl(msb, 1))\\n        }\\n    }\\n\\n    /// @notice Get the left child of `_position`.\\n    /// @param _position The position to get the left position of.\\n    /// @return left_ The position to the left of `position`.\\n    function left(Position _position) internal pure returns (Position left_) {\\n        assembly {\\n            left_ := shl(1, _position)\\n        }\\n    }\\n\\n    /// @notice Get the right child of `_position`\\n    /// @param _position The position to get the right position of.\\n    /// @return right_ The position to the right of `position`.\\n    function right(Position _position) internal pure returns (Position right_) {\\n        assembly {\\n            right_ := or(1, shl(1, _position))\\n        }\\n    }\\n\\n    /// @notice Get the parent position of `_position`.\\n    /// @param _position The position to get the parent position of.\\n    /// @return parent_ The parent position of `position`.\\n    function parent(Position _position) internal pure returns (Position parent_) {\\n        assembly {\\n            parent_ := shr(1, _position)\\n        }\\n    }\\n\\n    /// @notice Get the deepest, right most gindex relative to the `position`. This is equivalent to\\n    ///         calling `right` on a position until the maximum depth is reached.\\n    /// @param _position The position to get the relative deepest, right most gindex of.\\n    /// @param _maxDepth The maximum depth of the game.\\n    /// @return rightIndex_ The deepest, right most gindex relative to the `position`.\\n    function rightIndex(Position _position, uint256 _maxDepth) internal pure returns (Position rightIndex_) {\\n        uint256 msb = depth(_position);\\n        assembly {\\n            let remaining := sub(_maxDepth, msb)\\n            rightIndex_ := or(shl(remaining, _position), sub(shl(remaining, 1), 1))\\n        }\\n    }\\n\\n    /// @notice Get the deepest, right most trace index relative to the `position`. This is\\n    ///         equivalent to calling `right` on a position until the maximum depth is reached and\\n    ///         then finding its index at depth.\\n    /// @param _position The position to get the relative trace index of.\\n    /// @param _maxDepth The maximum depth of the game.\\n    /// @return traceIndex_ The trace index relative to the `position`.\\n    function traceIndex(Position _position, uint256 _maxDepth) internal pure returns (uint256 traceIndex_) {\\n        uint256 msb = depth(_position);\\n        assembly {\\n            let remaining := sub(_maxDepth, msb)\\n            traceIndex_ := sub(or(shl(remaining, _position), sub(shl(remaining, 1), 1)), shl(_maxDepth, 1))\\n        }\\n    }\\n\\n    /// @notice Gets the position of the highest ancestor of `_position` that commits to the same\\n    ///         trace index.\\n    /// @param _position The position to get the highest ancestor of.\\n    /// @return ancestor_ The highest ancestor of `position` that commits to the same trace index.\\n    function traceAncestor(Position _position) internal pure returns (Position ancestor_) {\\n        // Create a field with only the lowest unset bit of `_position` set.\\n        Position lsb;\\n        assembly {\\n            lsb := and(not(_position), add(_position, 1))\\n        }\\n        // Find the index of the lowest unset bit within the field.\\n        uint256 msb = depth(lsb);\\n        // The highest ancestor that commits to the same trace index is the original position\\n        // shifted right by the index of the lowest unset bit.\\n        assembly {\\n            let a := shr(msb, _position)\\n            // Bound the ancestor to the minimum gindex, 1.\\n            ancestor_ := or(a, iszero(a))\\n        }\\n    }\\n\\n    /// @notice Gets the position of the highest ancestor of `_position` that commits to the same\\n    ///         trace index, while still being below `_upperBoundExclusive`.\\n    /// @param _position The position to get the highest ancestor of.\\n    /// @param _upperBoundExclusive The exclusive upper depth bound, used to inform where to stop in order\\n    ///                             to not escape a sub-tree.\\n    /// @return ancestor_ The highest ancestor of `position` that commits to the same trace index.\\n    function traceAncestorBounded(\\n        Position _position,\\n        uint256 _upperBoundExclusive\\n    )\\n        internal\\n        pure\\n        returns (Position ancestor_)\\n    {\\n        // This function only works for positions that are below the upper bound.\\n        if (_position.depth() <= _upperBoundExclusive) {\\n            assembly {\\n                // Revert with `ClaimAboveSplit()`\\n                mstore(0x00, 0xb34b5c22)\\n                revert(0x1C, 0x04)\\n            }\\n        }\\n\\n        // Grab the global trace ancestor.\\n        ancestor_ = traceAncestor(_position);\\n\\n        // If the ancestor is above or at the upper bound, shift it to be below the upper bound.\\n        // This should be a special case that only covers positions that commit to the final leaf\\n        // in a sub-tree.\\n        if (ancestor_.depth() <= _upperBoundExclusive) {\\n            ancestor_ = ancestor_.rightIndex(_upperBoundExclusive + 1);\\n        }\\n    }\\n\\n    /// @notice Get the move position of `_position`, which is the left child of:\\n    ///         1. `_position` if `_isAttack` is true.\\n    ///         2. `_position | 1` if `_isAttack` is false.\\n    /// @param _position The position to get the relative attack/defense position of.\\n    /// @param _isAttack Whether or not the move is an attack move.\\n    /// @return move_ The move position relative to `position`.\\n    function move(Position _position, bool _isAttack) internal pure returns (Position move_) {\\n        assembly {\\n            move_ := shl(1, or(iszero(_isAttack), _position))\\n        }\\n    }\\n\\n    /// @notice Get the value of a `Position` type in the form of the underlying uint128.\\n    /// @param _position The position to get the value of.\\n    /// @return raw_ The value of the `position` as a uint128 type.\\n    function raw(Position _position) internal pure returns (uint128 raw_) {\\n        assembly {\\n            raw_ := _position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/rlp/RLPErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice The length of an RLP item must be greater than zero to be decodable\\nerror EmptyItem();\\n\\n/// @notice The decoded item type for list is not a list item\\nerror UnexpectedString();\\n\\n/// @notice The RLP item has an invalid data remainder\\nerror InvalidDataRemainder();\\n\\n/// @notice Decoded item type for bytes is not a string item\\nerror UnexpectedList();\\n\\n/// @notice The length of the content must be greater than the RLP item length\\nerror ContentLengthMismatch();\\n\\n/// @notice Invalid RLP header for RLP item\\nerror InvalidHeader();\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-v5/=lib/openzeppelin-contracts-v5/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"@lib-keccak/=lib/lib-keccak/contracts/lib/\",\r\n      \"@solady/=lib/solady/src/\",\r\n      \"@solady-v0.0.245/=lib/solady-v0.0.245/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"kontrol-cheatcodes/=lib/kontrol-cheatcodes/src/\",\r\n      \"interfaces/=interfaces/\",\r\n      \"@solady-test/=lib/lib-keccak/lib/solady/test/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-v5/lib/erc4626-tests/\",\r\n      \"lib-keccak/=lib/lib-keccak/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts-v5/=lib/openzeppelin-contracts-v5/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solady-v0.0.245/=lib/solady-v0.0.245/src/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proofMaturityDelaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_disputeGameFinalityDelaySeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyFinalized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Blacklisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContentLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyItem\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasEstimation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDataRemainder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDisputeGame\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidGameType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHeader\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMerkleProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LargeCalldata\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LegacyGame\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonReentrant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OutOfGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposalNotValidated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SmallGasLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnexpectedList\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnexpectedString\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unproven\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IDisputeGame\",\"name\":\"disputeGame\",\"type\":\"address\"}],\"name\":\"DisputeGameBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"GameType\",\"name\":\"newGameType\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"Timestamp\",\"name\":\"updatedAt\",\"type\":\"uint64\"}],\"name\":\"RespectedGameTypeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"opaqueData\",\"type\":\"bytes\"}],\"name\":\"TransactionDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"withdrawalHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"WithdrawalFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"withdrawalHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"WithdrawalProven\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"withdrawalHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proofSubmitter\",\"type\":\"address\"}],\"name\":\"WithdrawalProvenExtension1\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IDisputeGame\",\"name\":\"_disputeGame\",\"type\":\"address\"}],\"name\":\"blacklistDisputeGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_withdrawalHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_proofSubmitter\",\"type\":\"address\"}],\"name\":\"checkWithdrawal\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_gasLimit\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"_isCreation\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"depositTransaction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDisputeGame\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"disputeGameBlacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputeGameFactory\",\"outputs\":[{\"internalType\":\"contract IDisputeGameFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputeGameFinalityDelaySeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donateETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.WithdrawalTransaction\",\"name\":\"_tx\",\"type\":\"tuple\"}],\"name\":\"finalizeWithdrawalTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.WithdrawalTransaction\",\"name\":\"_tx\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_proofSubmitter\",\"type\":\"address\"}],\"name\":\"finalizeWithdrawalTransactionExternalProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"finalizedWithdrawals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDisputeGameFactory\",\"name\":\"_disputeGameFactory\",\"type\":\"address\"},{\"internalType\":\"contract ISystemConfig\",\"name\":\"_systemConfig\",\"type\":\"address\"},{\"internalType\":\"contract ISuperchainConfig\",\"name\":\"_superchainConfig\",\"type\":\"address\"},{\"internalType\":\"GameType\",\"name\":\"_initialRespectedGameType\",\"type\":\"uint32\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2Sender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_byteCount\",\"type\":\"uint64\"}],\"name\":\"minimumGasLimit\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_withdrawalHash\",\"type\":\"bytes32\"}],\"name\":\"numProofSubmitters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"params\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"prevBaseFee\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"prevBoughtGas\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"prevBlockNum\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proofMaturityDelaySeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proofSubmitters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.WithdrawalTransaction\",\"name\":\"_tx\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_disputeGameIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"version\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"messagePasserStorageRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"latestBlockhash\",\"type\":\"bytes32\"}],\"internalType\":\"struct Types.OutputRootProof\",\"name\":\"_outputRootProof\",\"type\":\"tuple\"},{\"internalType\":\"bytes[]\",\"name\":\"_withdrawalProof\",\"type\":\"bytes[]\"}],\"name\":\"proveWithdrawalTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"provenWithdrawals\",\"outputs\":[{\"internalType\":\"contract IDisputeGame\",\"name\":\"disputeGameProxy\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"respectedGameType\",\"outputs\":[{\"internalType\":\"GameType\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"respectedGameTypeUpdatedAt\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"GameType\",\"name\":\"_gameType\",\"type\":\"uint32\"}],\"name\":\"setRespectedGameType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superchainConfig\",\"outputs\":[{\"internalType\":\"contract ISuperchainConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemConfig\",\"outputs\":[{\"internalType\":\"contract ISystemConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "contract_name": "OptimismPortal2",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "optimization_used": "1",
      "runs": "999999",
      "constructor_arguments": "0000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000000000000000049d40",
      "evm_version": "london",
      "library": "",
      "license_type": "",
      "proxy": "0",
      "implementation": "",
      "bytecode": null
    },
    "0x78ffe9209dff6fe1c9b6f3efdf996bee60346d0e": {
      "address": "0x78ffe9209dff6fe1c9b6f3efdf996bee60346d0e",
      "has_source_code": true,
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/optimism/packages/contracts-bedrock/src/L1/SystemConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n// Contracts\\nimport { OwnableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\n// Libraries\\nimport { Storage } from \\\"src/libraries/Storage.sol\\\";\\n\\n// Interfaces\\nimport { ISemver } from \\\"interfaces/universal/ISemver.sol\\\";\\nimport { IResourceMetering } from \\\"interfaces/L1/IResourceMetering.sol\\\";\\n\\n/// @custom:proxied true\\n/// @title SystemConfig\\n/// @notice The SystemConfig contract is used to manage configuration of an Optimism network.\\n///         All configuration is stored on L1 and picked up by L2 as part of the derviation of\\n///         the L2 chain.\\ncontract SystemConfig is OwnableUpgradeable, ISemver {\\n    /// @notice Enum representing different types of updates.\\n    /// @custom:value BATCHER              Represents an update to the batcher hash.\\n    /// @custom:value FEE_SCALARS          Represents an update to l1 data fee scalars.\\n    /// @custom:value GAS_LIMIT            Represents an update to gas limit on L2.\\n    /// @custom:value UNSAFE_BLOCK_SIGNER  Represents an update to the signer key for unsafe\\n    ///                                    block distrubution.\\n    enum UpdateType {\\n        BATCHER,\\n        FEE_SCALARS,\\n        GAS_LIMIT,\\n        UNSAFE_BLOCK_SIGNER,\\n        EIP_1559_PARAMS,\\n        OPERATOR_FEE_PARAMS\\n    }\\n\\n    /// @notice Struct representing the addresses of L1 system contracts. These should be the\\n    ///         contracts that users interact with (not implementations for proxied contracts)\\n    ///         and are network specific.\\n    struct Addresses {\\n        address l1CrossDomainMessenger;\\n        address l1ERC721Bridge;\\n        address l1StandardBridge;\\n        address disputeGameFactory;\\n        address optimismPortal;\\n        address optimismMintableERC20Factory;\\n    }\\n\\n    /// @notice Version identifier, used for upgrades.\\n    uint256 public constant VERSION = 0;\\n\\n    /// @notice Storage slot that the unsafe block signer is stored at.\\n    ///         Storing it at this deterministic storage slot allows for decoupling the storage\\n    ///         layout from the way that `solc` lays out storage. The `op-node` uses a storage\\n    ///         proof to fetch this value.\\n    /// @dev    NOTE: this value will be migrated to another storage slot in a future version.\\n    ///         User input should not be placed in storage in this contract until this migration\\n    ///         happens. It is unlikely that keccak second preimage resistance will be broken,\\n    ///         but it is better to be safe than sorry.\\n    bytes32 public constant UNSAFE_BLOCK_SIGNER_SLOT = keccak256(\\\"systemconfig.unsafeblocksigner\\\");\\n\\n    /// @notice Storage slot that the L1CrossDomainMessenger address is stored at.\\n    bytes32 public constant L1_CROSS_DOMAIN_MESSENGER_SLOT =\\n        bytes32(uint256(keccak256(\\\"systemconfig.l1crossdomainmessenger\\\")) - 1);\\n\\n    /// @notice Storage slot that the L1ERC721Bridge address is stored at.\\n    bytes32 public constant L1_ERC_721_BRIDGE_SLOT = bytes32(uint256(keccak256(\\\"systemconfig.l1erc721bridge\\\")) - 1);\\n\\n    /// @notice Storage slot that the L1StandardBridge address is stored at.\\n    bytes32 public constant L1_STANDARD_BRIDGE_SLOT = bytes32(uint256(keccak256(\\\"systemconfig.l1standardbridge\\\")) - 1);\\n\\n    /// @notice Storage slot that the OptimismPortal address is stored at.\\n    bytes32 public constant OPTIMISM_PORTAL_SLOT = bytes32(uint256(keccak256(\\\"systemconfig.optimismportal\\\")) - 1);\\n\\n    /// @notice Storage slot that the OptimismMintableERC20Factory address is stored at.\\n    bytes32 public constant OPTIMISM_MINTABLE_ERC20_FACTORY_SLOT =\\n        bytes32(uint256(keccak256(\\\"systemconfig.optimismmintableerc20factory\\\")) - 1);\\n\\n    /// @notice Storage slot that the batch inbox address is stored at.\\n    bytes32 public constant BATCH_INBOX_SLOT = bytes32(uint256(keccak256(\\\"systemconfig.batchinbox\\\")) - 1);\\n\\n    /// @notice Storage slot for block at which the op-node can start searching for logs from.\\n    bytes32 public constant START_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"systemconfig.startBlock\\\")) - 1);\\n\\n    /// @notice Storage slot for the DisputeGameFactory address.\\n    bytes32 public constant DISPUTE_GAME_FACTORY_SLOT =\\n        bytes32(uint256(keccak256(\\\"systemconfig.disputegamefactory\\\")) - 1);\\n\\n    /// @notice The maximum gas limit that can be set for L2 blocks. This limit is used to enforce that the blocks\\n    ///         on L2 are not too large to process and prove. Over time, this value can be increased as various\\n    ///         optimizations and improvements are made to the system at large.\\n    uint64 internal constant MAX_GAS_LIMIT = 500_000_000;\\n\\n    /// @notice Fixed L2 gas overhead. Used as part of the L2 fee calculation.\\n    ///         Deprecated since the Ecotone network upgrade\\n    uint256 public overhead;\\n\\n    /// @notice Dynamic L2 gas overhead. Used as part of the L2 fee calculation.\\n    ///         The most significant byte is used to determine the version since the\\n    ///         Ecotone network upgrade.\\n    uint256 public scalar;\\n\\n    /// @notice Identifier for the batcher.\\n    ///         For version 1 of this configuration, this is represented as an address left-padded\\n    ///         with zeros to 32 bytes.\\n    bytes32 public batcherHash;\\n\\n    /// @notice L2 block gas limit.\\n    uint64 public gasLimit;\\n\\n    /// @notice Basefee scalar value. Part of the L2 fee calculation since the Ecotone network upgrade.\\n    uint32 public basefeeScalar;\\n\\n    /// @notice Blobbasefee scalar value. Part of the L2 fee calculation since the Ecotone network upgrade.\\n    uint32 public blobbasefeeScalar;\\n\\n    /// @notice The configuration for the deposit fee market.\\n    ///         Used by the OptimismPortal to meter the cost of buying L2 gas on L1.\\n    ///         Set as internal with a getter so that the struct is returned instead of a tuple.\\n    IResourceMetering.ResourceConfig internal _resourceConfig;\\n\\n    /// @notice The EIP-1559 base fee max change denominator.\\n    uint32 public eip1559Denominator;\\n\\n    /// @notice The EIP-1559 elasticity multiplier.\\n    uint32 public eip1559Elasticity;\\n\\n    /// @notice The operator fee scalar.\\n    uint32 public operatorFeeScalar;\\n\\n    /// @notice The operator fee constant.\\n    uint64 public operatorFeeConstant;\\n\\n    /// @notice Emitted when configuration is updated.\\n    /// @param version    SystemConfig version.\\n    /// @param updateType Type of update.\\n    /// @param data       Encoded update data.\\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\\n\\n    /// @notice Semantic version.\\n    /// @custom:semver 2.5.0+max-gas-limit-500M\\n    function version() public pure virtual returns (string memory) {\\n        return \\\"2.5.0+max-gas-limit-500M\\\";\\n    }\\n\\n    /// @notice Constructs the SystemConfig contract.\\n    /// @dev    START_BLOCK_SLOT is set to type(uint256).max here so that it will be a dead value\\n    ///         in the singleton.\\n    constructor() {\\n        Storage.setUint(START_BLOCK_SLOT, type(uint256).max);\\n        _disableInitializers();\\n    }\\n\\n    /// @notice Initializer.\\n    ///         The resource config must be set before the require check.\\n    /// @param _owner             Initial owner of the contract.\\n    /// @param _basefeeScalar     Initial basefee scalar value.\\n    /// @param _blobbasefeeScalar Initial blobbasefee scalar value.\\n    /// @param _batcherHash       Initial batcher hash.\\n    /// @param _gasLimit          Initial gas limit.\\n    /// @param _unsafeBlockSigner Initial unsafe block signer address.\\n    /// @param _config            Initial ResourceConfig.\\n    /// @param _batchInbox        Batch inbox address. An identifier for the op-node to find\\n    ///                           canonical data.\\n    /// @param _addresses         Set of L1 contract addresses. These should be the proxies.\\n    function initialize(\\n        address _owner,\\n        uint32 _basefeeScalar,\\n        uint32 _blobbasefeeScalar,\\n        bytes32 _batcherHash,\\n        uint64 _gasLimit,\\n        address _unsafeBlockSigner,\\n        IResourceMetering.ResourceConfig memory _config,\\n        address _batchInbox,\\n        SystemConfig.Addresses memory _addresses\\n    )\\n        public\\n        initializer\\n    {\\n        __Ownable_init();\\n        transferOwnership(_owner);\\n\\n        // These are set in ascending order of their UpdateTypes.\\n        _setBatcherHash(_batcherHash);\\n        _setGasConfigEcotone({ _basefeeScalar: _basefeeScalar, _blobbasefeeScalar: _blobbasefeeScalar });\\n        _setGasLimit(_gasLimit);\\n\\n        Storage.setAddress(UNSAFE_BLOCK_SIGNER_SLOT, _unsafeBlockSigner);\\n        Storage.setAddress(BATCH_INBOX_SLOT, _batchInbox);\\n        Storage.setAddress(L1_CROSS_DOMAIN_MESSENGER_SLOT, _addresses.l1CrossDomainMessenger);\\n        Storage.setAddress(L1_ERC_721_BRIDGE_SLOT, _addresses.l1ERC721Bridge);\\n        Storage.setAddress(L1_STANDARD_BRIDGE_SLOT, _addresses.l1StandardBridge);\\n        Storage.setAddress(DISPUTE_GAME_FACTORY_SLOT, _addresses.disputeGameFactory);\\n        Storage.setAddress(OPTIMISM_PORTAL_SLOT, _addresses.optimismPortal);\\n        Storage.setAddress(OPTIMISM_MINTABLE_ERC20_FACTORY_SLOT, _addresses.optimismMintableERC20Factory);\\n\\n        _setStartBlock();\\n\\n        _setResourceConfig(_config);\\n    }\\n\\n    /// @notice Returns the minimum L2 gas limit that can be safely set for the system to\\n    ///         operate. The L2 gas limit must be larger than or equal to the amount of\\n    ///         gas that is allocated for deposits per block plus the amount of gas that\\n    ///         is allocated for the system transaction.\\n    ///         This function is used to determine if changes to parameters are safe.\\n    /// @return uint64 Minimum gas limit.\\n    function minimumGasLimit() public view returns (uint64) {\\n        return uint64(_resourceConfig.maxResourceLimit) + uint64(_resourceConfig.systemTxMaxGas);\\n    }\\n\\n    /// @notice Returns the maximum L2 gas limit that can be safely set for the system to\\n    ///         operate. This bound is used to prevent the gas limit from being set too high\\n    ///         and causing the system to be unable to process and/or prove L2 blocks.\\n    /// @return uint64 Maximum gas limit.\\n    function maximumGasLimit() public pure returns (uint64) {\\n        return MAX_GAS_LIMIT;\\n    }\\n\\n    /// @notice High level getter for the unsafe block signer address.\\n    ///         Unsafe blocks can be propagated across the p2p network if they are signed by the\\n    ///         key corresponding to this address.\\n    /// @return addr_ Address of the unsafe block signer.\\n    function unsafeBlockSigner() public view returns (address addr_) {\\n        addr_ = Storage.getAddress(UNSAFE_BLOCK_SIGNER_SLOT);\\n    }\\n\\n    /// @notice Getter for the L1CrossDomainMessenger address.\\n    function l1CrossDomainMessenger() public view returns (address addr_) {\\n        addr_ = Storage.getAddress(L1_CROSS_DOMAIN_MESSENGER_SLOT);\\n    }\\n\\n    /// @notice Getter for the L1ERC721Bridge address.\\n    function l1ERC721Bridge() public view returns (address addr_) {\\n        addr_ = Storage.getAddress(L1_ERC_721_BRIDGE_SLOT);\\n    }\\n\\n    /// @notice Getter for the L1StandardBridge address.\\n    function l1StandardBridge() public view returns (address addr_) {\\n        addr_ = Storage.getAddress(L1_STANDARD_BRIDGE_SLOT);\\n    }\\n\\n    /// @notice Getter for the DisputeGameFactory address.\\n    function disputeGameFactory() public view returns (address addr_) {\\n        addr_ = Storage.getAddress(DISPUTE_GAME_FACTORY_SLOT);\\n    }\\n\\n    /// @notice Getter for the OptimismPortal address.\\n    function optimismPortal() public view returns (address addr_) {\\n        addr_ = Storage.getAddress(OPTIMISM_PORTAL_SLOT);\\n    }\\n\\n    /// @notice Getter for the OptimismMintableERC20Factory address.\\n    function optimismMintableERC20Factory() public view returns (address addr_) {\\n        addr_ = Storage.getAddress(OPTIMISM_MINTABLE_ERC20_FACTORY_SLOT);\\n    }\\n\\n    /// @notice Consolidated getter for the Addresses struct.\\n    function getAddresses() external view returns (Addresses memory) {\\n        return Addresses({\\n            l1CrossDomainMessenger: l1CrossDomainMessenger(),\\n            l1ERC721Bridge: l1ERC721Bridge(),\\n            l1StandardBridge: l1StandardBridge(),\\n            disputeGameFactory: disputeGameFactory(),\\n            optimismPortal: optimismPortal(),\\n            optimismMintableERC20Factory: optimismMintableERC20Factory()\\n        });\\n    }\\n\\n    /// @notice Getter for the BatchInbox address.\\n    function batchInbox() external view returns (address addr_) {\\n        addr_ = Storage.getAddress(BATCH_INBOX_SLOT);\\n    }\\n\\n    /// @notice Getter for the StartBlock number.\\n    function startBlock() external view returns (uint256 startBlock_) {\\n        startBlock_ = Storage.getUint(START_BLOCK_SLOT);\\n    }\\n\\n    /// @notice Updates the unsafe block signer address. Can only be called by the owner.\\n    /// @param _unsafeBlockSigner New unsafe block signer address.\\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external onlyOwner {\\n        _setUnsafeBlockSigner(_unsafeBlockSigner);\\n    }\\n\\n    /// @notice Updates the unsafe block signer address.\\n    /// @param _unsafeBlockSigner New unsafe block signer address.\\n    function _setUnsafeBlockSigner(address _unsafeBlockSigner) internal {\\n        Storage.setAddress(UNSAFE_BLOCK_SIGNER_SLOT, _unsafeBlockSigner);\\n\\n        bytes memory data = abi.encode(_unsafeBlockSigner);\\n        emit ConfigUpdate(VERSION, UpdateType.UNSAFE_BLOCK_SIGNER, data);\\n    }\\n\\n    /// @notice Updates the batcher hash. Can only be called by the owner.\\n    /// @param _batcherHash New batcher hash.\\n    function setBatcherHash(bytes32 _batcherHash) external onlyOwner {\\n        _setBatcherHash(_batcherHash);\\n    }\\n\\n    /// @notice Internal function for updating the batcher hash.\\n    /// @param _batcherHash New batcher hash.\\n    function _setBatcherHash(bytes32 _batcherHash) internal {\\n        batcherHash = _batcherHash;\\n\\n        bytes memory data = abi.encode(_batcherHash);\\n        emit ConfigUpdate(VERSION, UpdateType.BATCHER, data);\\n    }\\n\\n    /// @notice Updates gas config. Can only be called by the owner.\\n    ///         Deprecated in favor of setGasConfigEcotone since the Ecotone upgrade.\\n    /// @param _overhead New overhead value.\\n    /// @param _scalar   New scalar value.\\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external onlyOwner {\\n        _setGasConfig(_overhead, _scalar);\\n    }\\n\\n    /// @notice Internal function for updating the gas config.\\n    /// @param _overhead New overhead value.\\n    /// @param _scalar   New scalar value.\\n    function _setGasConfig(uint256 _overhead, uint256 _scalar) internal {\\n        require((uint256(0xff) << 248) & _scalar == 0, \\\"SystemConfig: scalar exceeds max.\\\");\\n\\n        overhead = _overhead;\\n        scalar = _scalar;\\n\\n        bytes memory data = abi.encode(_overhead, _scalar);\\n        emit ConfigUpdate(VERSION, UpdateType.FEE_SCALARS, data);\\n    }\\n\\n    /// @notice Updates gas config as of the Ecotone upgrade. Can only be called by the owner.\\n    /// @param _basefeeScalar     New basefeeScalar value.\\n    /// @param _blobbasefeeScalar New blobbasefeeScalar value.\\n    function setGasConfigEcotone(uint32 _basefeeScalar, uint32 _blobbasefeeScalar) external onlyOwner {\\n        _setGasConfigEcotone(_basefeeScalar, _blobbasefeeScalar);\\n    }\\n\\n    /// @notice Internal function for updating the fee scalars as of the Ecotone upgrade.\\n    /// @param _basefeeScalar     New basefeeScalar value.\\n    /// @param _blobbasefeeScalar New blobbasefeeScalar value.\\n    function _setGasConfigEcotone(uint32 _basefeeScalar, uint32 _blobbasefeeScalar) internal {\\n        basefeeScalar = _basefeeScalar;\\n        blobbasefeeScalar = _blobbasefeeScalar;\\n\\n        scalar = (uint256(0x01) << 248) | (uint256(_blobbasefeeScalar) << 32) | _basefeeScalar;\\n\\n        bytes memory data = abi.encode(overhead, scalar);\\n        emit ConfigUpdate(VERSION, UpdateType.FEE_SCALARS, data);\\n    }\\n\\n    /// @notice Updates the L2 gas limit. Can only be called by the owner.\\n    /// @param _gasLimit New gas limit.\\n    function setGasLimit(uint64 _gasLimit) external onlyOwner {\\n        _setGasLimit(_gasLimit);\\n    }\\n\\n    /// @notice Internal function for updating the L2 gas limit.\\n    /// @param _gasLimit New gas limit.\\n    function _setGasLimit(uint64 _gasLimit) internal {\\n        require(_gasLimit >= minimumGasLimit(), \\\"SystemConfig: gas limit too low\\\");\\n        require(_gasLimit <= maximumGasLimit(), \\\"SystemConfig: gas limit too high\\\");\\n        gasLimit = _gasLimit;\\n\\n        bytes memory data = abi.encode(_gasLimit);\\n        emit ConfigUpdate(VERSION, UpdateType.GAS_LIMIT, data);\\n    }\\n\\n    /// @notice Updates the EIP-1559 parameters of the chain. Can only be called by the owner.\\n    /// @param _denominator EIP-1559 base fee max change denominator.\\n    /// @param _elasticity  EIP-1559 elasticity multiplier.\\n    function setEIP1559Params(uint32 _denominator, uint32 _elasticity) external onlyOwner {\\n        _setEIP1559Params(_denominator, _elasticity);\\n    }\\n\\n    /// @notice Internal function for updating the EIP-1559 parameters.\\n    function _setEIP1559Params(uint32 _denominator, uint32 _elasticity) internal {\\n        // require the parameters have sane values:\\n        require(_denominator >= 1, \\\"SystemConfig: denominator must be >= 1\\\");\\n        require(_elasticity >= 1, \\\"SystemConfig: elasticity must be >= 1\\\");\\n        eip1559Denominator = _denominator;\\n        eip1559Elasticity = _elasticity;\\n\\n        bytes memory data = abi.encode(uint256(_denominator) << 32 | uint64(_elasticity));\\n        emit ConfigUpdate(VERSION, UpdateType.EIP_1559_PARAMS, data);\\n    }\\n\\n    /// @notice Updates the operator fee parameters. Can only be called by the owner.\\n    /// @param _operatorFeeScalar operator fee scalar.\\n    /// @param _operatorFeeConstant  operator fee constant.\\n    function setOperatorFeeScalars(uint32 _operatorFeeScalar, uint64 _operatorFeeConstant) external onlyOwner {\\n        _setOperatorFeeScalars(_operatorFeeScalar, _operatorFeeConstant);\\n    }\\n\\n    /// @notice Internal function for updating the operator fee parameters.\\n    function _setOperatorFeeScalars(uint32 _operatorFeeScalar, uint64 _operatorFeeConstant) internal {\\n        operatorFeeScalar = _operatorFeeScalar;\\n        operatorFeeConstant = _operatorFeeConstant;\\n\\n        bytes memory data = abi.encode(uint256(_operatorFeeScalar) << 64 | _operatorFeeConstant);\\n        emit ConfigUpdate(VERSION, UpdateType.OPERATOR_FEE_PARAMS, data);\\n    }\\n\\n    /// @notice Sets the start block in a backwards compatible way. Proxies\\n    ///         that were initialized before the startBlock existed in storage\\n    ///         can have their start block set by a user provided override.\\n    ///         A start block of 0 indicates that there is no override and the\\n    ///         start block will be set by `block.number`.\\n    /// @dev    This logic is used to patch legacy deployments with new storage values.\\n    ///         Use the override if it is provided as a non zero value and the value\\n    ///         has not already been set in storage. Use `block.number` if the value\\n    ///         has already been set in storage\\n    function _setStartBlock() internal {\\n        if (Storage.getUint(START_BLOCK_SLOT) == 0) {\\n            Storage.setUint(START_BLOCK_SLOT, block.number);\\n        }\\n    }\\n\\n    /// @notice A getter for the resource config.\\n    ///         Ensures that the struct is returned instead of a tuple.\\n    /// @return ResourceConfig\\n    function resourceConfig() external view returns (IResourceMetering.ResourceConfig memory) {\\n        return _resourceConfig;\\n    }\\n\\n    /// @notice An internal setter for the resource config.\\n    ///         Ensures that the config is sane before storing it by checking for invariants.\\n    ///         In the future, this method may emit an event that the `op-node` picks up\\n    ///         for when the resource config is changed.\\n    /// @param _config The new resource config.\\n    function _setResourceConfig(IResourceMetering.ResourceConfig memory _config) internal {\\n        // Min base fee must be less than or equal to max base fee.\\n        require(\\n            _config.minimumBaseFee <= _config.maximumBaseFee, \\\"SystemConfig: min base fee must be less than max base\\\"\\n        );\\n        // Base fee change denominator must be greater than 1.\\n        require(_config.baseFeeMaxChangeDenominator > 1, \\\"SystemConfig: denominator must be larger than 1\\\");\\n        // Max resource limit plus system tx gas must be less than or equal to the L2 gas limit.\\n        // The gas limit must be increased before these values can be increased.\\n        require(_config.maxResourceLimit + _config.systemTxMaxGas <= gasLimit, \\\"SystemConfig: gas limit too low\\\");\\n        // Elasticity multiplier must be greater than 0.\\n        require(_config.elasticityMultiplier > 0, \\\"SystemConfig: elasticity multiplier cannot be 0\\\");\\n        // No precision loss when computing target resource limit.\\n        require(\\n            ((_config.maxResourceLimit / _config.elasticityMultiplier) * _config.elasticityMultiplier)\\n                == _config.maxResourceLimit,\\n            \\\"SystemConfig: precision loss with target resource limit\\\"\\n        );\\n\\n        _resourceConfig = _config;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/optimism/packages/contracts-bedrock/src/libraries/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Storage\\n/// @notice Storage handles reading and writing to arbitary storage locations\\nlibrary Storage {\\n    /// @notice Returns an address stored in an arbitrary storage slot.\\n    ///         These storage slots decouple the storage layout from\\n    ///         solc's automation.\\n    /// @param _slot The storage slot to retrieve the address from.\\n    function getAddress(bytes32 _slot) internal view returns (address addr_) {\\n        assembly {\\n            addr_ := sload(_slot)\\n        }\\n    }\\n\\n    /// @notice Stores an address in an arbitrary storage slot, `_slot`.\\n    /// @param _slot The storage slot to store the address in.\\n    /// @param _address The protocol version to store\\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting addresses\\n    ///      in arbitrary storage slots.\\n    function setAddress(bytes32 _slot, address _address) internal {\\n        assembly {\\n            sstore(_slot, _address)\\n        }\\n    }\\n\\n    /// @notice Returns a uint256 stored in an arbitrary storage slot.\\n    ///         These storage slots decouple the storage layout from\\n    ///         solc's automation.\\n    /// @param _slot The storage slot to retrieve the address from.\\n    function getUint(bytes32 _slot) internal view returns (uint256 value_) {\\n        assembly {\\n            value_ := sload(_slot)\\n        }\\n    }\\n\\n    /// @notice Stores a value in an arbitrary storage slot, `_slot`.\\n    /// @param _slot The storage slot to store the address in.\\n    /// @param _value The protocol version to store\\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\\n    ///      in arbitrary storage slots.\\n    function setUint(bytes32 _slot, uint256 _value) internal {\\n        assembly {\\n            sstore(_slot, _value)\\n        }\\n    }\\n\\n    /// @notice Returns a bytes32 stored in an arbitrary storage slot.\\n    ///         These storage slots decouple the storage layout from\\n    ///         solc's automation.\\n    /// @param _slot The storage slot to retrieve the address from.\\n    function getBytes32(bytes32 _slot) internal view returns (bytes32 value_) {\\n        assembly {\\n            value_ := sload(_slot)\\n        }\\n    }\\n\\n    /// @notice Stores a bytes32 value in an arbitrary storage slot, `_slot`.\\n    /// @param _slot The storage slot to store the address in.\\n    /// @param _value The bytes32 value to store.\\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\\n    ///      in arbitrary storage slots.\\n    function setBytes32(bytes32 _slot, bytes32 _value) internal {\\n        assembly {\\n            sstore(_slot, _value)\\n        }\\n    }\\n\\n    /// @notice Stores a bool value in an arbitrary storage slot, `_slot`.\\n    /// @param _slot The storage slot to store the bool in.\\n    /// @param _value The bool value to store\\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\\n    ///      in arbitrary storage slots.\\n    function setBool(bytes32 _slot, bool _value) internal {\\n        assembly {\\n            sstore(_slot, _value)\\n        }\\n    }\\n\\n    /// @notice Returns a bool stored in an arbitrary storage slot.\\n    /// @param _slot The storage slot to retrieve the bool from.\\n    function getBool(bytes32 _slot) internal view returns (bool value_) {\\n        assembly {\\n            value_ := sload(_slot)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/optimism/packages/contracts-bedrock/interfaces/universal/ISemver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ISemver\\n/// @notice ISemver is a simple contract for ensuring that contracts are\\n///         versioned using semantic versioning.\\ninterface ISemver {\\n    /// @notice Getter for the semantic version of the contract. This is not\\n    ///         meant to be used onchain but instead meant to be used by offchain\\n    ///         tooling.\\n    /// @return Semver contract version as a string.\\n    function version() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/optimism/packages/contracts-bedrock/interfaces/L1/IResourceMetering.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IResourceMetering {\\n    struct ResourceParams {\\n        uint128 prevBaseFee;\\n        uint64 prevBoughtGas;\\n        uint64 prevBlockNum;\\n    }\\n\\n    struct ResourceConfig {\\n        uint32 maxResourceLimit;\\n        uint8 elasticityMultiplier;\\n        uint8 baseFeeMaxChangeDenominator;\\n        uint32 minimumBaseFee;\\n        uint32 systemTxMaxGas;\\n        uint128 maximumBaseFee;\\n    }\\n\\n    error OutOfGas();\\n\\n    event Initialized(uint8 version);\\n\\n    function params() external view returns (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum); // nosemgrep\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@eth-optimism-bedrock/=lib/optimism/packages/contracts-bedrock/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"@base-contracts/=lib/base-contracts/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"@lib-keccak/=lib/lib-keccak/contracts/lib/\",\r\n      \"src/libraries/=lib/optimism/packages/contracts-bedrock/src/libraries/\",\r\n      \"interfaces/universal/=lib/optimism/packages/contracts-bedrock/interfaces/universal/\",\r\n      \"interfaces/L1/=lib/optimism/packages/contracts-bedrock/interfaces/L1/\",\r\n      \"@solady-test/=lib/lib-keccak/lib/solady/test/\",\r\n      \"@solady/=lib/lib-keccak/lib/solady/src/\",\r\n      \"base-contracts/=lib/base-contracts/src/\",\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"ds-test/=lib/clones-with-immutable-args/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\r\n      \"lib-keccak/=lib/lib-keccak/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"optimism/=lib/optimism/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum SystemConfig.UpdateType\",\"name\":\"updateType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ConfigUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BATCH_INBOX_SLOT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DISPUTE_GAME_FACTORY_SLOT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L1_CROSS_DOMAIN_MESSENGER_SLOT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L1_ERC_721_BRIDGE_SLOT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L1_STANDARD_BRIDGE_SLOT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPTIMISM_MINTABLE_ERC20_FACTORY_SLOT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPTIMISM_PORTAL_SLOT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"START_BLOCK_SLOT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNSAFE_BLOCK_SIGNER_SLOT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basefeeScalar\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchInbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batcherHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blobbasefeeScalar\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputeGameFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip1559Denominator\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip1559Elasticity\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasLimit\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddresses\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"l1CrossDomainMessenger\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1ERC721Bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1StandardBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"disputeGameFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"optimismPortal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"optimismMintableERC20Factory\",\"type\":\"address\"}],\"internalType\":\"struct SystemConfig.Addresses\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_basefeeScalar\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_blobbasefeeScalar\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_batcherHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_gasLimit\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_unsafeBlockSigner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"maxResourceLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"elasticityMultiplier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"baseFeeMaxChangeDenominator\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"minimumBaseFee\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"systemTxMaxGas\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"maximumBaseFee\",\"type\":\"uint128\"}],\"internalType\":\"struct IResourceMetering.ResourceConfig\",\"name\":\"_config\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_batchInbox\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"l1CrossDomainMessenger\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1ERC721Bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1StandardBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"disputeGameFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"optimismPortal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"optimismMintableERC20Factory\",\"type\":\"address\"}],\"internalType\":\"struct SystemConfig.Addresses\",\"name\":\"_addresses\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l1CrossDomainMessenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l1ERC721Bridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l1StandardBridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumGasLimit\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumGasLimit\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorFeeConstant\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorFeeScalar\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimismMintableERC20Factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimismPortal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overhead\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resourceConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"maxResourceLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"elasticityMultiplier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"baseFeeMaxChangeDenominator\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"minimumBaseFee\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"systemTxMaxGas\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"maximumBaseFee\",\"type\":\"uint128\"}],\"internalType\":\"struct IResourceMetering.ResourceConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scalar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_batcherHash\",\"type\":\"bytes32\"}],\"name\":\"setBatcherHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_denominator\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_elasticity\",\"type\":\"uint32\"}],\"name\":\"setEIP1559Params\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_overhead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_scalar\",\"type\":\"uint256\"}],\"name\":\"setGasConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_basefeeScalar\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_blobbasefeeScalar\",\"type\":\"uint32\"}],\"name\":\"setGasConfigEcotone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_gasLimit\",\"type\":\"uint64\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_operatorFeeScalar\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"_operatorFeeConstant\",\"type\":\"uint64\"}],\"name\":\"setOperatorFeeScalars\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_unsafeBlockSigner\",\"type\":\"address\"}],\"name\":\"setUnsafeBlockSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startBlock_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unsafeBlockSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
      "contract_name": "SystemConfig",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "optimization_used": "1",
      "runs": "999999",
      "constructor_arguments": "",
      "evm_version": "london",
      "library": "",
      "license_type": "",
      "proxy": "0",
      "implementation": "",
      "bytecode": null
    },
    "0x866e82a600a1414e583f7f13623f1ac5d58b0afa": {
      "address": "0x866e82a600a1414e583f7f13623f1ac5d58b0afa",
      "has_source_code": true,
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/optimism/packages/contracts-bedrock/contracts/legacy/ResolvedDelegateProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { AddressManager } from \\\"./AddressManager.sol\\\";\\n\\n/**\\n * @custom:legacy\\n * @title ResolvedDelegateProxy\\n * @notice ResolvedDelegateProxy is a legacy proxy contract that makes use of the AddressManager to\\n *         resolve the implementation address. We're maintaining this contract for backwards\\n *         compatibility so we can manage all legacy proxies where necessary.\\n */\\ncontract ResolvedDelegateProxy {\\n    /**\\n     * @notice Mapping used to store the implementation name that corresponds to this contract. A\\n     *         mapping was originally used as a way to bypass the same issue normally solved by\\n     *         storing the implementation address in a specific storage slot that does not conflict\\n     *         with any other storage slot. Generally NOT a safe solution but works as long as the\\n     *         implementation does not also keep a mapping in the first storage slot.\\n     */\\n    mapping(address => string) private implementationName;\\n\\n    /**\\n     * @notice Mapping used to store the address of the AddressManager contract where the\\n     *         implementation address will be resolved from. Same concept here as with the above\\n     *         mapping. Also generally unsafe but fine if the implementation doesn't keep a mapping\\n     *         in the second storage slot.\\n     */\\n    mapping(address => AddressManager) private addressManager;\\n\\n    /**\\n     * @param _addressManager  Address of the AddressManager.\\n     * @param _implementationName implementationName of the contract to proxy to.\\n     */\\n    constructor(AddressManager _addressManager, string memory _implementationName) {\\n        addressManager[address(this)] = _addressManager;\\n        implementationName[address(this)] = _implementationName;\\n    }\\n\\n    /**\\n     * @notice Fallback, performs a delegatecall to the resolved implementation address.\\n     */\\n    // solhint-disable-next-line no-complex-fallback\\n    fallback() external payable {\\n        address target = addressManager[address(this)].getAddress(\\n            (implementationName[address(this)])\\n        );\\n\\n        require(target != address(0), \\\"ResolvedDelegateProxy: target address must be initialized\\\");\\n\\n        // slither-disable-next-line controlled-delegatecall\\n        (bool success, bytes memory returndata) = target.delegatecall(msg.data);\\n\\n        if (success == true) {\\n            assembly {\\n                return(add(returndata, 0x20), mload(returndata))\\n            }\\n        } else {\\n            assembly {\\n                revert(add(returndata, 0x20), mload(returndata))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/optimism/packages/contracts-bedrock/contracts/legacy/AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @custom:legacy\\n * @title AddressManager\\n * @notice AddressManager is a legacy contract that was used in the old version of the Optimism\\n *         system to manage a registry of string names to addresses. We now use a more standard\\n *         proxy system instead, but this contract is still necessary for backwards compatibility\\n *         with several older contracts.\\n */\\ncontract AddressManager is Ownable {\\n    /**\\n     * @notice Mapping of the hashes of string names to addresses.\\n     */\\n    mapping(bytes32 => address) private addresses;\\n\\n    /**\\n     * @notice Emitted when an address is modified in the registry.\\n     *\\n     * @param name       String name being set in the registry.\\n     * @param newAddress Address set for the given name.\\n     * @param oldAddress Address that was previously set for the given name.\\n     */\\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\\n\\n    /**\\n     * @notice Changes the address associated with a particular name.\\n     *\\n     * @param _name    String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * @notice Retrieves the address associated with a given name.\\n     *\\n     * @param _name Name to retrieve an address for.\\n     *\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**\\n     * @notice Computes the hash of a name.\\n     *\\n     * @param _name Name to compute a hash for.\\n     *\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@base-contracts/=lib/base-contracts/\",\r\n      \"@eth-optimism-bedrock/=lib/optimism/packages/contracts-bedrock/\",\r\n      \"@gnosissafe/contracts/=lib/safe-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"base-contracts/=lib/base-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"optimism/=lib/optimism/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[{\"internalType\":\"contract AddressManager\",\"name\":\"_addressManager\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_implementationName\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]",
      "contract_name": "ResolvedDelegateProxy",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "optimization_used": "1",
      "runs": "999999",
      "constructor_arguments": "0000000000000000000000008efb6b5c4767b09dc9aa6af4eaa89f749522bae20000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001a4f564d5f4c3143726f7373446f6d61696e4d657373656e676572000000000000",
      "evm_version": "Default",
      "library": "",
      "license_type": "",
      "proxy": "1",
      "implementation": "0x5d5a095665886119693f0b41d8dfee78da033e8b",
      "bytecode": null
    },
    "0x8efb6b5c4767b09dc9aa6af4eaa89f749522bae2": {
      "address": "0x8efb6b5c4767b09dc9aa6af4eaa89f749522bae2",
      "has_source_code": true,
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/optimism/packages/contracts-bedrock/contracts/legacy/AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @custom:legacy\\n * @title AddressManager\\n * @notice AddressManager is a legacy contract that was used in the old version of the Optimism\\n *         system to manage a registry of string names to addresses. We now use a more standard\\n *         proxy system instead, but this contract is still necessary for backwards compatibility\\n *         with several older contracts.\\n */\\ncontract AddressManager is Ownable {\\n    /**\\n     * @notice Mapping of the hashes of string names to addresses.\\n     */\\n    mapping(bytes32 => address) private addresses;\\n\\n    /**\\n     * @notice Emitted when an address is modified in the registry.\\n     *\\n     * @param name       String name being set in the registry.\\n     * @param newAddress Address set for the given name.\\n     * @param oldAddress Address that was previously set for the given name.\\n     */\\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\\n\\n    /**\\n     * @notice Changes the address associated with a particular name.\\n     *\\n     * @param _name    String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * @notice Retrieves the address associated with a given name.\\n     *\\n     * @param _name Name to retrieve an address for.\\n     *\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**\\n     * @notice Computes the hash of a name.\\n     *\\n     * @param _name Name to compute a hash for.\\n     *\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@base-contracts/=lib/base-contracts/\",\r\n      \"@eth-optimism-bedrock/=lib/optimism/packages/contracts-bedrock/\",\r\n      \"@gnosissafe/contracts/=lib/safe-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"base-contracts/=lib/base-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"optimism/=lib/optimism/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"AddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
      "contract_name": "AddressManager",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "optimization_used": "1",
      "runs": "999999",
      "constructor_arguments": "",
      "evm_version": "Default",
      "library": "",
      "license_type": "",
      "proxy": "0",
      "implementation": "",
      "bytecode": null
    },
    "0x73a79fab69143498ed3712e519a88a918e1f4072": {
      "address": "0x73a79fab69143498ed3712e519a88a918e1f4072",
      "has_source_code": true,
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/optimism/packages/contracts-bedrock/contracts/universal/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Proxy\\n * @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\\n *         if the caller is address(0), meaning that the call originated from an off-chain\\n *         simulation.\\n */\\ncontract Proxy {\\n    /**\\n     * @notice The storage slot that holds the address of the implementation.\\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n     */\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @notice The storage slot that holds the address of the owner.\\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n     */\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @notice An event that is emitted each time the implementation is changed. This event is part\\n     *         of the EIP-1967 specification.\\n     *\\n     * @param implementation The address of the implementation contract\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\\n     *         EIP-1967 specification.\\n     *\\n     * @param previousAdmin The previous owner of the contract\\n     * @param newAdmin      The new owner of the contract\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\\n     *         eth_call to interact with this proxy without needing to use low-level storage\\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\\n     *         normal EVM execution.\\n     */\\n    modifier proxyCallIfNotAdmin() {\\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\\n     *         implementation is not possible.\\n     *\\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\\n     *               transparent proxy interface.\\n     */\\n    constructor(address _admin) {\\n        _changeAdmin(_admin);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /**\\n     * @notice Set the implementation contract address. The code at the given address will execute\\n     *         when this contract is called.\\n     *\\n     * @param _implementation Address of the implementation contract.\\n     */\\n    function upgradeTo(address _implementation) public virtual proxyCallIfNotAdmin {\\n        _setImplementation(_implementation);\\n    }\\n\\n    /**\\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\\n     *         atomic execution of initialization-based upgrades.\\n     *\\n     * @param _implementation Address of the implementation contract.\\n     * @param _data           Calldata to delegatecall the new implementation with.\\n     */\\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\\n        public\\n        payable\\n        virtual\\n        proxyCallIfNotAdmin\\n        returns (bytes memory)\\n    {\\n        _setImplementation(_implementation);\\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\\n        require(success, \\\"Proxy: delegatecall to new implementation contract failed\\\");\\n        return returndata;\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\\n     *\\n     * @param _admin New owner of the proxy contract.\\n     */\\n    function changeAdmin(address _admin) public virtual proxyCallIfNotAdmin {\\n        _changeAdmin(_admin);\\n    }\\n\\n    /**\\n     * @notice Gets the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function admin() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function implementation() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**\\n     * @notice Sets the implementation address.\\n     *\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n        emit Upgraded(_implementation);\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract.\\n     *\\n     * @param _admin New owner of the proxy contract.\\n     */\\n    function _changeAdmin(address _admin) internal {\\n        address previous = _getAdmin();\\n        assembly {\\n            sstore(OWNER_KEY, _admin)\\n        }\\n        emit AdminChanged(previous, _admin);\\n    }\\n\\n    /**\\n     * @notice Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall() internal {\\n        address impl = _getImplementation();\\n        require(impl != address(0), \\\"Proxy: implementation not initialized\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        address impl;\\n        assembly {\\n            impl := sload(IMPLEMENTATION_KEY)\\n        }\\n        return impl;\\n    }\\n\\n    /**\\n     * @notice Queries the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@base-contracts/=lib/base-contracts/\",\r\n      \"@eth-optimism-bedrock/=lib/optimism/packages/contracts-bedrock/\",\r\n      \"@gnosissafe/contracts/=lib/safe-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"base-contracts/=lib/base-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"optimism/=lib/optimism/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "contract_name": "Proxy",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "optimization_used": "1",
      "runs": "999999",
      "constructor_arguments": "",
      "evm_version": "Default",
      "library": "",
      "license_type": "",
      "proxy": "1",
      "implementation": "0x78ffe9209dff6fe1c9b6f3efdf996bee60346d0e",
      "bytecode": null
    },
    "0x0475cbcaebd9ce8afa5025828d5b98dfb67e059e": {
      "address": "0x0475cbcaebd9ce8afa5025828d5b98dfb67e059e",
      "has_source_code": true,
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/optimism/packages/contracts-bedrock/contracts/universal/ProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { Proxy } from \\\"./Proxy.sol\\\";\\nimport { AddressManager } from \\\"../legacy/AddressManager.sol\\\";\\nimport { L1ChugSplashProxy } from \\\"../legacy/L1ChugSplashProxy.sol\\\";\\n\\n/**\\n * @title IStaticERC1967Proxy\\n * @notice IStaticERC1967Proxy is a static version of the ERC1967 proxy interface.\\n */\\ninterface IStaticERC1967Proxy {\\n    function implementation() external view returns (address);\\n\\n    function admin() external view returns (address);\\n}\\n\\n/**\\n * @title IStaticL1ChugSplashProxy\\n * @notice IStaticL1ChugSplashProxy is a static version of the ChugSplash proxy interface.\\n */\\ninterface IStaticL1ChugSplashProxy {\\n    function getImplementation() external view returns (address);\\n\\n    function getOwner() external view returns (address);\\n}\\n\\n/**\\n * @title ProxyAdmin\\n * @notice This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\\n *         based on the OpenZeppelin implementation. It has backwards compatibility logic to work\\n *         with the various types of proxies that have been deployed by Optimism in the past.\\n */\\ncontract ProxyAdmin is Ownable {\\n    /**\\n     * @notice The proxy types that the ProxyAdmin can manage.\\n     *\\n     * @custom:value ERC1967    Represents an ERC1967 compliant transparent proxy interface.\\n     * @custom:value CHUGSPLASH Represents the Chugsplash proxy interface (legacy).\\n     * @custom:value RESOLVED   Represents the ResolvedDelegate proxy (legacy).\\n     */\\n    enum ProxyType {\\n        ERC1967,\\n        CHUGSPLASH,\\n        RESOLVED\\n    }\\n\\n    /**\\n     * @notice A mapping of proxy types, used for backwards compatibility.\\n     */\\n    mapping(address => ProxyType) public proxyType;\\n\\n    /**\\n     * @notice A reverse mapping of addresses to names held in the AddressManager. This must be\\n     *         manually kept up to date with changes in the AddressManager for this contract\\n     *         to be able to work as an admin for the ResolvedDelegateProxy type.\\n     */\\n    mapping(address => string) public implementationName;\\n\\n    /**\\n     * @notice The address of the address manager, this is required to manage the\\n     *         ResolvedDelegateProxy type.\\n     */\\n    AddressManager public addressManager;\\n\\n    /**\\n     * @notice A legacy upgrading indicator used by the old Chugsplash Proxy.\\n     */\\n    bool internal upgrading;\\n\\n    /**\\n     * @param _owner Address of the initial owner of this contract.\\n     */\\n    constructor(address _owner) Ownable() {\\n        _transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @notice Sets the proxy type for a given address. Only required for non-standard (legacy)\\n     *         proxy types.\\n     *\\n     * @param _address Address of the proxy.\\n     * @param _type    Type of the proxy.\\n     */\\n    function setProxyType(address _address, ProxyType _type) external onlyOwner {\\n        proxyType[_address] = _type;\\n    }\\n\\n    /**\\n     * @notice Sets the implementation name for a given address. Only required for\\n     *         ResolvedDelegateProxy type proxies that have an implementation name.\\n     *\\n     * @param _address Address of the ResolvedDelegateProxy.\\n     * @param _name    Name of the implementation for the proxy.\\n     */\\n    function setImplementationName(address _address, string memory _name) external onlyOwner {\\n        implementationName[_address] = _name;\\n    }\\n\\n    /**\\n     * @notice Set the address of the AddressManager. This is required to manage legacy\\n     *         ResolvedDelegateProxy type proxy contracts.\\n     *\\n     * @param _address Address of the AddressManager.\\n     */\\n    function setAddressManager(AddressManager _address) external onlyOwner {\\n        addressManager = _address;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Set an address in the address manager. Since only the owner of the AddressManager\\n     *         can directly modify addresses and the ProxyAdmin will own the AddressManager, this\\n     *         gives the owner of the ProxyAdmin the ability to modify addresses directly.\\n     *\\n     * @param _name    Name to set within the AddressManager.\\n     * @param _address Address to attach to the given name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        addressManager.setAddress(_name, _address);\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Set the upgrading status for the Chugsplash proxy type.\\n     *\\n     * @param _upgrading Whether or not the system is upgrading.\\n     */\\n    function setUpgrading(bool _upgrading) external onlyOwner {\\n        upgrading = _upgrading;\\n    }\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Legacy function used to tell ChugSplashProxy contracts if an upgrade is happening.\\n     *\\n     * @return Whether or not there is an upgrade going on. May not actually tell you whether an\\n     *         upgrade is going on, since we don't currently plan to use this variable for anything\\n     *         other than a legacy indicator to fix a UX bug in the ChugSplash proxy.\\n     */\\n    function isUpgrading() external view returns (bool) {\\n        return upgrading;\\n    }\\n\\n    /**\\n     * @notice Returns the implementation of the given proxy address.\\n     *\\n     * @param _proxy Address of the proxy to get the implementation of.\\n     *\\n     * @return Address of the implementation of the proxy.\\n     */\\n    function getProxyImplementation(address _proxy) external view returns (address) {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            return IStaticERC1967Proxy(_proxy).implementation();\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            return IStaticL1ChugSplashProxy(_proxy).getImplementation();\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            return addressManager.getAddress(implementationName[_proxy]);\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the admin of the given proxy address.\\n     *\\n     * @param _proxy Address of the proxy to get the admin of.\\n     *\\n     * @return Address of the admin of the proxy.\\n     */\\n    function getProxyAdmin(address payable _proxy) external view returns (address) {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            return IStaticERC1967Proxy(_proxy).admin();\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            return IStaticL1ChugSplashProxy(_proxy).getOwner();\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            return addressManager.owner();\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates the admin of the given proxy address.\\n     *\\n     * @param _proxy    Address of the proxy to update.\\n     * @param _newAdmin Address of the new proxy admin.\\n     */\\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).changeAdmin(_newAdmin);\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            L1ChugSplashProxy(_proxy).setOwner(_newAdmin);\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            addressManager.transferOwnership(_newAdmin);\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes a proxy's implementation contract.\\n     *\\n     * @param _proxy          Address of the proxy to upgrade.\\n     * @param _implementation Address of the new implementation address.\\n     */\\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).upgradeTo(_implementation);\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            L1ChugSplashProxy(_proxy).setStorage(\\n                // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\\n                bytes32(uint256(uint160(_implementation)))\\n            );\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            string memory name = implementationName[_proxy];\\n            addressManager.setAddress(name, _implementation);\\n        } else {\\n            // It should not be possible to retrieve a ProxyType value which is not matched by\\n            // one of the previous conditions.\\n            assert(false);\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes a proxy's implementation contract and delegatecalls the new implementation\\n     *         with some given data. Useful for atomic upgrade-and-initialize calls.\\n     *\\n     * @param _proxy          Address of the proxy to upgrade.\\n     * @param _implementation Address of the new implementation address.\\n     * @param _data           Data to trigger the new implementation with.\\n     */\\n    function upgradeAndCall(\\n        address payable _proxy,\\n        address _implementation,\\n        bytes memory _data\\n    ) external payable onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).upgradeToAndCall{ value: msg.value }(_implementation, _data);\\n        } else {\\n            // reverts if proxy type is unknown\\n            upgrade(_proxy, _implementation);\\n            (bool success, ) = _proxy.call{ value: msg.value }(_data);\\n            require(success, \\\"ProxyAdmin: call to proxy after upgrade failed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/optimism/packages/contracts-bedrock/contracts/universal/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Proxy\\n * @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\\n *         if the caller is address(0), meaning that the call originated from an off-chain\\n *         simulation.\\n */\\ncontract Proxy {\\n    /**\\n     * @notice The storage slot that holds the address of the implementation.\\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n     */\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @notice The storage slot that holds the address of the owner.\\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n     */\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @notice An event that is emitted each time the implementation is changed. This event is part\\n     *         of the EIP-1967 specification.\\n     *\\n     * @param implementation The address of the implementation contract\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\\n     *         EIP-1967 specification.\\n     *\\n     * @param previousAdmin The previous owner of the contract\\n     * @param newAdmin      The new owner of the contract\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\\n     *         eth_call to interact with this proxy without needing to use low-level storage\\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\\n     *         normal EVM execution.\\n     */\\n    modifier proxyCallIfNotAdmin() {\\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\\n     *         implementation is not possible.\\n     *\\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\\n     *               transparent proxy interface.\\n     */\\n    constructor(address _admin) {\\n        _changeAdmin(_admin);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /**\\n     * @notice Set the implementation contract address. The code at the given address will execute\\n     *         when this contract is called.\\n     *\\n     * @param _implementation Address of the implementation contract.\\n     */\\n    function upgradeTo(address _implementation) public virtual proxyCallIfNotAdmin {\\n        _setImplementation(_implementation);\\n    }\\n\\n    /**\\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\\n     *         atomic execution of initialization-based upgrades.\\n     *\\n     * @param _implementation Address of the implementation contract.\\n     * @param _data           Calldata to delegatecall the new implementation with.\\n     */\\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\\n        public\\n        payable\\n        virtual\\n        proxyCallIfNotAdmin\\n        returns (bytes memory)\\n    {\\n        _setImplementation(_implementation);\\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\\n        require(success, \\\"Proxy: delegatecall to new implementation contract failed\\\");\\n        return returndata;\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\\n     *\\n     * @param _admin New owner of the proxy contract.\\n     */\\n    function changeAdmin(address _admin) public virtual proxyCallIfNotAdmin {\\n        _changeAdmin(_admin);\\n    }\\n\\n    /**\\n     * @notice Gets the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function admin() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function implementation() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**\\n     * @notice Sets the implementation address.\\n     *\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n        emit Upgraded(_implementation);\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract.\\n     *\\n     * @param _admin New owner of the proxy contract.\\n     */\\n    function _changeAdmin(address _admin) internal {\\n        address previous = _getAdmin();\\n        assembly {\\n            sstore(OWNER_KEY, _admin)\\n        }\\n        emit AdminChanged(previous, _admin);\\n    }\\n\\n    /**\\n     * @notice Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall() internal {\\n        address impl = _getImplementation();\\n        require(impl != address(0), \\\"Proxy: implementation not initialized\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        address impl;\\n        assembly {\\n            impl := sload(IMPLEMENTATION_KEY)\\n        }\\n        return impl;\\n    }\\n\\n    /**\\n     * @notice Queries the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/optimism/packages/contracts-bedrock/contracts/legacy/AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @custom:legacy\\n * @title AddressManager\\n * @notice AddressManager is a legacy contract that was used in the old version of the Optimism\\n *         system to manage a registry of string names to addresses. We now use a more standard\\n *         proxy system instead, but this contract is still necessary for backwards compatibility\\n *         with several older contracts.\\n */\\ncontract AddressManager is Ownable {\\n    /**\\n     * @notice Mapping of the hashes of string names to addresses.\\n     */\\n    mapping(bytes32 => address) private addresses;\\n\\n    /**\\n     * @notice Emitted when an address is modified in the registry.\\n     *\\n     * @param name       String name being set in the registry.\\n     * @param newAddress Address set for the given name.\\n     * @param oldAddress Address that was previously set for the given name.\\n     */\\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\\n\\n    /**\\n     * @notice Changes the address associated with a particular name.\\n     *\\n     * @param _name    String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * @notice Retrieves the address associated with a given name.\\n     *\\n     * @param _name Name to retrieve an address for.\\n     *\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**\\n     * @notice Computes the hash of a name.\\n     *\\n     * @param _name Name to compute a hash for.\\n     *\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/optimism/packages/contracts-bedrock/contracts/legacy/L1ChugSplashProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/**\\n * @title IL1ChugSplashDeployer\\n */\\ninterface IL1ChugSplashDeployer {\\n    function isUpgrading() external view returns (bool);\\n}\\n\\n/**\\n * @custom:legacy\\n * @title L1ChugSplashProxy\\n * @notice Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\\n *         functions `setCode` and `setStorage` for changing the code or storage of the contract.\\n *\\n *         Note for future developers: do NOT make anything in this contract 'public' unless you\\n *         know what you're doing. Anything public can potentially have a function signature that\\n *         conflicts with a signature attached to the implementation contract. Public functions\\n *         SHOULD always have the `proxyCallIfNotOwner` modifier unless there's some *really* good\\n *         reason not to have that modifier. And there almost certainly is not a good reason to not\\n *         have that modifier. Beware!\\n */\\ncontract L1ChugSplashProxy {\\n    /**\\n     * @notice \\\"Magic\\\" prefix. When prepended to some arbitrary bytecode and used to create a\\n     *         contract, the appended bytecode will be deployed as given.\\n     */\\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\\n\\n    /**\\n     * @notice bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n     */\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @notice bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n     */\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @notice Blocks a function from being called when the parent signals that the system should\\n     *         be paused via an isUpgrading function.\\n     */\\n    modifier onlyWhenNotPaused() {\\n        address owner = _getOwner();\\n\\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\\n        // it turns out that it isn't the right type of contract.\\n        (bool success, bytes memory returndata) = owner.staticcall(\\n            abi.encodeWithSelector(IL1ChugSplashDeployer.isUpgrading.selector)\\n        );\\n\\n        // If the call was unsuccessful then we assume that there's no \\\"isUpgrading\\\" method and we\\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\\n        // long. If this isn't the case then we can safely ignore the result.\\n        if (success && returndata.length == 32) {\\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\\n            // really care about the case where this value is 0 (= false).\\n            uint256 ret = abi.decode(returndata, (uint256));\\n            require(ret == 0, \\\"L1ChugSplashProxy: system is currently being upgraded\\\");\\n        }\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Makes a proxy call instead of triggering the given function when the caller is\\n     *         either the owner or the zero address. Caller can only ever be the zero address if\\n     *         this function is being called off-chain via eth_call, which is totally fine and can\\n     *         be convenient for client-side tooling. Avoids situations where the proxy and\\n     *         implementation share a sighash and the proxy function ends up being called instead\\n     *         of the implementation one.\\n     *\\n     *         Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If\\n     *         there's a way for someone to send a transaction with msg.sender == address(0) in any\\n     *         real context then we have much bigger problems. Primary reason to include this\\n     *         additional allowed sender is because the owner address can be changed dynamically\\n     *         and we do not want clients to have to keep track of the current owner in order to\\n     *         make an eth_call that doesn't trigger the proxied contract.\\n     */\\n    // slither-disable-next-line incorrect-modifier\\n    modifier proxyCallIfNotOwner() {\\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /**\\n     * @param _owner Address of the initial contract owner.\\n     */\\n    constructor(address _owner) {\\n        _setOwner(_owner);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /**\\n     * @notice Sets the code that should be running behind this proxy.\\n     *\\n     *         Note: This scheme is a bit different from the standard proxy scheme where one would\\n     *         typically deploy the code separately and then set the implementation address. We're\\n     *         doing it this way because it gives us a lot more freedom on the client side. Can\\n     *         only be triggered by the contract owner.\\n     *\\n     * @param _code New contract code to run inside this contract.\\n     */\\n    function setCode(bytes memory _code) external proxyCallIfNotOwner {\\n        // Get the code hash of the current implementation.\\n        address implementation = _getImplementation();\\n\\n        // If the code hash matches the new implementation then we return early.\\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\\n            return;\\n        }\\n\\n        // Create the deploycode by appending the magic prefix.\\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\\n\\n        // Deploy the code and set the new implementation address.\\n        address newImplementation;\\n        assembly {\\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\\n        }\\n\\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\\n        // actually fail this check. Should only happen if the contract creation from above runs\\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\\n        // should be doing this check anyway though.\\n        require(\\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\\n            \\\"L1ChugSplashProxy: code was not correctly deployed\\\"\\n        );\\n\\n        _setImplementation(newImplementation);\\n    }\\n\\n    /**\\n     * @notice Modifies some storage slot within the proxy contract. Gives us a lot of power to\\n     *         perform upgrades in a more transparent way. Only callable by the owner.\\n     *\\n     * @param _key   Storage key to modify.\\n     * @param _value New value for the storage key.\\n     */\\n    function setStorage(bytes32 _key, bytes32 _value) external proxyCallIfNotOwner {\\n        assembly {\\n            sstore(_key, _value)\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\\n     *\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function setOwner(address _owner) external proxyCallIfNotOwner {\\n        _setOwner(_owner);\\n    }\\n\\n    /**\\n     * @notice Queries the owner of the proxy contract. Can only be called by the owner OR by\\n     *         making an eth_call and setting the \\\"from\\\" address to address(0).\\n     *\\n     * @return Owner address.\\n     */\\n    function getOwner() external proxyCallIfNotOwner returns (address) {\\n        return _getOwner();\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address. Can only be called by the owner OR by making an\\n     *         eth_call and setting the \\\"from\\\" address to address(0).\\n     *\\n     * @return Implementation address.\\n     */\\n    function getImplementation() external proxyCallIfNotOwner returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**\\n     * @notice Sets the implementation address.\\n     *\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract.\\n     *\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function _setOwner(address _owner) internal {\\n        assembly {\\n            sstore(OWNER_KEY, _owner)\\n        }\\n    }\\n\\n    /**\\n     * @notice Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall() internal onlyWhenNotPaused {\\n        address implementation = _getImplementation();\\n\\n        require(implementation != address(0), \\\"L1ChugSplashProxy: implementation is not set yet\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        address implementation;\\n        assembly {\\n            implementation := sload(IMPLEMENTATION_KEY)\\n        }\\n        return implementation;\\n    }\\n\\n    /**\\n     * @notice Queries the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function _getOwner() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * @notice Gets the code hash for a given account.\\n     *\\n     * @param _account Address of the account to get a code hash for.\\n     *\\n     * @return Code hash for the account.\\n     */\\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\\n        bytes32 codeHash;\\n        assembly {\\n            codeHash := extcodehash(_account)\\n        }\\n        return codeHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@base-contracts/=lib/base-contracts/\",\r\n      \"@eth-optimism-bedrock/=lib/optimism/packages/contracts-bedrock/\",\r\n      \"@gnosissafe/contracts/=lib/safe-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"base-contracts/=lib/base-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"optimism/=lib/optimism/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addressManager\",\"outputs\":[{\"internalType\":\"contract AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeProxyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"getProxyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"implementationName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUpgrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proxyType\",\"outputs\":[{\"internalType\":\"enum ProxyAdmin.ProxyType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AddressManager\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAddressManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setImplementationName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"enum ProxyAdmin.ProxyType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"setProxyType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_upgrading\",\"type\":\"bool\"}],\"name\":\"setUpgrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"upgradeAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]",
      "contract_name": "ProxyAdmin",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "optimization_used": "1",
      "runs": "999999",
      "constructor_arguments": "0000000000000000000000006606d3c20cc94cc7aa1d430c0e83a5129976153a",
      "evm_version": "Default",
      "library": "",
      "license_type": "",
      "proxy": "0",
      "implementation": "",
      "bytecode": null
    },
    "0x3154cf16ccdb4c6d922629664174b904d80f2c35": {
      "address": "0x3154cf16ccdb4c6d922629664174b904d80f2c35",
      "has_source_code": true,
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/optimism/packages/contracts-bedrock/contracts/legacy/L1ChugSplashProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/**\\n * @title IL1ChugSplashDeployer\\n */\\ninterface IL1ChugSplashDeployer {\\n    function isUpgrading() external view returns (bool);\\n}\\n\\n/**\\n * @custom:legacy\\n * @title L1ChugSplashProxy\\n * @notice Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\\n *         functions `setCode` and `setStorage` for changing the code or storage of the contract.\\n *\\n *         Note for future developers: do NOT make anything in this contract 'public' unless you\\n *         know what you're doing. Anything public can potentially have a function signature that\\n *         conflicts with a signature attached to the implementation contract. Public functions\\n *         SHOULD always have the `proxyCallIfNotOwner` modifier unless there's some *really* good\\n *         reason not to have that modifier. And there almost certainly is not a good reason to not\\n *         have that modifier. Beware!\\n */\\ncontract L1ChugSplashProxy {\\n    /**\\n     * @notice \\\"Magic\\\" prefix. When prepended to some arbitrary bytecode and used to create a\\n     *         contract, the appended bytecode will be deployed as given.\\n     */\\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\\n\\n    /**\\n     * @notice bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n     */\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @notice bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n     */\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @notice Blocks a function from being called when the parent signals that the system should\\n     *         be paused via an isUpgrading function.\\n     */\\n    modifier onlyWhenNotPaused() {\\n        address owner = _getOwner();\\n\\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\\n        // it turns out that it isn't the right type of contract.\\n        (bool success, bytes memory returndata) = owner.staticcall(\\n            abi.encodeWithSelector(IL1ChugSplashDeployer.isUpgrading.selector)\\n        );\\n\\n        // If the call was unsuccessful then we assume that there's no \\\"isUpgrading\\\" method and we\\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\\n        // long. If this isn't the case then we can safely ignore the result.\\n        if (success && returndata.length == 32) {\\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\\n            // really care about the case where this value is 0 (= false).\\n            uint256 ret = abi.decode(returndata, (uint256));\\n            require(ret == 0, \\\"L1ChugSplashProxy: system is currently being upgraded\\\");\\n        }\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Makes a proxy call instead of triggering the given function when the caller is\\n     *         either the owner or the zero address. Caller can only ever be the zero address if\\n     *         this function is being called off-chain via eth_call, which is totally fine and can\\n     *         be convenient for client-side tooling. Avoids situations where the proxy and\\n     *         implementation share a sighash and the proxy function ends up being called instead\\n     *         of the implementation one.\\n     *\\n     *         Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If\\n     *         there's a way for someone to send a transaction with msg.sender == address(0) in any\\n     *         real context then we have much bigger problems. Primary reason to include this\\n     *         additional allowed sender is because the owner address can be changed dynamically\\n     *         and we do not want clients to have to keep track of the current owner in order to\\n     *         make an eth_call that doesn't trigger the proxied contract.\\n     */\\n    // slither-disable-next-line incorrect-modifier\\n    modifier proxyCallIfNotOwner() {\\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /**\\n     * @param _owner Address of the initial contract owner.\\n     */\\n    constructor(address _owner) {\\n        _setOwner(_owner);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /**\\n     * @notice Sets the code that should be running behind this proxy.\\n     *\\n     *         Note: This scheme is a bit different from the standard proxy scheme where one would\\n     *         typically deploy the code separately and then set the implementation address. We're\\n     *         doing it this way because it gives us a lot more freedom on the client side. Can\\n     *         only be triggered by the contract owner.\\n     *\\n     * @param _code New contract code to run inside this contract.\\n     */\\n    function setCode(bytes memory _code) external proxyCallIfNotOwner {\\n        // Get the code hash of the current implementation.\\n        address implementation = _getImplementation();\\n\\n        // If the code hash matches the new implementation then we return early.\\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\\n            return;\\n        }\\n\\n        // Create the deploycode by appending the magic prefix.\\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\\n\\n        // Deploy the code and set the new implementation address.\\n        address newImplementation;\\n        assembly {\\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\\n        }\\n\\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\\n        // actually fail this check. Should only happen if the contract creation from above runs\\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\\n        // should be doing this check anyway though.\\n        require(\\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\\n            \\\"L1ChugSplashProxy: code was not correctly deployed\\\"\\n        );\\n\\n        _setImplementation(newImplementation);\\n    }\\n\\n    /**\\n     * @notice Modifies some storage slot within the proxy contract. Gives us a lot of power to\\n     *         perform upgrades in a more transparent way. Only callable by the owner.\\n     *\\n     * @param _key   Storage key to modify.\\n     * @param _value New value for the storage key.\\n     */\\n    function setStorage(bytes32 _key, bytes32 _value) external proxyCallIfNotOwner {\\n        assembly {\\n            sstore(_key, _value)\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\\n     *\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function setOwner(address _owner) external proxyCallIfNotOwner {\\n        _setOwner(_owner);\\n    }\\n\\n    /**\\n     * @notice Queries the owner of the proxy contract. Can only be called by the owner OR by\\n     *         making an eth_call and setting the \\\"from\\\" address to address(0).\\n     *\\n     * @return Owner address.\\n     */\\n    function getOwner() external proxyCallIfNotOwner returns (address) {\\n        return _getOwner();\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address. Can only be called by the owner OR by making an\\n     *         eth_call and setting the \\\"from\\\" address to address(0).\\n     *\\n     * @return Implementation address.\\n     */\\n    function getImplementation() external proxyCallIfNotOwner returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**\\n     * @notice Sets the implementation address.\\n     *\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes the owner of the proxy contract.\\n     *\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function _setOwner(address _owner) internal {\\n        assembly {\\n            sstore(OWNER_KEY, _owner)\\n        }\\n    }\\n\\n    /**\\n     * @notice Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall() internal onlyWhenNotPaused {\\n        address implementation = _getImplementation();\\n\\n        require(implementation != address(0), \\\"L1ChugSplashProxy: implementation is not set yet\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /**\\n     * @notice Queries the implementation address.\\n     *\\n     * @return Implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        address implementation;\\n        assembly {\\n            implementation := sload(IMPLEMENTATION_KEY)\\n        }\\n        return implementation;\\n    }\\n\\n    /**\\n     * @notice Queries the owner of the proxy contract.\\n     *\\n     * @return Owner address.\\n     */\\n    function _getOwner() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * @notice Gets the code hash for a given account.\\n     *\\n     * @param _account Address of the account to get a code hash for.\\n     *\\n     * @return Code hash for the account.\\n     */\\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\\n        bytes32 codeHash;\\n        assembly {\\n            codeHash := extcodehash(_account)\\n        }\\n        return codeHash;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@base-contracts/=lib/base-contracts/\",\r\n      \"@eth-optimism-bedrock/=lib/optimism/packages/contracts-bedrock/\",\r\n      \"@gnosissafe/contracts/=lib/safe-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"base-contracts/=lib/base-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"optimism/=lib/optimism/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_code\",\"type\":\"bytes\"}],\"name\":\"setCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"setStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "contract_name": "L1ChugSplashProxy",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "optimization_used": "1",
      "runs": "999999",
      "constructor_arguments": "0000000000000000000000006606d3c20cc94cc7aa1d430c0e83a5129976153a",
      "evm_version": "Default",
      "library": "",
      "license_type": "",
      "proxy": "1",
      "implementation": "0x0b09ba359a106c9ea3b181cbc5f394570c7d2a7a",
      "bytecode": null
    }
  },
  "summary": {
    "total_calls": 10,
    "call_types": {
      "call": 3,
      "staticcall": 3,
      "delegatecall": 4
    },
    "total_value_transferred": 2352000000000000000,
    "total_value_transferred_eth": 2.352
  }
}