// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/// @title            Decompiled Contract
/// @author           Jonathan Becker <jonathan@jbecker.dev>
/// @custom:version   heimdall-rs v0.9.0
///
/// @notice           This contract was decompiled using the heimdall-rs decompiler.
///                     It was generated directly by tracing the EVM opcodes from this contract.
///                     As a result, it may not compile or even be valid solidity code.
///                     Despite this, it should be obvious what each function does. Overall
///                     logic should have been preserved throughout decompiling.
///
/// @custom:github    You can find the open-source decompiler here:
///                       https://heimdall.rs

contract DecompiledContract {
    
    /// @custom:selector    0x84800812
    /// @custom:signature   Unresolved_84800812(address arg0, uint256 arg1) public pure
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_84800812(address arg0, uint256 arg1) public pure {
        require(arg0 == (address(arg0)));
        require(arg1 == arg1);
    }
    
    /// @custom:selector    0xa1d48336
    /// @custom:signature   Unresolved_a1d48336(uint256 arg0) public pure
    /// @param              arg0 ["uint256", "bytes32", "int256"]
    function Unresolved_a1d48336(uint256 arg0) public pure {
        require(arg0 == arg0);
    }
    
    /// @custom:selector    0xbe9a6555
    /// @custom:signature   start() public payable
    function start() public payable {
        require(!0x02 > 0xffffffffffffffff);
        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
        var_b = 0x41;
        var_c = 0x02;
        uint256 var_d = var_d + 0x60;
        require(!0x02);
        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
        var_b = 0x32;
        var_e = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c;
        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
        var_b = 0x32;
        var_f = 0xc321ac21a07b3d593b269acdace69c3762ca2dd0;
        var_g = 0x70a0823100000000000000000000000000000000000000000000000000000000;
        var_h = 0x42a93c3af7cb1bbc757dd2ec4977fd6d7916ba1d;
        (bool success, bytes memory ret0) = address(0xc321ac21a07b3d593b269acdace69c3762ca2dd0).Unresolved_70a08231(var_h); // staticcall
        var_d = var_d + (uint248(ret0.length + 0x1f));
        require(!((var_d + ret0.length) - var_d) < 0x20);
        require(var_i == (var_i));
        require(0x03e8);
        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
        var_b = 0x12;
        require((!(var_i) / 0x03e8) | (0x0384 == (((var_i / 0x03e8) * 0x0384) / (var_i / 0x03e8))));
        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
        var_b = 0x11;
        var_j = 0x1f00ca7400000000000000000000000000000000000000000000000000000000;
        uint256 var_k = (var_i / 0x03e8) * 0x0384;
        uint256 var_l = ((0x04 + var_d) + 0x40) - (0x04 + var_d);
        uint256 var_m = var_d.length;
        (bool success, bytes memory ret0) = address(0x10ed43c718714eb63d5aa57b78b54704e256024e).Unresolved_1f00ca74(var_k); // staticcall
        var_d = var_d + (uint248(ret0.length + 0x1f));
        require(!((var_d + ret0.length) - var_d) < 0x20);
        require(!(var_i) > 0xffffffffffffffff);
        require(((var_d + (var_n)) + 0x1f) < (var_d + ret0.length));
        require(!(var_o) > 0xffffffffffffffff);
        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
        var_b = 0x41;
        require(!((var_d + (uint248(((var_p * 0x20) + 0x20) + 0x1f))) > 0xffffffffffffffff) | ((var_d + (uint248(((var_p * 0x20) + 0x20) + 0x1f))) < var_d));
        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
        var_b = 0x41;
        var_d = var_d + (uint248(((var_p * 0x20) + 0x20) + 0x1f));
        var_q = var_o;
        require(!(((var_d + (var_n)) + 0x20) + (var_r * 0x20)) > (var_d + ret0.length));
        require(!((var_d + (var_n)) + 0x20) < (((var_d + (var_n)) + 0x20) + (var_r * 0x20)));
        require(var_s == (var_s));
        var_t = var_u;
        uint256 var_v = (((0x20 + var_d) + 0x20) - var_d) - 0x20;
        var_d = (0x20 + var_d) + 0x20;
        var_w = 0x490e6cbc00000000000000000000000000000000000000000000000000000000;
        address var_x = address(this);
        uint256 var_y = 0;
        var_z = var_u;
        uint256 var_aa = ((0x04 + var_d) + 0x80) - (0x04 + var_d);
        uint256 var_ab = var_d.length;
        uint256 var_ac = 0;
        require(address(0x172fcd41e0913e95784454622d1c3724f546f849).code.length);
        (bool success, bytes memory ret0) = address(0x172fcd41e0913e95784454622d1c3724f546f849).Unresolved_490e6cbc(var_x); // call
        var_ad = var_ae;
        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
        var_b = 0x32;
    }
}