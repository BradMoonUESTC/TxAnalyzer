{
  "address": "0x1e619dbea18f5e0e66d1c2df3f14416d3c804809",
  "has_source_code": false,
  "source_code": "基于反编译代码的分析，这是一个节点管理和奖励分发系统。以下是优化重构后的代码：\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title NodeRewardManager\n * @notice 节点奖励管理合约 - 管理节点注册、奖励分发和时间周期\n * @dev 这是一个去中心化的节点管理系统，支持周期性奖励分发\n * \n * 主要功能：\n * - 节点注册和移除\n * - 基于时间周期的奖励分发\n * - 奖励池管理\n * - 权限控制\n * \n * 安全特性：\n * - 所有者权限控制\n * - 防重入攻击\n * - 时间锁定机制\n * - 奖励防重复领取\n */\ncontract NodeRewardManager is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ========== 状态变量 ==========\n    \n    /// @notice 奖励代币地址\n    address public rewardToken;\n    \n    /// @notice USDT代币地址\n    address public usdtToken;\n    \n    /// @notice 特殊权限地址（可能是管理员或合作伙伴）\n    address public privilegedAddress;\n    \n    /// @notice 时间周期长度（秒）\n    uint256 public timeLength;\n    \n    /// @notice 今日开始时间戳\n    uint256 public todayStartTime;\n    \n    /// @notice 节点总数\n    uint256 public totalNodes;\n    \n    /// @notice 节点地址列表\n    address[] public nodeList;\n\n    // ========== 映射存储 ==========\n    \n    /// @notice 节点信息映射：地址 => 节点状态\n    mapping(address => bool) public isNodeActive;\n    \n    /// @notice 节点注册时间映射：地址 => 注册的周期数\n    mapping(address => uint256) public nodeRegistrationPeriod;\n    \n    /// @notice 用户在特定周期的领取状态：用户地址 => 周期 => 是否已领取\n    mapping(address => mapping(uint256 => bool)) public hasClaimedInPeriod;\n    \n    /// @notice 周期奖励池信息\n    struct PeriodRewardPool {\n        uint256 totalRewards;        // 总奖励数量\n        uint256 distributedRewards;  // 已分发奖励\n        uint256 nodeRewards;         // 节点奖励\n        uint256 bonusRewards;        // 额外奖励\n        bool isFinalized;            // 是否已结算\n    }\n    \n    /// @notice 周期 => 奖励池信息\n    mapping(uint256 => PeriodRewardPool) public periodRewardPools;\n\n    // ========== 事件定义 ==========\n    \n    /// @notice 节点添加事件\n    /// @param nodeAddress 节点地址\n    /// @param period 注册周期\n    event NodeAdded(address indexed nodeAddress, uint256 indexed period);\n    \n    /// @notice 节点移除事件\n    /// @param nodeAddress 节点地址\n    event NodeRemoved(address indexed nodeAddress);\n    \n    /// @notice 奖励领取事件\n    /// @param user 用户地址\n    /// @param period 周期\n    /// @param amount 奖励数量\n    event RewardClaimed(address indexed user, uint256 indexed period, uint256 amount);\n    \n    /// @notice 奖励池更新事件\n    /// @param period 周期\n    /// @param rewardType 奖励类型 (0: 节点奖励, 1: 额外奖励)\n    /// @param amount 数量\n    event RewardPoolUpdated(uint256 indexed period, uint8 rewardType, uint256 amount);\n\n    // ========== 错误定义 ==========\n    \n    error NotOwner();\n    error NotAuthorized();\n    error InvalidAddress();\n    error InvalidTime();\n    error AlreadyNode();\n    error NotANode();\n    error AlreadyClaimed();\n    error NoValidNodes();\n    error NodeTooNew();\n    error InsufficientRewards();\n\n    // ========== 修饰器 ==========\n    \n    /// @notice 检查是否为合约所有者\n    modifier onlyOwner() override {\n        if (msg.sender != owner()) revert NotOwner();\n        _;\n    }\n    \n    /// @notice 检查是否为特权地址（奖励代币或特殊权限地址）\n    modifier onlyPrivileged() {\n        if (msg.sender != rewardToken && msg.sender != privilegedAddress) {\n            revert NotAuthorized();\n        }\n        _;\n    }\n    \n    /// @notice 检查地址有效性\n    modifier validAddress(address addr) {\n        if (addr == address(0)) revert InvalidAddress();\n        _;\n    }\n\n    // ========== 构造函数 ==========\n    \n    constructor(\n        address _rewardToken,\n        address _usdtToken,\n        uint256 _timeLength,\n        uint256 _todayStartTime\n    ) {\n        rewardToken = _rewardToken;\n        usdtToken = _usdtToken;\n        timeLength = _timeLength;\n        todayStartTime = _todayStartTime;\n    }\n\n    // ========== 管理员函数 ==========\n    \n    /**\n     * @notice 设置时间周期长度\n     * @param newTimeLength 新的时间周期长度（秒）\n     */\n    function setTimeLength(uint256 newTimeLength) external onlyOwner {\n        if (newTimeLength == 0) revert InvalidTime();\n        timeLength = newTimeLength;\n    }\n    \n    /**\n     * @notice 设置特权地址\n     * @param newPrivilegedAddress 新的特权地址\n     */\n    function setPrivilegedAddress(address newPrivilegedAddress) \n        external \n        onlyOwner \n        validAddress(newPrivilegedAddress) \n    {\n        privilegedAddress = newPrivilegedAddress;\n    }\n    \n    /**\n     * @notice 更换奖励代币地址\n     * @param newRewardToken 新的奖励代币地址\n     */\n    function changeRewardToken(address newRewardToken) \n        external \n        onlyOwner \n        validAddress(newRewardToken) \n    {\n        rewardToken = newRewardToken;\n    }\n    \n    /**\n     * @notice 设置USDT代币地址\n     * @param newUsdtToken 新的USDT代币地址\n     */\n    function setUsdtToken(address newUsdtToken) \n        external \n        onlyOwner \n        validAddress(newUsdtToken) \n    {\n        usdtToken = newUsdtToken;\n    }\n\n    // ========== 节点管理函数 ==========\n    \n    /**\n     * @notice 添加节点\n     * @param nodeAddress 节点地址\n     */\n    function addNode(address nodeAddress) \n        external \n        onlyOwner \n        validAddress(nodeAddress) \n        nonReentrant \n    {\n        if (isNodeActive[nodeAddress]) revert AlreadyNode();\n        \n        uint256 currentPeriod = getCurrentPeriod();\n        \n        // 设置节点状态\n        isNodeActive[nodeAddress] = true;\n        nodeRegistrationPeriod[nodeAddress] = currentPeriod;\n        \n        // 添加到节点列表\n        nodeList.push(nodeAddress);\n        totalNodes++;\n        \n        emit NodeAdded(nodeAddress, currentPeriod);\n    }\n    \n    /**\n     * @notice 批量添加节点\n     * @param nodeAddresses 节点地址数组\n     */\n    function addMultipleNodes(address[] calldata nodeAddresses) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        uint256 currentPeriod = getCurrentPeriod();\n        uint256 length = nodeAddresses.length;\n        \n        for (uint256 i = 0; i < length; i++) {\n            address nodeAddress = nodeAddresses[i];\n            if (nodeAddress == address(0)) continue;\n            if (isNodeActive[nodeAddress]) continue;\n            \n            // 设置节点状态\n            isNodeActive[nodeAddress] = true;\n            nodeRegistrationPeriod[nodeAddress] = currentPeriod;\n            \n            // 添加到节点列表\n            nodeList.push(nodeAddress);\n            totalNodes++;\n            \n            emit NodeAdded(nodeAddress, currentPeriod);\n        }\n    }\n    \n    /**\n     * @notice 移除节点\n     * @param nodeAddress 要移除的节点地址\n     */\n    function removeNode(address nodeAddress) \n        external \n        onlyOwner \n        validAddress(nodeAddress) \n        nonReentrant \n    {\n        if (!isNodeActive[nodeAddress]) revert NotANode();\n        \n        // 清除节点状态\n        isNodeActive[nodeAddress] = false;\n        nodeRegistrationPeriod[nodeAddress] = 0;\n        \n        // 从节点列表中移除\n        _removeFromNodeList(nodeAddress);\n        totalNodes--;\n        \n        emit NodeRemoved(nodeAddress);\n    }\n\n    // ========== 奖励相关函数 ==========\n    \n    /**\n     * @notice 用户领取奖励\n     * @dev 用户可以领取前一个周期的奖励\n     */\n    function claim() external nonReentrant {\n        address user = msg.sender;\n        \n        // 检查是否为活跃节点\n        if (!isNodeActive[user]) revert NotANode();\n        \n        uint256 currentPeriod = getCurrentPeriod();\n        if (currentPeriod == 0) revert NodeTooNew();\n        \n        uint256 claimPeriod = currentPeriod - 1;\n        \n        // 检查节点是否在该周期已经存在\n        if (nodeRegistrationPeriod[user] > claimPeriod) revert NodeTooNew();\n        \n        // 检查是否已经领取过\n        if (hasClaimedInPeriod[user][claimPeriod]) revert AlreadyClaimed();\n        \n        // 计算奖励数量\n        uint256 rewardAmount = _calculateReward(user, claimPeriod);\n        if (rewardAmount == 0) revert NoValidNodes();\n        \n        // 标记为已领取\n        hasClaimedInPeriod[user][claimPeriod] = true;\n        \n        // 更新奖励池统计\n        periodRewardPools[claimPeriod].distributedRewards += rewardAmount;\n        \n        // 转账奖励\n        IERC20(rewardToken).safeTransfer(user, rewardAmount);\n        \n        emit RewardClaimed(user, claimPeriod, rewardAmount);\n    }\n    \n    /**\n     * @notice 更新节点奖励池\n     * @param period 周期\n     * @param amount 奖励数量\n     */\n    function updateNodeRewardPool(uint256 period, uint256 amount) \n        external \n        onlyPrivileged \n    {\n        PeriodRewardPool storage pool = periodRewardPools[period];\n        \n        // 检查溢出\n        if (pool.nodeRewards + amount < pool.nodeRewards) {\n            revert InsufficientRewards();\n        }\n        \n        pool.nodeRewards += amount;\n        pool.totalRewards += amount;\n        \n        emit RewardPoolUpdated(period, 0, amount);\n    }\n    \n    /**\n     * @notice 更新额外奖励池\n     * @param period 周期\n     * @param amount 奖励数量\n     */\n    function updateBonusRewardPool(uint256 period, uint256 amount) \n        external \n        onlyPrivileged \n    {\n        PeriodRewardPool storage pool = periodRewardPools[period];\n        \n        // 检查溢出\n        if (pool.bonusRewards + amount < pool.bonusRewards) {\n            revert InsufficientRewards();\n        }\n        \n        pool.bonusRewards += amount;\n        pool.totalRewards += amount;\n        \n        emit RewardPoolUpdated(period, 1, amount);\n    }\n    \n    /**\n     * @notice 处理周期结算\n     * @dev 自动处理周期奖励分配逻辑\n     */\n    function processPeriodSettlement() external onlyPrivileged {\n        uint256 currentPeriod = getCurrentPeriod();\n        if (currentPeriod < 2) return;\n        \n        uint256 settlementPeriod = currentPeriod - 2;\n        PeriodRewardPool storage pool = periodRewardPools[settlementPeriod];\n        \n        if (pool.isFinalized) return;\n        \n        // 检查是否有足够的奖励分配\n        if (pool.nodeRewards > 0) {\n            uint256 previousPeriod = settlementPeriod + 1;\n            PeriodRewardPool storage prevPool = periodRewardPools[previousPeriod];\n            \n            // 将未分发的奖励累加到下一周期\n            if (prevPool.totalRewards + pool.nodeRewards >= prevPool.totalRewards) {\n                prevPool.totalRewards += pool.nodeRewards;\n                prevPool.nodeRewards += pool.nodeRewards;\n            }\n        }\n        \n        if (pool.bonusRewards > 0) {\n            uint256 previousPeriod = settlementPeriod + 1;\n            PeriodRewardPool storage prevPool = periodRewardPools[previousPeriod];\n            \n            // 将未分发的额外奖励累加到下一周期\n            if (prevPool.totalRewards + pool.bonusRewards >= prevPool.totalRewards) {\n                prevPool.totalRewards += pool.bonusRewards;\n                prevPool.bonusRewards += pool.bonusRewards;\n            }\n        }\n        \n        pool.isFinalized = true;\n    }\n\n    // ========== 资产管理函数 ==========\n    \n    /**\n     * @notice 提取代币\n     * @param token 代币地址\n     * @param to 接收地址\n     * @param amount 提取数量\n     */\n    function withdrawToken(\n        address token, \n        address to, \n        uint256 amount\n    ) external onlyOwner validAddress(token) validAddress(to) {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    // ========== 查询函数 ==========\n    \n    /**\n     * @notice 获取当前周期\n     * @return 当前周期数\n     */\n    function getCurrentPeriod() public view returns (uint256) {\n        if (timeLength == 0) return 0;\n        if",
  "abi": "Contract source code not verified",
  "contract_name": "Unknown",
  "compiler_version": null,
  "optimization_used": null,
  "runs": null,
  "constructor_arguments": null,
  "evm_version": null,
  "library": null,
  "license_type": null,
  "proxy": "0",
  "implementation": "",
  "bytecode": "0x608060408181526004918236101561002a575b505050361561002057600080fd5b610028610e3d565b005b600092833560e01c918263189a5a1714610bf357508163208f2a3114610bb25781632f48ab7d14610b895781634e71d92d14610b7057816353f3b71314610aab5781635f465f8f14610a6157816366829b1614610a17578163763ea379146109f85781637f315061146109735781638a8100561461094a5781638c256359146109085781638da5cb5b146108e0578382639c4380e714610818575081639d95f1cc1461071d578163a4f3fa10146106f8578163afe5b025146106dc578163b293109614610692578163b2b99ec914610519578163b79b70eb146104c1578163bd06f3f1146104a3578163bd7a303f1461047c578163c15de638146103e4578163c7c5a25e1461037f578163cbae0b8d14610335578163df9620eb146101da57508063f2fde38b146101905763f7c618c1146101655780610012565b3461018c578160031936011261018c5760035490516001600160a01b039091168152602090f35b5080fd5b82346101d75760203660031901126101d7576101aa610c38565b8154906001600160a01b03906101c33383851614610ca0565b16906001600160601b0360a01b1617815580f35b80fd5b91905034610331576020908160031936011261032d5767ffffffffffffffff91833583811161032957366023820112156103295780850135938411610329576024600591368287851b830101116103255787546001600160a01b039761025a91610247908a163314610ca0565b610252855442610cd8565b905490610cfb565b92885b878110610268578980f35b8381831b84010135908982168b8184036101d7576102aa938282526006808b52898c8c60019160ff83828920015416156102af575b5050505050505050610db1565b61025d565b6102f0966102eb958251956102c387610d1b565b8652838601938585528a835252209251835551151591019060ff801983541691151516179055565b610d87565b7fe02b43adbee0c123de070a04554a71877a0007e2fc161466299cae3c094fe82f888a51898152a2388b818089818c8e61029d565b8780fd5b8580fd5b8380fd5b8280fd5b83346101d75760203660031901126101d75761034f610c38565b81546001600160a01b0391906103689083163314610ca0565b166001600160601b0360a01b600254161760025580f35b905034610331576020366003190112610331578035916103a960018060a01b038554163314610ca0565b82156103b457505580f35b906020606492519162461bcd60e51b8352820152600a60248201526977726f6e672074696d6560b01b6044820152fd5b905034610331576020366003190112610331576020816104427f489b12952048439369acc792f77b058f9a1ed1ae20da7282ba883a21d570e7af93359161043660018060a01b03600154163314610df9565b61025260055442610cd8565b9384865260078352808620610458838254610e30565b905584865260078352600181872001610472838254610e30565b905551908152a280f35b8284346101d75760203660031901126101d7575061049c6020923561128c565b9051908152f35b90503461033157826003193601126103315760209250549051908152f35b91905034610331576020366003190112610331578060a0938335815260076020522080549260028201549260ff6001840154926003850154940154169381519586526020860152840152606083015215156080820152f35b90503461033157602036600319011261033157610534610c38565b83546001600160a01b0391829161054e9083163314610ca0565b169182855260066020528460018561056e60ff8380998620015416610dc0565b85835260066020528220828155015584845b6105ae575b85847fcfc24166db4bb677e857cacabd1541fb2b30645021b27c5130419589b84db52b8280a280f35b600880548083101561068b57908491866105c785610c53565b949054600395861b1c16146105e8575050506105e290610db1565b84610580565b929094939195965060001992838101908111610678579061061c8561060f61063b94610c53565b9054908a1b1c1691610c53565b90919082549060031b9160018060a01b03809116831b921b1916179055565b83549081156106655750019261065084610c53565b81939154921b1b191690555580388080610585565b634e487b7160e01b885260319052602487fd5b634e487b7160e01b895260118352602489fd5b5050610585565b50503461018c578060031936011261018c5760ff816020936106b2610c38565b6024358252600786528282206001600160a01b039091168252600501855220549151911615158152f35b83346101d757806003193601126101d7576106f5611192565b80f35b8284346101d757806003193601126101d7575061049c60209261025260055442610cd8565b91905034610331576020908160031936011261032d5761073b610c38565b9060018060a01b03610751818754163314610ca0565b8216938486526006845260ff60018388200154166107e657906107de6107a07fe02b43adbee0c123de070a04554a71877a0007e2fc161466299cae3c094fe82f95949361025260055442610cd8565b926102eb83516107af81610d1b565b85815260018782018181528a8c5260068952868c209251835551151591019060ff801983541691151516179055565b51908152a280f35b83606492519162461bcd60e51b8352820152600e60248201526d416c72656164792061206e6f646560901b6044820152fd5b929150346108dc5760603660031901126108dc57610834610c38565b6001600160a01b039190602435838116810361032957858461085f6020966108939954163314610ca0565b865163a9059cbb60e01b81526001600160a01b03909316948301948552604435602086015291968794859391849160400190565b0393165af19081156108d357506108a8575080f35b6108c89060203d81116108cc575b6108c08183610d4d565b810190610d6f565b5080f35b503d6108b6565b513d84823e3d90fd5b5050fd5b50503461018c578160031936011261018c57905490516001600160a01b039091168152602090f35b50503461018c57602036600319011261018c5760209160ff9060019083906001600160a01b03610936610c38565b168152600686522001541690519015158152f35b50503461018c578160031936011261018c5760015490516001600160a01b039091168152602090f35b905034610331576020366003190112610331576020816109c57f1df38bde545fd9bc19718ab9c27dbde6626eefe2ae0acffe17361272608b664393359161043660018060a01b03600354163314610df9565b93848652600783526002818720016109de838254610e30565b905584865260078352600381872001610472838254610e30565b50503461018c578160031936011261018c576020906005549051908152f35b83346101d75760203660031901126101d757610a31610c38565b81546001600160a01b039190610a4a9083163314610ca0565b166001600160601b0360a01b600354161760035580f35b83346101d75760203660031901126101d757610a7b610c38565b81546001600160a01b039190610a949083163314610ca0565b166001600160601b0360a01b600154161760015580f35b8284346101d757806003193601126101d7579080519182906008549182855260208095018093600884527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee390845b818110610b535750505081610b0f910382610d4d565b83519485948186019282875251809352850193925b828110610b3357505050500390f35b83516001600160a01b031685528695509381019392810192600101610b24565b82546001600160a01b031684529288019260019283019201610af9565b83346101d757806003193601126101d7576106f5610e3d565b50503461018c578160031936011261018c5760025490516001600160a01b039091168152602090f35b9050346103315760203660031901126103315735916008548310156101d75750610bdd602092610c53565b905491519160018060a01b039160031b1c168152f35b839085346101d75760203660031901126101d75782906001600160a01b03610c19610c38565b16815260066020522060ff600182549201541690825215156020820152f35b600435906001600160a01b0382168203610c4e57565b600080fd5b600854811015610c8a5760086000527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee30190600090565b634e487b7160e01b600052603260045260246000fd5b15610ca757565b60405162461bcd60e51b81526020600482015260096024820152682737ba1037bbb732b960b91b6044820152606490fd5b91908203918211610ce557565b634e487b7160e01b600052601160045260246000fd5b8115610d05570490565b634e487b7160e01b600052601260045260246000fd5b6040810190811067ffffffffffffffff821117610d3757604052565b634e487b7160e01b600052604160045260246000fd5b90601f8019910116810190811067ffffffffffffffff821117610d3757604052565b90816020910312610c4e57518015158103610c4e5790565b6008549068010000000000000000821015610d375761061c826001610daf9401600855610c53565b565b6000198114610ce55760010190565b15610dc757565b60405162461bcd60e51b815260206004820152600a6024820152694e6f742061206e6f646560b01b6044820152606490fd5b15610e0057565b60405162461bcd60e51b81526020600482015260086024820152671b9bdd081c985b9d60c21b6044820152606490fd5b91908201809211610ce557565b6000338152602090600682526040610e5d60ff6001838520015416610dc0565b610e6960055442610cd8565b610e77600491825490610cfb565b6000198101949080861161117f57600119810190811161117f5784526007815260ff8284862001541615611172575b33845260068152848385205411611143578484526007815282842091600583019433815285835260ff858220541661110f57610ee18761128c565b9384156110db57610f01610ef6868354610cfb565b956002830154610cfb565b338352968452858220805460ff191660011790558461101c575b86610f57575b50505082519485528401528201527f9cdcf2f7714cca3508c7f0110b04a90a80a3a8dd0e35de99689db74d28c5383e60603392a2565b600301610f65878254610cd8565b9055600354855163a9059cbb60e01b815233848201908152602081018990529091859183916001600160a01b03169082908690829060400103925af19182156110115791610ff4575b5015610fbb578080610f21565b60649184519162461bcd60e51b83528201526015602482015274151bdad95b881d1c985b9cd9995c8819985a5b1959605a1b6044820152fd5b61100b9150833d85116108cc576108c08183610d4d565b38610fae565b8651903d90823e3d90fd5b6001810161102b868254610cd8565b9055600254865163a9059cbb60e01b815233858201908152602081018890529091869183916001600160a01b03169082908790829060400103925af19081156110d15783916110b4575b50610f1b57855162461bcd60e51b815280840185905260146024820152731554d115081d1c985b9cd9995c8819985a5b195960621b6044820152606490fd5b6110cb9150853d87116108cc576108c08183610d4d565b38611075565b87513d85823e3d90fd5b855162461bcd60e51b8152808401859052600e60248201526d4e6f2076616c6964206e6f64657360901b6044820152606490fd5b5060649184519162461bcd60e51b8352820152600f60248201526e105b1c9958591e4818db185a5b5959608a1b6044820152fd5b606492519162461bcd60e51b8352820152600c60248201526b4e6f646520746f6f206e657760a01b6044820152fd5b61117a611192565b610ea6565b634e487b7160e01b855260118352602485fd5b6111aa6111a160055442610cd8565b60045490610cfb565b600019810190808211610ce5576001190190808211610ce557600091825260076020526040822091600483019260ff845416611286578060016003920180548061124e575b50500180548061120b575b50505050600160ff19825416179055565b82600392604092866112439652600760205261122e600285852001918254610e30565b90555494815260076020522001918254610e30565b9055388080806111fa565b85855261126060408620918254610e30565b905554848452600760205261127d60016040862001918254610e30565b905538806111ef565b50505050565b600854600092918390815b8381106112a45750505050565b816112ae82610c53565b9054600391821b1c6001600160a01b0390811686526006602081815260408089206001015460ff1695949093908661130f575b5050505050506112fa575b6112f590610db1565b611297565b946113076112f591610db1565b9590506112ec565b9091929394955061131f87610c53565b9054911b1c1687525284205411158238808080806112e156fea164736f6c6343000814000a",
  "decompiled": true,
  "raw_sol_code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title            Decompiled Contract\n/// @author           Jonathan Becker <jonathan@jbecker.dev>\n/// @custom:version   heimdall-rs v0.9.0\n///\n/// @notice           This contract was decompiled using the heimdall-rs decompiler.\n///                     It was generated directly by tracing the EVM opcodes from this contract.\n///                     As a result, it may not compile or even be valid solidity code.\n///                     Despite this, it should be obvious what each function does. Overall\n///                     logic should have been preserved throughout decompiling.\n///\n/// @custom:github    You can find the open-source decompiler here:\n///                       https://heimdall.rs\n\ncontract DecompiledContract {\n    mapping(bytes32 => bytes32) storage_map_l;\n    mapping(bytes32 => bytes32) storage_map_h;\n    mapping(bytes32 => bytes32) storage_map_r;\n    mapping(bytes32 => bytes32) storage_map_c;\n    mapping(bytes32 => bytes32) storage_map_f;\n    mapping(bytes32 => bytes32) storage_map_j;\n    address public rewardToken;\n    bytes32 store_p;\n    mapping(bytes32 => bytes32) storage_map_m;\n    address store_k;\n    mapping(bytes32 => bytes32) storage_map_n;\n    bytes32 store_a;\n    uint256 public timeLength;\n    bytes32 store_b;\n    address public usdt;\n    uint256 public getToday;\n    address public unresolved_8a810056;\n    address public owner;\n    \n    event NodeAdded(address, uint256);\n    event NodeRemoved(address);\n    \n    /// @custom:selector    0xbd7a303f\n    /// @custom:signature   Unresolved_bd7a303f(uint256 arg0) public view returns (uint256)\n    /// @param              arg0 [\"uint256\", \"bytes32\", \"int256\"]\n    function Unresolved_bd7a303f(uint256 arg0) public view returns (uint256) {\n        require(msg.value);\n        if ((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20) {\n            if (0 < store_a) {\n                require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n                var_a = 0x08;\n                address var_a = address(store_b >> 0);\n                var_b = 0x06;\n                require(0 < store_a);\n                require(!0 < store_a);\n                var_a = 0x08;\n                var_a = address(store_b >> 0);\n                var_b = 0x06;\n                require(!0 < store_a);\n                require(!storage_map_c[var_a] > arg0);\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(0 == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x32;\n                require(0 == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            }\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        uint256 var_d = 0;\n        return 0;\n    }\n    \n    /// @custom:selector    0xc7c5a25e\n    /// @custom:signature   Unresolved_c7c5a25e(uint256 arg0) public payable returns (uint256)\n    /// @param              arg0 [\"uint256\", \"bytes32\", \"int256\"]\n    function Unresolved_c7c5a25e(uint256 arg0) public payable returns (uint256) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20, \"Not owner\");\n        require(!(msg.sender == (address(owner))), \"Not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x09;\n        var_d = 0x4e6f74206f776e65720000000000000000000000000000000000000000000000;\n        require(!arg0, \"wrong time\");\n        timeLength = arg0;\n        return ;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0a;\n        var_d = 0x77726f6e672074696d6500000000000000000000000000000000000000000000;\n    }\n    \n    /// @custom:selector    0xb2931096\n    /// @custom:signature   hasClaimed(address arg0, uint256 arg1) public view returns (bool)\n    /// @param              arg0 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    /// @param              arg1 [\"uint256\", \"bytes32\", \"int256\"]\n    function hasClaimed(address arg0, uint256 arg1) public view returns (bool) {\n        require(msg.value);\n        require((msg.data.length + 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc) < 0x40);\n        require(arg0 - (address(arg0)));\n        uint256 var_a = arg1;\n        var_b = 0x07;\n        var_a = address(arg0);\n        uint256 var_b = 0x05 + keccak256(var_a);\n        uint256 var_c = !(!bytes1(storage_map_c[var_a]));\n        return !(!bytes1(storage_map_c[var_a]));\n    }\n    \n    /// @custom:selector    0x189a5a17\n    /// @custom:signature   nodes(address arg0) public view returns (bool)\n    /// @param              arg0 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    function nodes(address arg0) public view returns (bool) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n        require(arg0 - (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x06;\n        address var_c = storage_map_c[var_a];\n        address var_d = !(!bytes1(storage_map_f[var_a]));\n        return abi.encodePacked(storage_map_c[var_a], (bytes1(storage_map_f[var_a])));\n    }\n    \n    /// @custom:selector    0x5f465f8f\n    /// @custom:signature   Unresolved_5f465f8f(address arg0) public payable returns (uint256)\n    /// @param              arg0 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    function Unresolved_5f465f8f(address arg0) public payable returns (uint256) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n        require(arg0 - (address(arg0)));\n        require(!(msg.sender == (address(owner))), \"Not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x09;\n        var_d = 0x4e6f74206f776e65720000000000000000000000000000000000000000000000;\n        unresolved_8a810056 = (uint96(unresolved_8a810056)) | (address(arg0));\n        return ;\n    }\n    \n    /// @custom:selector    0x8c256359\n    /// @custom:signature   isNodes(address arg0) public view returns (bool)\n    /// @param              arg0 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    function isNodes(address arg0) public view returns (bool) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n        require(arg0 - (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x06;\n        address var_c = !(!bytes1(storage_map_f[var_a]));\n        return !(!bytes1(storage_map_f[var_a]));\n    }\n    \n    /// @custom:selector    0x9d95f1cc\n    /// @custom:signature   addNode(address arg0) public payable returns (uint256)\n    /// @param              arg0 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    function addNode(address arg0) public payable returns (uint256) {\n        require(msg.value);\n        require((msg.data.length + 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc) < 0x20);\n        require(arg0 - (address(arg0)));\n        require(!(msg.sender == (address(owner))), \"Not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x09;\n        var_d = 0x4e6f74206f776e65720000000000000000000000000000000000000000000000;\n        address var_e = address(arg0);\n        var_f = 0x06;\n        require(bytes1(storage_map_h[var_e]), \"Already a node\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0e;\n        var_d = 0x416c72656164792061206e6f6465000000000000000000000000000000000000;\n        require((block.timestamp - getToday) > block.timestamp);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(!timeLength);\n        require(((var_h + 0x40) > 0xffffffffffffffff) | ((var_h + 0x40) < var_h));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x41;\n        uint256 var_h = var_h + 0x40;\n        uint256 var_a = (block.timestamp - getToday) / timeLength;\n        var_i = 0x01;\n        var_e = address(arg0);\n        var_f = 0x06;\n        storage_map_j[var_e] = var_h.length;\n        storage_map_h[var_e] = (bytes1(var_j)) | (uint248(storage_map_h[var_e]));\n        require(!store_a < 0x010000000000000000);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x41;\n        store_a = store_a + 0x01;\n        require(!store_a < store_a);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x32;\n        var_e = 0x08;\n        store_k = (uint96(store_k)) | (address(arg0) << 0);\n        uint256 var_k = (block.timestamp - getToday) / timeLength;\n        emit NodeAdded(address(arg0), (block.timestamp - getToday) / timeLength);\n        return ;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x12;\n    }\n    \n    /// @custom:selector    0xb79b70eb\n    /// @custom:signature   getBonusPool(uint256 arg0) public view returns (bool)\n    /// @param              arg0 [\"uint256\", \"bytes32\", \"int256\"]\n    function getBonusPool(uint256 arg0) public view returns (bool) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n        uint256 var_a = arg0;\n        var_b = 0x07;\n        uint256 var_c = storage_map_c[var_a];\n        uint256 var_d = storage_map_l[var_a];\n        uint256 var_e = storage_map_f[var_a];\n        uint256 var_f = storage_map_m[var_a];\n        uint256 var_g = !(!bytes1(storage_map_n[var_a]));\n        return abi.encodePacked(storage_map_c[var_a], storage_map_l[var_a], storage_map_f[var_a], storage_map_m[var_a], (bytes1(storage_map_n[var_a])));\n    }\n    \n    /// @custom:selector    0x4e71d92d\n    /// @custom:signature   claim() public view\n    function claim() public view {\n        require(msg.value);\n        require((msg.data.length + 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc) < 0);\n        address var_a = msg.sender;\n        var_b = 0x06;\n        require(!(bytes1(storage_map_f[var_a])), \"Node too new\");\n        require((block.timestamp - getToday) > block.timestamp, \"Node too new\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!timeLength, \"Node too new\");\n        require((((block.timestamp - getToday) / timeLength) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) > ((block.timestamp - getToday) / timeLength), \"Node too new\");\n        require((((block.timestamp - getToday) / timeLength) + 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe) > ((block.timestamp - getToday) / timeLength), \"Node too new\");\n        var_a = ((block.timestamp - getToday) / timeLength) + 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe;\n        var_b = 0x07;\n        require(!(bytes1(storage_map_n[var_a])), \"Node too new\");\n        var_a = msg.sender;\n        var_b = 0x06;\n        require(storage_map_c[var_a] > (((block.timestamp - getToday) / timeLength) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), \"Node too new\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x0c;\n        var_g = 0x4e6f646520746f6f206e65770000000000000000000000000000000000000000;\n        var_a = ((block.timestamp - getToday) / timeLength) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x07;\n        var_a = msg.sender;\n        address var_b = keccak256(var_a) + 0x05;\n        require(bytes1(storage_map_c[var_a]), \"Already claimed\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x0f;\n        var_g = 0x416c726561647920636c61696d65640000000000000000000000000000000000;\n        if (0 < store_a) {\n            if (!0 < store_a) {\n                var_a = 0x08;\n                var_a = address(store_b >> 0);\n                var_b = 0x06;\n                require(0 < store_a, \"No valid nodes\");\n                require(!(0 < store_a), \"No valid nodes\");\n                var_a = 0x08;\n                var_a = address(store_b >> 0);\n                var_b = 0x06;\n                require(!(0 < store_a), \"No valid nodes\");\n                require(!(storage_map_c[var_a] > (((block.timestamp - getToday) / timeLength) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)), \"No valid nodes\");\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(0 == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"No valid nodes\");\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x32;\n                require(0 == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"No valid nodes\");\n            }\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        require(!0, \"No valid nodes\");\n        require(!0, \"No valid nodes\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x0e;\n        var_g = 0x4e6f2076616c6964206e6f646573000000000000000000000000000000000000;\n        require((block.timestamp - getToday) > block.timestamp, \"Not a node\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x0a;\n        var_g = 0x4e6f742061206e6f646500000000000000000000000000000000000000000000;\n    }\n    \n    /// @custom:selector    0x208f2a31\n    /// @custom:signature   nodeList(uint256 arg0) public view returns (address)\n    /// @param              arg0 [\"uint256\", \"bytes32\", \"int256\"]\n    function nodeList(uint256 arg0) public view returns (address) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n        require(!arg0 < store_a);\n        require(!arg0 < store_a);\n        var_a = 0x08;\n        uint256 var_b = address(store_p >> 0);\n        return address(store_p >> 0);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n    }\n    \n    /// @custom:selector    0xb2b99ec9\n    /// @custom:signature   removeNode(address arg0) public payable returns (uint256)\n    /// @param              arg0 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    function removeNode(address arg0) public payable returns (uint256) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n        require(arg0 - (address(arg0)));\n        require(!(msg.sender == (address(owner))), \"Not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x09;\n        var_d = 0x4e6f74206f776e65720000000000000000000000000000000000000000000000;\n        address var_e = address(arg0);\n        var_f = 0x06;\n        require(!(bytes1(storage_map_h[var_e])), \"Not a node\");\n        var_e = address(arg0);\n        var_f = 0x06;\n        storage_map_j[var_e] = 0;\n        storage_map_h[var_e] = 0;\n        require(0x01, \"Not a node\");\n        emit NodeRemoved(address(arg0));\n        return ;\n        require(!(0 < store_a), \"Not a node\");\n        require(!(0 < store_a), \"Not a node\");\n        var_e = 0x08;\n        require(address(store_b >> 0) == (address(arg0)), \"Not a node\");\n        require(0 == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Not a node\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require((store_a + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) > store_a, \"Not a node\");\n        require(!((store_a + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) < store_a), \"Not a node\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x32;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x32;\n        emit NodeRemoved(address(arg0));\n        return ;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0a;\n        var_d = 0x4e6f742061206e6f646500000000000000000000000000000000000000000000;\n    }\n    \n    /// @custom:selector    0xcbae0b8d\n    /// @custom:signature   Unresolved_cbae0b8d(address arg0) public payable returns (uint256)\n    /// @param              arg0 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    function Unresolved_cbae0b8d(address arg0) public payable returns (uint256) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n        require(arg0 - (address(arg0)));\n        require(!(msg.sender == (address(owner))), \"Not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x09;\n        var_d = 0x4e6f74206f776e65720000000000000000000000000000000000000000000000;\n        usdt = (uint96(usdt)) | (address(arg0));\n        return ;\n    }\n    \n    /// @custom:selector    0x9c4380e7\n    /// @custom:signature   getToken(address arg0, address arg1, uint256 arg2) public payable returns (uint256)\n    /// @param              arg0 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    /// @param              arg1 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    /// @param              arg2 [\"uint256\", \"bytes32\", \"int256\"]\n    function getToken(address arg0, address arg1, uint256 arg2) public payable returns (uint256) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x60);\n        require(arg0 - (address(arg0)));\n        require(arg1 - (address(arg1)));\n        require(!(msg.sender == (address(owner))), \"Not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x09;\n        var_d = 0x4e6f74206f776e65720000000000000000000000000000000000000000000000;\n        var_a = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(arg1);\n        uint256 var_c = arg2;\n        (bool success, bytes memory ret0) = address(arg0).{ value: 0 ether }Unresolved_a9059cbb(var_b); // call\n        return ;\n        require(0x20 > ret0.length);\n        require(((var_e + 0x20) > 0xffffffffffffffff) | ((var_e + 0x20) < var_e));\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x41;\n        uint256 var_e = var_e + 0x20;\n        require(((var_e + 0x20) - var_e) < 0x20);\n        require(var_e.length - var_e.length);\n        return ;\n    }\n    \n    /// @custom:selector    0x7f315061\n    /// @custom:signature   Unresolved_7f315061(uint256 arg0) public view\n    /// @param              arg0 [\"uint256\", \"bytes32\", \"int256\"]\n    function Unresolved_7f315061(uint256 arg0) public view {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20, \"not rant\");\n        require(!(msg.sender == (address(rewardToken))), \"not rant\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x08;\n        var_d = 0x6e6f742072616e74000000000000000000000000000000000000000000000000;\n        require((block.timestamp - getToday) > block.timestamp);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(!timeLength);\n        uint256 var_e = (block.timestamp - getToday) / timeLength;\n        var_g = 0x07;\n        require(storage_map_r[var_e] > (storage_map_r[var_e] + arg0));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n    }\n    \n    /// @custom:selector    0xc15de638\n    /// @custom:signature   Unresolved_c15de638(uint256 arg0) public view\n    /// @param              arg0 [\"uint256\", \"bytes32\", \"int256\"]\n    function Unresolved_c15de638(uint256 arg0) public view {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20, \"not rant\");\n        require(!(msg.sender == (address(unresolved_8a810056))), \"not rant\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x08;\n        var_d = 0x6e6f742072616e74000000000000000000000000000000000000000000000000;\n        require((block.timestamp - getToday) > block.timestamp);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(!timeLength);\n        uint256 var_e = (block.timestamp - getToday) / timeLength;\n        var_g = 0x07;\n        require(storage_map_j[var_e] > (storage_map_j[var_e] + arg0));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n    }\n    \n    /// @custom:selector    0x66829b16\n    /// @custom:signature   changeToken(address arg0) public payable returns (uint256)\n    /// @param              arg0 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    function changeToken(address arg0) public payable returns (uint256) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n        require(arg0 - (address(arg0)));\n        require(!(msg.sender == (address(owner))), \"Not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x09;\n        var_d = 0x4e6f74206f776e65720000000000000000000000000000000000000000000000;\n        rewardToken = (uint96(rewardToken)) | (address(arg0));\n        return ;\n    }\n    \n    /// @custom:selector    0xdf9620eb\n    /// @custom:signature   Unresolved_df9620eb(uint256 arg0, address arg1) public payable returns (uint256)\n    /// @param              arg0 [\"uint256\", \"bytes32\", \"int256\"]\n    /// @param              arg1 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    function Unresolved_df9620eb(uint256 arg0, address arg1) public payable returns (uint256) {\n        require(msg.value);\n        require((msg.data.length + 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc) < 0x20);\n        require(arg0 > 0xffffffffffffffff);\n        require(!(arg0 + 0x23) < msg.data.length);\n        require(arg0 > 0xffffffffffffffff);\n        require(((arg0 + (arg0 << 0x05)) + 0x24) > msg.data.length, \"Not owner\");\n        require(!(msg.sender == (address(owner))), \"Not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x09;\n        var_d = 0x4e6f74206f776e65720000000000000000000000000000000000000000000000;\n        require((block.timestamp - getToday) > block.timestamp);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(!timeLength);\n        require(0 < (arg0));\n        require(msg.data[(arg0 + 0) + 0x24] - (address(msg.data[(arg0 + 0) + 0x24])));\n        uint256 var_e = address(msg.data[(arg0 + 0) + 0x24]);\n        var_g = 0x06;\n        require(!bytes1(storage_map_h[var_e]));\n        require(0 == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(((var_h + 0x40) > 0xffffffffffffffff) | ((var_h + 0x40) < var_h));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x41;\n        uint256 var_h = var_h + 0x40;\n        uint256 var_a = (block.timestamp - getToday) / timeLength;\n        var_i = 0x01;\n        var_e = address(msg.data[(arg0 + 0) + 0x24]);\n        var_g = 0x06;\n        storage_map_j[var_e] = var_h.length;\n        storage_map_h[var_e] = (bytes1(var_j)) | (uint248(storage_map_h[var_e]));\n        require(!store_a < 0x010000000000000000);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x41;\n        store_a = store_a + 0x01;\n        require(!store_a < store_a);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        return ;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n    }\n    \n    /// @custom:selector    0xf2fde38b\n    /// @custom:signature   transferOwnership(address arg0) public payable returns (uint256)\n    /// @param              arg0 [\"address\", \"uint160\", \"bytes20\", \"int160\"]\n    function transferOwnership(address arg0) public payable returns (uint256) {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n        require(arg0 - (address(arg0)));\n        require(!(address(owner) == msg.sender), \"Not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x09;\n        var_d = 0x4e6f74206f776e65720000000000000000000000000000000000000000000000;\n        owner = (uint96(owner)) | (address(arg0));\n        return ;\n    }\n    \n    /// @custom:selector    0x53f3b713\n    /// @custom:signature   getNodeList() public view returns (bytes memory)\n    function getNodeList() public view returns (bytes memory) {\n        require(msg.value);\n        require((msg.data.length + 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc) < 0);\n        var_a = store_a;\n        var_b = 0x08;\n        if (0 < store_a) {\n            if (((var_c + (uint248(((var_c + 0x20) - var_c) + 0x1f))) > 0xffffffffffffffff) | ((var_c + (uint248(((var_c + 0x20) - var_c) + 0x1f))) < var_c)) {\n                var_b = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_d = 0x41;\n                uint248 var_c = var_c + (uint248(((var_c + 0x20) - var_c) + 0x1f));\n                var_e = 0x20;\n                uint256 var_f = var_c.length;\n                return abi.encodePacked(0x20, var_c.length);\n            }\n        }\n    }\n    \n    /// @custom:selector    0xafe5b025\n    /// @custom:signature   Unresolved_afe5b025() public payable returns (uint256)\n    function Unresolved_afe5b025() public payable returns (uint256) {\n        require(msg.value);\n        require((msg.data.length + 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc) < 0);\n        if ((block.timestamp - getToday) > block.timestamp) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x11;\n            if (!timeLength) {\n                if ((((block.timestamp - getToday) / timeLength) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) > ((block.timestamp - getToday) / timeLength)) {\n                    if ((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe + ((block.timestamp - getToday) / timeLength)) > (((block.timestamp - getToday) / timeLength) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x11;\n                        uint256 var_a = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe + ((block.timestamp - getToday) / timeLength);\n                        var_c = 0x07;\n                        if (storage_map_n[var_a]) {\n                            return ;\n                            if (storage_map_f[var_a]) {\n                                var_a = ((block.timestamp - getToday) / timeLength) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                                if (storage_map_c[var_a] > (storage_map_c[var_a] + (storage_map_f[var_a]))) {\n                                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_b = 0x11;\n                                    if (storage_map_m[var_a]) {\n                                        var_a = ((block.timestamp - getToday) / timeLength) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                                        var_c = 0x07;\n                                        if (storage_map_l[var_a] > (storage_map_l[var_a] + (storage_map_m[var_a]))) {\n                                            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_b = 0x11;\n                                            storage_map_n[var_a] = (uint248(storage_map_n[var_a])) | 0x01;\n                                            return ;\n                                            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_b = 0x11;\n                                            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_b = 0x12;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
  "optimized_sol_code": "基于反编译代码的分析，这是一个节点管理和奖励分发系统。以下是优化重构后的代码：\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title NodeRewardManager\n * @notice 节点奖励管理合约 - 管理节点注册、奖励分发和时间周期\n * @dev 这是一个去中心化的节点管理系统，支持周期性奖励分发\n * \n * 主要功能：\n * - 节点注册和移除\n * - 基于时间周期的奖励分发\n * - 奖励池管理\n * - 权限控制\n * \n * 安全特性：\n * - 所有者权限控制\n * - 防重入攻击\n * - 时间锁定机制\n * - 奖励防重复领取\n */\ncontract NodeRewardManager is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ========== 状态变量 ==========\n    \n    /// @notice 奖励代币地址\n    address public rewardToken;\n    \n    /// @notice USDT代币地址\n    address public usdtToken;\n    \n    /// @notice 特殊权限地址（可能是管理员或合作伙伴）\n    address public privilegedAddress;\n    \n    /// @notice 时间周期长度（秒）\n    uint256 public timeLength;\n    \n    /// @notice 今日开始时间戳\n    uint256 public todayStartTime;\n    \n    /// @notice 节点总数\n    uint256 public totalNodes;\n    \n    /// @notice 节点地址列表\n    address[] public nodeList;\n\n    // ========== 映射存储 ==========\n    \n    /// @notice 节点信息映射：地址 => 节点状态\n    mapping(address => bool) public isNodeActive;\n    \n    /// @notice 节点注册时间映射：地址 => 注册的周期数\n    mapping(address => uint256) public nodeRegistrationPeriod;\n    \n    /// @notice 用户在特定周期的领取状态：用户地址 => 周期 => 是否已领取\n    mapping(address => mapping(uint256 => bool)) public hasClaimedInPeriod;\n    \n    /// @notice 周期奖励池信息\n    struct PeriodRewardPool {\n        uint256 totalRewards;        // 总奖励数量\n        uint256 distributedRewards;  // 已分发奖励\n        uint256 nodeRewards;         // 节点奖励\n        uint256 bonusRewards;        // 额外奖励\n        bool isFinalized;            // 是否已结算\n    }\n    \n    /// @notice 周期 => 奖励池信息\n    mapping(uint256 => PeriodRewardPool) public periodRewardPools;\n\n    // ========== 事件定义 ==========\n    \n    /// @notice 节点添加事件\n    /// @param nodeAddress 节点地址\n    /// @param period 注册周期\n    event NodeAdded(address indexed nodeAddress, uint256 indexed period);\n    \n    /// @notice 节点移除事件\n    /// @param nodeAddress 节点地址\n    event NodeRemoved(address indexed nodeAddress);\n    \n    /// @notice 奖励领取事件\n    /// @param user 用户地址\n    /// @param period 周期\n    /// @param amount 奖励数量\n    event RewardClaimed(address indexed user, uint256 indexed period, uint256 amount);\n    \n    /// @notice 奖励池更新事件\n    /// @param period 周期\n    /// @param rewardType 奖励类型 (0: 节点奖励, 1: 额外奖励)\n    /// @param amount 数量\n    event RewardPoolUpdated(uint256 indexed period, uint8 rewardType, uint256 amount);\n\n    // ========== 错误定义 ==========\n    \n    error NotOwner();\n    error NotAuthorized();\n    error InvalidAddress();\n    error InvalidTime();\n    error AlreadyNode();\n    error NotANode();\n    error AlreadyClaimed();\n    error NoValidNodes();\n    error NodeTooNew();\n    error InsufficientRewards();\n\n    // ========== 修饰器 ==========\n    \n    /// @notice 检查是否为合约所有者\n    modifier onlyOwner() override {\n        if (msg.sender != owner()) revert NotOwner();\n        _;\n    }\n    \n    /// @notice 检查是否为特权地址（奖励代币或特殊权限地址）\n    modifier onlyPrivileged() {\n        if (msg.sender != rewardToken && msg.sender != privilegedAddress) {\n            revert NotAuthorized();\n        }\n        _;\n    }\n    \n    /// @notice 检查地址有效性\n    modifier validAddress(address addr) {\n        if (addr == address(0)) revert InvalidAddress();\n        _;\n    }\n\n    // ========== 构造函数 ==========\n    \n    constructor(\n        address _rewardToken,\n        address _usdtToken,\n        uint256 _timeLength,\n        uint256 _todayStartTime\n    ) {\n        rewardToken = _rewardToken;\n        usdtToken = _usdtToken;\n        timeLength = _timeLength;\n        todayStartTime = _todayStartTime;\n    }\n\n    // ========== 管理员函数 ==========\n    \n    /**\n     * @notice 设置时间周期长度\n     * @param newTimeLength 新的时间周期长度（秒）\n     */\n    function setTimeLength(uint256 newTimeLength) external onlyOwner {\n        if (newTimeLength == 0) revert InvalidTime();\n        timeLength = newTimeLength;\n    }\n    \n    /**\n     * @notice 设置特权地址\n     * @param newPrivilegedAddress 新的特权地址\n     */\n    function setPrivilegedAddress(address newPrivilegedAddress) \n        external \n        onlyOwner \n        validAddress(newPrivilegedAddress) \n    {\n        privilegedAddress = newPrivilegedAddress;\n    }\n    \n    /**\n     * @notice 更换奖励代币地址\n     * @param newRewardToken 新的奖励代币地址\n     */\n    function changeRewardToken(address newRewardToken) \n        external \n        onlyOwner \n        validAddress(newRewardToken) \n    {\n        rewardToken = newRewardToken;\n    }\n    \n    /**\n     * @notice 设置USDT代币地址\n     * @param newUsdtToken 新的USDT代币地址\n     */\n    function setUsdtToken(address newUsdtToken) \n        external \n        onlyOwner \n        validAddress(newUsdtToken) \n    {\n        usdtToken = newUsdtToken;\n    }\n\n    // ========== 节点管理函数 ==========\n    \n    /**\n     * @notice 添加节点\n     * @param nodeAddress 节点地址\n     */\n    function addNode(address nodeAddress) \n        external \n        onlyOwner \n        validAddress(nodeAddress) \n        nonReentrant \n    {\n        if (isNodeActive[nodeAddress]) revert AlreadyNode();\n        \n        uint256 currentPeriod = getCurrentPeriod();\n        \n        // 设置节点状态\n        isNodeActive[nodeAddress] = true;\n        nodeRegistrationPeriod[nodeAddress] = currentPeriod;\n        \n        // 添加到节点列表\n        nodeList.push(nodeAddress);\n        totalNodes++;\n        \n        emit NodeAdded(nodeAddress, currentPeriod);\n    }\n    \n    /**\n     * @notice 批量添加节点\n     * @param nodeAddresses 节点地址数组\n     */\n    function addMultipleNodes(address[] calldata nodeAddresses) \n        external \n        onlyOwner \n        nonReentrant \n    {\n        uint256 currentPeriod = getCurrentPeriod();\n        uint256 length = nodeAddresses.length;\n        \n        for (uint256 i = 0; i < length; i++) {\n            address nodeAddress = nodeAddresses[i];\n            if (nodeAddress == address(0)) continue;\n            if (isNodeActive[nodeAddress]) continue;\n            \n            // 设置节点状态\n            isNodeActive[nodeAddress] = true;\n            nodeRegistrationPeriod[nodeAddress] = currentPeriod;\n            \n            // 添加到节点列表\n            nodeList.push(nodeAddress);\n            totalNodes++;\n            \n            emit NodeAdded(nodeAddress, currentPeriod);\n        }\n    }\n    \n    /**\n     * @notice 移除节点\n     * @param nodeAddress 要移除的节点地址\n     */\n    function removeNode(address nodeAddress) \n        external \n        onlyOwner \n        validAddress(nodeAddress) \n        nonReentrant \n    {\n        if (!isNodeActive[nodeAddress]) revert NotANode();\n        \n        // 清除节点状态\n        isNodeActive[nodeAddress] = false;\n        nodeRegistrationPeriod[nodeAddress] = 0;\n        \n        // 从节点列表中移除\n        _removeFromNodeList(nodeAddress);\n        totalNodes--;\n        \n        emit NodeRemoved(nodeAddress);\n    }\n\n    // ========== 奖励相关函数 ==========\n    \n    /**\n     * @notice 用户领取奖励\n     * @dev 用户可以领取前一个周期的奖励\n     */\n    function claim() external nonReentrant {\n        address user = msg.sender;\n        \n        // 检查是否为活跃节点\n        if (!isNodeActive[user]) revert NotANode();\n        \n        uint256 currentPeriod = getCurrentPeriod();\n        if (currentPeriod == 0) revert NodeTooNew();\n        \n        uint256 claimPeriod = currentPeriod - 1;\n        \n        // 检查节点是否在该周期已经存在\n        if (nodeRegistrationPeriod[user] > claimPeriod) revert NodeTooNew();\n        \n        // 检查是否已经领取过\n        if (hasClaimedInPeriod[user][claimPeriod]) revert AlreadyClaimed();\n        \n        // 计算奖励数量\n        uint256 rewardAmount = _calculateReward(user, claimPeriod);\n        if (rewardAmount == 0) revert NoValidNodes();\n        \n        // 标记为已领取\n        hasClaimedInPeriod[user][claimPeriod] = true;\n        \n        // 更新奖励池统计\n        periodRewardPools[claimPeriod].distributedRewards += rewardAmount;\n        \n        // 转账奖励\n        IERC20(rewardToken).safeTransfer(user, rewardAmount);\n        \n        emit RewardClaimed(user, claimPeriod, rewardAmount);\n    }\n    \n    /**\n     * @notice 更新节点奖励池\n     * @param period 周期\n     * @param amount 奖励数量\n     */\n    function updateNodeRewardPool(uint256 period, uint256 amount) \n        external \n        onlyPrivileged \n    {\n        PeriodRewardPool storage pool = periodRewardPools[period];\n        \n        // 检查溢出\n        if (pool.nodeRewards + amount < pool.nodeRewards) {\n            revert InsufficientRewards();\n        }\n        \n        pool.nodeRewards += amount;\n        pool.totalRewards += amount;\n        \n        emit RewardPoolUpdated(period, 0, amount);\n    }\n    \n    /**\n     * @notice 更新额外奖励池\n     * @param period 周期\n     * @param amount 奖励数量\n     */\n    function updateBonusRewardPool(uint256 period, uint256 amount) \n        external \n        onlyPrivileged \n    {\n        PeriodRewardPool storage pool = periodRewardPools[period];\n        \n        // 检查溢出\n        if (pool.bonusRewards + amount < pool.bonusRewards) {\n            revert InsufficientRewards();\n        }\n        \n        pool.bonusRewards += amount;\n        pool.totalRewards += amount;\n        \n        emit RewardPoolUpdated(period, 1, amount);\n    }\n    \n    /**\n     * @notice 处理周期结算\n     * @dev 自动处理周期奖励分配逻辑\n     */\n    function processPeriodSettlement() external onlyPrivileged {\n        uint256 currentPeriod = getCurrentPeriod();\n        if (currentPeriod < 2) return;\n        \n        uint256 settlementPeriod = currentPeriod - 2;\n        PeriodRewardPool storage pool = periodRewardPools[settlementPeriod];\n        \n        if (pool.isFinalized) return;\n        \n        // 检查是否有足够的奖励分配\n        if (pool.nodeRewards > 0) {\n            uint256 previousPeriod = settlementPeriod + 1;\n            PeriodRewardPool storage prevPool = periodRewardPools[previousPeriod];\n            \n            // 将未分发的奖励累加到下一周期\n            if (prevPool.totalRewards + pool.nodeRewards >= prevPool.totalRewards) {\n                prevPool.totalRewards += pool.nodeRewards;\n                prevPool.nodeRewards += pool.nodeRewards;\n            }\n        }\n        \n        if (pool.bonusRewards > 0) {\n            uint256 previousPeriod = settlementPeriod + 1;\n            PeriodRewardPool storage prevPool = periodRewardPools[previousPeriod];\n            \n            // 将未分发的额外奖励累加到下一周期\n            if (prevPool.totalRewards + pool.bonusRewards >= prevPool.totalRewards) {\n                prevPool.totalRewards += pool.bonusRewards;\n                prevPool.bonusRewards += pool.bonusRewards;\n            }\n        }\n        \n        pool.isFinalized = true;\n    }\n\n    // ========== 资产管理函数 ==========\n    \n    /**\n     * @notice 提取代币\n     * @param token 代币地址\n     * @param to 接收地址\n     * @param amount 提取数量\n     */\n    function withdrawToken(\n        address token, \n        address to, \n        uint256 amount\n    ) external onlyOwner validAddress(token) validAddress(to) {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    // ========== 查询函数 ==========\n    \n    /**\n     * @notice 获取当前周期\n     * @return 当前周期数\n     */\n    function getCurrentPeriod() public view returns (uint256) {\n        if (timeLength == 0) return 0;\n        if",
  "decompiled_abi": "[\n  {\n    \"type\": \"function\",\n    \"name\": \"Unresolved_5f465f8f\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"Unresolved_763ea379\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"Unresolved_7f315061\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"Unresolved_8a810056\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"Unresolved_afe5b025\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"Unresolved_bd7a303f\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"Unresolved_c15de638\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"Unresolved_c7c5a25e\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"Unresolved_cbae0b8d\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"Unresolved_df9620eb\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"arg1\",\n        \"type\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"addNode\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"changeToken\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"claim\",\n    \"inputs\": [],\n    \"outputs\": [],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getBonusPool\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getNodeList\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getToday\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getToken\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"arg1\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"arg2\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"hasClaimed\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"arg1\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"isNodes\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"nodeList\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"nodes\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"owner\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"removeNode\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"rewardToken\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"timeLength\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"transferOwnership\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"usdt\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"NodeAdded\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\",\n        \"indexed\": false\n      },\n      {\n        \"name\": \"arg1\",\n        \"type\": \"uint256\",\n        \"indexed\": false\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"NodeRemoved\",\n    \"inputs\": [\n      {\n        \"name\": \"arg0\",\n        \"type\": \"address\",\n        \"indexed\": false\n      }\n    ],\n    \"anonymous\": false\n  }\n]",
  "decompiled_at": "2025-07-06T00:20:27.703133",
  "optimized_sol_file": "log/decompiled_1e619dbea1_20250706_002128.sol",
  "raw_sol_file": "log/raw_decompiled_1e619dbea1_20250706_002128.sol",
  "decompiled_abi_file": "log/decompiled_abi_1e619dbea1_20250706_002128.json"
}