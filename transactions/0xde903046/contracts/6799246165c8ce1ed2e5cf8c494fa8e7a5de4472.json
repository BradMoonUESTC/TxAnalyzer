{
  "address": "0x6799246165c8ce1ed2e5cf8c494fa8e7a5de4472",
  "has_source_code": true,
  "source_code": "// File: contracts\\extensions\\interfaces\\IV3Oracle.sol\r\n\r\npragma solidity >=0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IV3Oracle {\r\n\tfunction oraclePriceSqrtX96(address token0, address token1) external returns (uint256);\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\AggregatorInterface.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface AggregatorInterface {\r\n  function decimals() external view returns (uint8);\r\n  function latestAnswer() external view returns (int256);\r\n  function latestTimestamp() external view returns (uint256);\r\n  function latestRound() external view returns (uint256);\r\n  function description() external view returns (string memory);\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// File: contracts\\libraries\\SafeMath.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\libraries\\Math.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for performing various math operations\r\n// forked from: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\t\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        z = x > y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\extensions\\libraries\\StringHelpers.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\nlibrary StringHelpers {\r\n    function append(string memory a, string memory b) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a, b));\r\n    }\r\n\r\n    /**\r\n     * Returns the first string if it is not-empty, otherwise the second.\r\n     */\r\n    function orElse(string memory a, string memory b) internal pure returns (string memory) {\r\n        if (bytes(a).length > 0) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\t\r\n    function equals(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n}\r\n\r\n// File: contracts\\extensions\\ImpermaxV3OracleChainlink.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract ImpermaxV3OracleChainlink is IV3Oracle {\r\n\tusing SafeMath for uint256;\r\n\tusing StringHelpers for string;\r\n\r\n\tuint constant Q128 = 2**128;\r\n\tuint constant Q96 = 2**96;\r\n\tuint constant Q48 = 2**48;\r\n\tuint constant Q32 = 2**32;\r\n\r\n\taddress public admin;\r\n\taddress public pendingAdmin;\r\n\t\r\n\taddress public fallbackOracle;\r\n\r\n\t// Once created, token sources are immutable\r\n\t// All sources should be USD denominated\r\n\tmapping(address => address) public tokenSources;\r\n\t\r\n\t// If this is true, it prevents the admin to add the wrong source for a token by mistake\r\n\t// The admin could still add malicious sources for new tokens -> always double check a source before adding it\r\n\tbool public verifyTokenSource;\r\n\t\r\n\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\tevent NewAdmin(address oldAdmin, address newAdmin);\r\n\tevent NewFallbackOracle(address oldFallbackOracle, address newFallbackOracle);\r\n\tevent SetVerifyTokenSource(bool enable);\r\n\tevent TokenSourceCreated(address token, address source);\r\n\t\r\n\tconstructor(address _admin) public {\r\n\t\tadmin = _admin;\r\n\t\tverifyTokenSource = true;\r\n\t\temit NewAdmin(address(0), _admin);\r\n\t\temit SetVerifyTokenSource(true);\r\n\t}\r\n\t\r\n\tfunction oraclePriceSqrtX96(address token0, address token1) external returns (uint256 priceSqrtX96) {\r\n\t\t// 1. get latest prices\r\n\t\taddress source0 = tokenSources[token0];\r\n\t\taddress source1 = tokenSources[token1];\r\n\t\tif (source0 == address(0) || source1 == address(0)) {\r\n\t\t\t// fallback would be unsafe\r\n\t\t\trevert(\"ImpermaxV3OracleChainlink: UNSUPPORTED_PAIR\");\r\n\t\t}\r\n\t\tint256 price0 = AggregatorInterface(source0).latestAnswer();\r\n\t\tint256 price1 = AggregatorInterface(source1).latestAnswer();\r\n\t\tif (price0 <= 0 || price1 <= 0) {\r\n\t\t\trequire(fallbackOracle != address(0), \"ImpermaxV3OracleChainlink: PRICE_CALCULATION_ERROR\");\r\n\t\t\treturn IV3Oracle(fallbackOracle).oraclePriceSqrtX96(token0, token1);\r\n\t\t}\r\n\t\t\r\n\t\t// 2. calculate delta decimals\r\n\t\tint256 totalDecimals0 = int256(IERC20(token0).decimals()) + AggregatorInterface(source0).decimals();\r\n\t\tint256 totalDecimals1 = int256(IERC20(token1).decimals()) + AggregatorInterface(source1).decimals();\r\n\t\tint256 deltaDecimals = totalDecimals0 - totalDecimals1;\r\n\t\t\r\n\t\t// 3. calculate the price and scale it based on delta decimals\r\n\t\tpriceSqrtX96 = Math.sqrt(uint256(price0).mul(Q128).div(uint256(price1))).mul(Q32);\r\n\t\tuint scaleX96 = Q96;\r\n\t\tuint deltaDecimalsAbs = uint(deltaDecimals > 0 ? deltaDecimals : -deltaDecimals);\r\n\t\tfor (uint i = 0; i < deltaDecimalsAbs; i++) {\r\n\t\t\tscaleX96 = scaleX96.mul(10);\r\n\t\t}\r\n\t\tscaleX96 = Math.sqrt(scaleX96).mul(Q48);\r\n\t\tif (deltaDecimals > 0) {\r\n\t\t\tpriceSqrtX96 = priceSqrtX96.mul(Q96).div(scaleX96);\r\n\t\t} else {\r\n\t\t\tpriceSqrtX96 = priceSqrtX96.mul(scaleX96).div(Q96);\r\n\t\t}\r\n\t}\r\n\t\r\n\t/*** Admin ***/\r\n\t\r\n\tfunction _addTokenSources(address[] calldata tokens, address[] calldata sources) external {\r\n\t\trequire(msg.sender == admin, \"ImpermaxV3OracleChainlink: UNAUTHORIZED\");\r\n\t\trequire(tokens.length == sources.length, \"ImpermaxV3OracleChainlink: INCONSISTENT_PARAMS_LENGTH\");\r\n\t\tfor (uint i = 0; i < tokens.length; i++) {\r\n\t\t\trequire(tokenSources[tokens[i]] == address(0), \"ImpermaxV3OracleChainlink: TOKEN_INITIALIZED\");\r\n\t\t\tif (verifyTokenSource) {\r\n\t\t\t\tint256 price = AggregatorInterface(sources[i]).latestAnswer();\r\n\t\t\t\trequire(price > 100 && price < 2**112, \"ImpermaxV3OracleChainlink: PRICE_OUT_OF_RANGE\");\r\n\t\t\t\tint256 totalDecimals = int256(IERC20(tokens[i]).decimals()) + AggregatorInterface(sources[i]).decimals();\r\n\t\t\t\trequire(totalDecimals >= 8 && totalDecimals <= 48, \"ImpermaxV3OracleChainlink: DECIMALS_OUT_OF_RANGE\");\r\n\t\t\t\tstring memory symbol = IERC20(tokens[i]).symbol();\r\n\t\t\t\tstring memory description = AggregatorInterface(sources[i]).description();\r\n\t\t\t\trequire(description.equals(symbol.append(\" / USD\")), \"ImpermaxV3OracleChainlink: INCONSISTENT_DESCRIPTION\");\r\n\t\t\t}\r\n\t\t\ttokenSources[tokens[i]] = sources[i];\r\n\t\t\temit TokenSourceCreated(tokens[i], sources[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _setFallbackOracle(address newFallbackOracle) external {\r\n\t\trequire(msg.sender == admin, \"ImpermaxV3OracleChainlink: UNAUTHORIZED\");\r\n\t\taddress oldFallbackOracle = fallbackOracle;\r\n\t\tfallbackOracle = newFallbackOracle;\r\n\t\temit NewFallbackOracle(oldFallbackOracle, newFallbackOracle);\r\n\t}\r\n\t\r\n\tfunction _setVerifyTokenSource(bool enable) external {\r\n\t\trequire(msg.sender == admin, \"ImpermaxV3OracleChainlink: UNAUTHORIZED\");\r\n\t\tverifyTokenSource = enable;\r\n\t\temit SetVerifyTokenSource(enable);\r\n\t}\r\n\t\r\n\tfunction _setPendingAdmin(address newPendingAdmin) external {\r\n\t\trequire(msg.sender == admin, \"ImpermaxV3OracleChainlink: UNAUTHORIZED\");\r\n\t\taddress oldPendingAdmin = pendingAdmin;\r\n\t\tpendingAdmin = newPendingAdmin;\r\n\t\temit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\t}\r\n\r\n\tfunction _acceptAdmin() external {\r\n\t\trequire(msg.sender == pendingAdmin, \"ImpermaxV3OracleChainlink: UNAUTHORIZED\");\r\n\t\taddress oldAdmin = admin;\r\n\t\taddress oldPendingAdmin = pendingAdmin;\r\n\t\tadmin = pendingAdmin;\r\n\t\tpendingAdmin = address(0);\r\n\t\temit NewAdmin(oldAdmin, admin);\r\n\t\temit NewPendingAdmin(oldPendingAdmin, address(0));\r\n\t}\r\n}",
  "abi": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFallbackOracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFallbackOracle\",\"type\":\"address\"}],\"name\":\"NewFallbackOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"SetVerifyTokenSource\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"}],\"name\":\"TokenSourceCreated\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"sources\",\"type\":\"address[]\"}],\"name\":\"_addTokenSources\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFallbackOracle\",\"type\":\"address\"}],\"name\":\"_setFallbackOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"_setVerifyTokenSource\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fallbackOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"name\":\"oraclePriceSqrtX96\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceSqrtX96\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenSources\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifyTokenSource\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]",
  "contract_name": "ImpermaxV3OracleChainlink",
  "compiler_version": "v0.5.16+commit.9c3226ce",
  "optimization_used": "1",
  "runs": "999999",
  "constructor_arguments": "000000000000000000000000ee5ca68bae98c3e36bfbfeffb104f22e4ff34cf7",
  "evm_version": "Default",
  "library": "",
  "license_type": "BSL 1.1",
  "proxy": "0",
  "implementation": "",
  "bytecode": null
}