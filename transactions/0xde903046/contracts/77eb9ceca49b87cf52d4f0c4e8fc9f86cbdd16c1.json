{
  "address": "0x77eb9ceca49b87cf52d4f0c4e8fc9f86cbdd16c1",
  "has_source_code": true,
  "source_code": "// File: contracts\\interfaces\\IERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// File: contracts\\libraries\\Math.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for performing various math operations\r\n// forked from: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\t\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        z = x > y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\libraries\\SafeMath.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\ITokenizedUniswapV3Factory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ITokenizedUniswapV3Factory {\r\n\tevent NFTLPCreated(address indexed token0, address indexed token1, address NFTLP, uint);\r\n\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\tevent NewAdmin(address oldAdmin, address newAdmin);\r\n\tevent NewAcModule(address oldAcModule, address newAcModule);\r\n\t\r\n\tfunction admin() external view returns (address);\r\n\tfunction pendingAdmin() external view returns (address);\r\n\t\r\n\tfunction uniswapV3Factory() external view returns (address);\r\n\tfunction deployer() external view returns (address);\r\n\tfunction oracle() external view returns (address);\r\n\tfunction acModule() external view returns (address);\r\n\t\r\n\tfunction getNFTLP(address tokenA, address tokenB) external view returns (address);\r\n\tfunction allNFTLP(uint) external view returns (address);\r\n\tfunction allNFTLPLength() external view returns (uint);\r\n\t\r\n\tfunction createNFTLP(address tokenA, address tokenB) external returns (address NFTLP);\r\n\t\r\n\tfunction _setPendingAdmin(address newPendingAdmin) external;\r\n\tfunction _acceptAdmin() external;\r\n\tfunction _setAcModule(address newAcModule) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\INFTLP.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface INFTLP {\r\n\tstruct RealXY {\r\n\t\tuint256 realX;\r\n\t\tuint256 realY;\r\n\t}\r\n\t\r\n\tstruct RealXYs {\r\n\t\tRealXY lowestPrice;\r\n\t\tRealXY currentPrice;\r\n\t\tRealXY highestPrice;\r\n\t}\r\n\t\r\n\t// ERC-721\r\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\t\r\n\t// Global state\r\n\tfunction token0() external view returns (address);\r\n\tfunction token1() external view returns (address);\r\n\t\r\n\t// Position state\r\n\tfunction getPositionData(uint256 _tokenId, uint256 _safetyMarginSqrt) external returns (\r\n\t\tuint256 priceSqrtX96,\r\n\t\tRealXYs memory realXYs\r\n\t);\r\n\t\r\n\t// Interactions\r\n\t\r\n\tfunction split(uint256 tokenId, uint256 percentage) external returns (uint256 newTokenId);\r\n\tfunction join(uint256 tokenId, uint256 tokenToJoin) external;\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\ITokenizedUniswapV3Position.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ITokenizedUniswapV3Position {\r\n\t\r\n\t// ERC-721\r\n\t\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction nonces(uint256 tokenId) external view returns (uint256);\r\n\t\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\tfunction setApprovalForAll(address operator, bool approved) external;\r\n\tfunction permit(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t// INFTLP\r\n\t\r\n\tfunction token0() external view returns (address);\r\n\tfunction token1() external view returns (address);\r\n\tfunction getPositionData(uint256 _tokenId, uint256 _safetyMarginSqrt) external returns (\r\n\t\tuint256 priceSqrtX96,\r\n\t\tINFTLP.RealXYs memory realXYs\r\n\t);\r\n\t\r\n\tfunction join(uint256 tokenId, uint256 tokenToJoin) external;\r\n\tfunction split(uint256 tokenId, uint256 percentage) external returns (uint256 newTokenId);\r\n\t\r\n\t// ITokenizedUniswapV3Position\r\n\t\r\n\tstruct Position {\r\n\t\tuint24 fee;\r\n\t\tint24 tickLower;\r\n\t\tint24 tickUpper;\r\n\t\tuint128 liquidity;\r\n\t\tuint256 feeGrowthInside0LastX128;\r\n\t\tuint256 feeGrowthInside1LastX128;\r\n\t\tuint256 unclaimedFees0;\t\r\n\t\tuint256 unclaimedFees1;\t\r\n\t}\r\n\t\r\n\tfunction factory() external view returns (address);\r\n\tfunction uniswapV3Factory() external view returns (address);\r\n\t\r\n\tfunction totalBalance(uint24 fee, int24 tickLower, int24 tickUpper) external view returns (uint256);\r\n\t\r\n\tfunction positions(uint256 tokenId) external view returns (\r\n\t\tuint24 fee,\r\n\t\tint24 tickLower,\r\n\t\tint24 tickUpper,\r\n\t\tuint128 liquidity,\r\n\t\tuint256 feeGrowthInside0LastX128,\r\n\t\tuint256 feeGrowthInside1LastX128,\r\n\t\tuint256 unclaimedFees0,\r\n\t\tuint256 unclaimedFees1\r\n\t);\r\n\tfunction positionsLength() external view returns (uint256);\r\n\t\r\n\tfunction getPool(uint24 fee) external view returns (address pool);\r\n\t\r\n\tfunction oraclePriceSqrtX96() external returns (uint256);\r\n\t\r\n\tevent MintPosition(uint256 indexed tokenId, uint24 fee, int24 tickLower, int24 tickUpper);\r\n\tevent UpdatePositionLiquidity(uint256 indexed tokenId, uint256 liquidity);\r\n\tevent UpdatePositionFeeGrowthInside(uint256 indexed tokenId, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);\r\n\tevent UpdatePositionUnclaimedFees(uint256 indexed tokenId, uint256 unclaimedFees0, uint256 unclaimedFees1);\r\n\r\n\tfunction _initialize (\r\n\t\taddress _uniswapV3Factory, \r\n\t\taddress _oracle, \r\n\t\taddress _token0, \r\n\t\taddress _token1\r\n\t) external;\r\n\t\r\n\tfunction mint(address to, uint24 fee, int24 tickLower, int24 tickUpper) external  returns (uint256 newTokenId);\r\n\tfunction redeem(address to, uint256 tokenId) external  returns (uint256 amount0, uint256 amount1);\r\n\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\IUniswapV3Factory.sol\r\n\r\n// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title The interface for the Uniswap V3 Factory\r\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\r\ninterface IUniswapV3Factory {\r\n    /// @notice Emitted when the owner of the factory is changed\r\n    /// @param oldOwner The owner before the owner was changed\r\n    /// @param newOwner The owner after the owner was changed\r\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// @notice Emitted when a pool is created\r\n    /// @param token0 The first token of the pool by address sort order\r\n    /// @param token1 The second token of the pool by address sort order\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\r\n    /// @param pool The address of the created pool\r\n    event PoolCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        uint24 indexed fee,\r\n        int24 tickSpacing,\r\n        address pool\r\n    );\r\n\r\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\r\n    /// @param fee The enabled fee, denominated in hundredths of a bip\r\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\r\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\r\n\r\n    /// @notice Returns the current owner of the factory\r\n    /// @dev Can be changed by the current owner via setOwner\r\n    /// @return The address of the factory owner\r\n    function owner() external view returns (address);\r\n\r\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\r\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\r\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\r\n    /// @return The tick spacing\r\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\r\n\r\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\r\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\r\n    /// @param tokenA The contract address of either token0 or token1\r\n    /// @param tokenB The contract address of the other token\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @return pool The pool address\r\n    function getPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external view returns (address pool);\r\n\r\n    /// @notice Creates a pool for the given two tokens and fee\r\n    /// @param tokenA One of the two tokens in the desired pool\r\n    /// @param tokenB The other of the two tokens in the desired pool\r\n    /// @param fee The desired fee for the pool\r\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\r\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\r\n    /// are invalid.\r\n    /// @return pool The address of the newly created pool\r\n    function createPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external returns (address pool);\r\n\r\n    /// @notice Updates the owner of the factory\r\n    /// @dev Must be called by the current owner\r\n    /// @param _owner The new owner of the factory\r\n    function setOwner(address _owner) external;\r\n\r\n    /// @notice Enables a fee amount with the given tickSpacing\r\n    /// @dev Fee amounts may never be removed once enabled\r\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\r\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\r\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\IUniswapV3Pool.sol\r\n\r\n// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV3Pool {\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function fee() external view returns (uint24);\r\n    function tickSpacing() external view returns (int24);\r\n    function maxLiquidityPerTick() external view returns (uint128);\r\n\t\r\n    function slot0()\r\n        external\r\n        view\r\n        returns (\r\n            uint160 sqrtPriceX96,\r\n            int24 tick,\r\n            uint16 observationIndex,\r\n            uint16 observationCardinality,\r\n            uint16 observationCardinalityNext,\r\n            uint8 feeProtocol,\r\n            bool unlocked\r\n        );\r\n\r\n    function feeGrowthGlobal0X128() external view returns (uint256);\r\n    function feeGrowthGlobal1X128() external view returns (uint256);\r\n    function protocolFees() external view returns (uint128, uint128);\r\n    function liquidity() external view returns (uint128);\r\n\r\n    function ticks(int24 tick)\r\n        external\r\n        view\r\n        returns (\r\n            uint128 liquidityGross,\r\n            int128 liquidityNet,\r\n            uint256 feeGrowthOutside0X128,\r\n            uint256 feeGrowthOutside1X128,\r\n            int56 tickCumulativeOutside,\r\n            uint160 secondsPerLiquidityOutsideX128,\r\n            uint32 secondsOutside,\r\n            bool initialized\r\n        );\r\n\r\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\r\n\r\n    function positions(bytes32 key)\r\n        external\r\n        view\r\n        returns (\r\n            uint128 _liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n\r\n    function observations(uint256 index)\r\n        external\r\n        view\r\n        returns (\r\n            uint32 blockTimestamp,\r\n            int56 tickCumulative,\r\n            uint160 secondsPerLiquidityCumulativeX128,\r\n            bool initialized\r\n        );\r\n\t\t\r\n    function observe(uint32[] calldata secondsAgos)\r\n        external\r\n        view\r\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\r\n\r\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\r\n        external\r\n        view\r\n        returns (\r\n            int56 tickCumulativeInside,\r\n            uint160 secondsPerLiquidityInsideX128,\r\n            uint32 secondsInside\r\n        );\r\n\t\t\r\n    function initialize(uint160 sqrtPriceX96) external;\r\n\r\n    function mint(\r\n        address recipient,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount,\r\n        bytes calldata data\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function collect(\r\n        address recipient,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount0Requested,\r\n        uint128 amount1Requested\r\n    ) external returns (uint128 amount0, uint128 amount1);\r\n\r\n    function burn(\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        address recipient,\r\n        bool zeroForOne,\r\n        int256 amountSpecified,\r\n        uint160 sqrtPriceLimitX96,\r\n        bytes calldata data\r\n    ) external returns (int256 amount0, int256 amount1);\r\n\t\r\n    function flash(\r\n        address recipient,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\IUniswapV3AC01.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV3AC01 {\r\n\t\r\n\tfunction uniswapV3Factory() external view returns (address);\r\n\tfunction tokenizedUniswapV3Factory() external view returns (address);\r\n\t\r\n\tfunction MAX_REINVEST_BOUNTY() external view returns (uint256);\r\n\tfunction MAX_BOUNTY_T() external view returns (uint256);\r\n\tfunction PROTOCOL_SHARE() external view returns (uint256);\r\n\t\r\n\tfunction getToCollect(\r\n\t\tITokenizedUniswapV3Position.Position calldata position, \r\n\t\tuint256 tokenId, \r\n\t\tuint256 feeCollected0, \r\n\t\tuint256 feeCollected1\r\n\t) external returns (uint256 collect0, uint256 collect1, bytes memory data);\r\n\t\r\n\tfunction mintLiquidity(\r\n\t\taddress bountyTo, \r\n\t\tbytes calldata data\r\n\t) external returns (uint256 bounty0, uint256 bounty1);\r\n\t\r\n\t/* Reserve Manager */\r\n\t\r\n\tevent NewReservesPendingAdmin(address oldReservesPendingAdmin, address newReservesPendingAdmin);\r\n\tevent NewReservesAdmin(address oldReservesAdmin, address newReservesAdmin);\r\n\tevent NewReservesManager(address oldReservesManager, address newReservesManager);\r\n\t\r\n\tfunction reservesAdmin() external view returns (address);\r\n\tfunction reservesPendingAdmin() external view returns (address);\r\n\tfunction reservesManager() external view returns (address);\r\n\t\r\n\tfunction _setReservesPendingAdmin(address newPendingAdmin) external;\r\n\tfunction _acceptReservesAdmin() external;\r\n\tfunction _setReservesManager(address newReservesManager) external;\r\n\t\r\n\tfunction claimToken(address token) external;\r\n\tfunction claimTokens(address[] calldata tokens) external;\r\n}\r\n\r\n// File: contracts\\extensions\\libraries\\TransferHelper.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.5.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeApprove: approve failed'\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeTransfer: transfer failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::transferFrom: transferFrom failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call.value(value)(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n}\r\n\r\n// File: contracts\\libraries\\FullMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.0 <0.8.0;\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = a * b\r\n        // Compute the product mod 2**256 and mod 2**256 - 1\r\n        // then use the Chinese Remainder Theorem to reconstruct\r\n        // the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2**256 + prod0\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(a, b, not(0))\r\n            prod0 := mul(a, b)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division\r\n        if (prod1 == 0) {\r\n            require(denominator > 0);\r\n            assembly {\r\n                result := div(prod0, denominator)\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2**256.\r\n        // Also prevents denominator == 0\r\n        require(denominator > prod1);\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0]\r\n        // Compute remainder using mulmod\r\n        uint256 remainder;\r\n        assembly {\r\n            remainder := mulmod(a, b, denominator)\r\n        }\r\n        // Subtract 256 bit number from 512 bit number\r\n        assembly {\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator\r\n        // Compute largest power of two divisor of denominator.\r\n        // Always >= 1.\r\n        uint256 twos = -denominator & denominator;\r\n        // Divide denominator by power of two\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        // Divide [prod1 prod0] by the factors of two\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n        // Shift in bits from prod1 into prod0. For this we need\r\n        // to flip `twos` such that it is 2**256 / twos.\r\n        // If twos is zero, then it becomes one\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        prod0 |= prod1 * twos;\r\n\r\n        // Invert denominator mod 2**256\r\n        // Now that denominator is an odd number, it has an inverse\r\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n        // Compute the inverse by starting with a seed that is correct\r\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n        uint256 inv = (3 * denominator) ^ 2;\r\n        // Now use Newton-Raphson iteration to improve the precision.\r\n        // Thanks to Hensel's lifting lemma, this also works in modular\r\n        // arithmetic, doubling the correct bits in each step.\r\n        inv *= 2 - denominator * inv; // inverse mod 2**8\r\n        inv *= 2 - denominator * inv; // inverse mod 2**16\r\n        inv *= 2 - denominator * inv; // inverse mod 2**32\r\n        inv *= 2 - denominator * inv; // inverse mod 2**64\r\n        inv *= 2 - denominator * inv; // inverse mod 2**128\r\n        inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n        // Because the division is now exact we can divide by multiplying\r\n        // with the modular inverse of denominator. This will give us the\r\n        // correct result modulo 2**256. Since the precoditions guarantee\r\n        // that the outcome is less than 2**256, this is the final result.\r\n        // We don't need to compute the high bits of the result and prod1\r\n        // is no longer required.\r\n        result = prod0 * inv;\r\n        return result;\r\n    }\r\n\r\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        result = mulDiv(a, b, denominator);\r\n        if (mulmod(a, b, denominator) > 0) {\r\n            require(result < uint256(-1));\r\n            result++;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\extensions\\libraries\\LiquidityAmounts.sol\r\n\r\n// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Liquidity amount functions\r\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\r\nlibrary LiquidityAmounts {\r\n    uint constant Q96 = 2**96;\r\n\t\r\n    /// @notice Downcasts uint256 to uint128\r\n    /// @param x The uint258 to be downcasted\r\n    /// @return y The passed value, downcasted to uint128\r\n    function toUint128(uint256 x) private pure returns (uint128 y) {\r\n        require((y = uint128(x)) == x);\r\n    }\r\n\r\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\r\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount0 The amount0 being sent in\r\n    /// @return liquidity The amount of returned liquidity\r\n    function getLiquidityForAmount0(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\r\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\r\n    }\r\n\r\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\r\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount1 The amount1 being sent in\r\n    /// @return liquidity The amount of returned liquidity\r\n    function getLiquidityForAmount1(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        return toUint128(FullMath.mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\r\n    }\r\n\r\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\r\n    /// pool prices and the prices at the tick boundaries\r\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount0 The amount of token0 being sent in\r\n    /// @param amount1 The amount of token1 being sent in\r\n    /// @return liquidity The maximum amount of liquidity received\r\n    function getLiquidityForAmounts(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\r\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\r\n\r\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\r\n        } else {\r\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\r\n        }\r\n    }\r\n\r\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount0 The amount of token0\r\n    function getAmount0ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return\r\n            FullMath.mulDiv(\r\n                uint256(liquidity) << 96,\r\n                sqrtRatioBX96 - sqrtRatioAX96,\r\n                sqrtRatioBX96\r\n            ) / sqrtRatioAX96;\r\n    }\r\n\r\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount1 The amount of token1\r\n    function getAmount1ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\r\n    }\r\n\r\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\r\n    /// pool prices and the prices at the tick boundaries\r\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount0 The amount of token0\r\n    /// @return amount1 The amount of token1\r\n    function getAmountsForLiquidity(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\r\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\r\n        } else {\r\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\extensions\\libraries\\TickMath.sol\r\n\r\n// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0 <0.8.0;\r\n\r\n/// @title Math library for computing sqrt prices from ticks and vice versa\r\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\r\n/// prices between 2**-128 and 2**128\r\nlibrary TickMath {\r\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n    int24 internal constant MIN_TICK = -887272;\r\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\r\n\r\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n    /// @dev Throws if |tick| > max tick\r\n    /// @param tick The input tick for the above formula\r\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n    /// at the given tick\r\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\r\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\r\n        require(absTick <= uint256(MAX_TICK), 'TickMath: T');\r\n\r\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\r\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n        if (tick > 0) ratio = uint256(-1) / ratio;\r\n\r\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\r\n    }\r\n\r\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\r\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\r\n    /// ever return.\r\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\r\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\r\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\r\n        // second inequality must be < because the price can never reach the price at the max tick\r\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'TickMath: R');\r\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\r\n\r\n        uint256 r = ratio;\r\n        uint256 msb = 0;\r\n\r\n        assembly {\r\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(5, gt(r, 0xFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(4, gt(r, 0xFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(3, gt(r, 0xFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(2, gt(r, 0xF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(1, gt(r, 0x3))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := gt(r, 0x1)\r\n            msb := or(msb, f)\r\n        }\r\n\r\n        if (msb >= 128) r = ratio >> (msb - 127);\r\n        else r = ratio << (127 - msb);\r\n\r\n        int256 log_2 = (int256(msb) - 128) << 64;\r\n\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(63, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(62, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(61, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(60, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(59, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(58, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(57, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(56, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(55, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(54, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(53, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(52, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(51, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(50, f))\r\n        }\r\n\r\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\r\n\r\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\r\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\r\n\r\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\r\n    }\r\n}\r\n\r\n// File: contracts\\extensions\\UniswapV3AC01.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract UniswapV3AC01 is IUniswapV3AC01 {\r\n\tusing SafeMath for uint256;\r\n\tusing TickMath for int24;\r\n\t\r\n\taddress public uniswapV3Factory;\r\n\taddress public tokenizedUniswapV3Factory;\r\n\taddress public reservesAdmin;\r\n\taddress public reservesPendingAdmin;\r\n\taddress public reservesManager;\r\n\t\r\n\tconstructor(address _uniswapV3Factory, address _tokenizedUniswapV3Factory, address _reservesAdmin, address _reservesManager) public {\r\n\t\tuniswapV3Factory = _uniswapV3Factory;\r\n\t\ttokenizedUniswapV3Factory = _tokenizedUniswapV3Factory;\r\n\t\treservesAdmin = _reservesAdmin;\r\n\t\treservesManager = _reservesManager;\r\n\t\temit NewReservesAdmin(address(0), _reservesAdmin);\r\n\t\temit NewReservesManager(address(0), _reservesManager);\r\n\t}\r\n\t\r\n\t/*** Autocompounder ***/\r\n\t\r\n\tfunction _checkCaller() internal view returns (address token0, address token1) {\r\n\t\ttoken0 = ITokenizedUniswapV3Position(msg.sender).token0();\r\n\t\ttoken1 = ITokenizedUniswapV3Position(msg.sender).token1();\r\n\t\trequire(\r\n\t\t\tITokenizedUniswapV3Factory(tokenizedUniswapV3Factory).getNFTLP(token0, token1) == msg.sender,\r\n\t\t\t\"UniswapV3AC01: UNAUTHORIZED_CALLER\"\r\n\t\t);\r\n\t}\r\n\t\r\n    uint constant Q96 = 2**96;\r\n\t\t\r\n\tuint256 public constant MAX_REINVEST_BOUNTY = 0.02e18; // 2%\r\n\tuint256 public constant MAX_BOUNTY_T = 7 * 24 * 60 * 60; // 1 week\r\n\tuint256 public constant PROTOCOL_SHARE = 0.5e18; // 50%\r\n\t\r\n\tmapping(address => mapping(uint256 => uint256)) internal lastReinvest;\r\n\t\r\n\tfunction _getBounty(address nftlp, uint256 tokenId) internal returns (uint256) {\r\n\t\tuint timeDelta = block.timestamp - lastReinvest[nftlp][tokenId];\r\n\t\tlastReinvest[nftlp][tokenId] = block.timestamp;\r\n\t\treturn timeDelta > MAX_BOUNTY_T \r\n\t\t\t? MAX_REINVEST_BOUNTY \r\n\t\t\t: MAX_REINVEST_BOUNTY * timeDelta / MAX_BOUNTY_T;\r\n\t}\r\n\t\r\n\tfunction _getReinvestAmounts(\r\n\t\tuint256 liquidity,\r\n\t\tuint256 realX,\r\n\t\tuint256 realY,\r\n\t\tuint256 feeCollected0,\r\n\t\tuint256 feeCollected1\r\n\t) internal pure returns (uint256 newLiquidity, uint256 amount0, uint256 amount1) {\r\n\t\tif (realX == 0) {\r\n\t\t\tamount0 = 0;\r\n\t\t\tamount1 = feeCollected1;\r\n\t\t\tnewLiquidity = liquidity.mul(amount1).div(realY);\r\n\t\t} \r\n\t\telse if (realY == 0) {\r\n\t\t\tamount0 = feeCollected0;\r\n\t\t\tamount1 = 0;\r\n\t\t\tnewLiquidity = liquidity.mul(amount0).div(realX);\r\n\t\t} else {\r\n\t\t\tuint256 ratioX = feeCollected0.mul(1e18).div(realX);\r\n\t\t\tuint256 ratioY = feeCollected1.mul(1e18).div(realY);\r\n\t\t\tif (ratioX < ratioY) {\r\n\t\t\t\tamount0 = feeCollected0;\r\n\t\t\t\tamount1 = feeCollected1.mul(ratioX).div(ratioY);\r\n\t\t\t} else {\r\n\t\t\t\tamount0 = feeCollected0.mul(ratioY).div(ratioX);\r\n\t\t\t\tamount1 = feeCollected1;\r\n\t\t\t}\r\n\t\t\tnewLiquidity = Math.min(liquidity.mul(amount0).div(realX), liquidity.mul(amount1).div(realY));\r\n\t\t}\r\n\t}\r\n\t\r\n\tstruct AutocompoundData {\r\n\t\taddress pool;\r\n\t\tITokenizedUniswapV3Position.Position position;\r\n\t\tuint256 tokenId;\r\n\t\tuint256 collect0; \r\n\t\tuint256 collect1; \r\n\t\tuint256 newLiquidity;\r\n\t}\r\n\t\t\r\n\tfunction getToCollect(\r\n\t\tITokenizedUniswapV3Position.Position calldata position, \r\n\t\tuint256 tokenId, \r\n\t\tuint256 feeCollected0, \r\n\t\tuint256 feeCollected1\r\n\t) external returns (uint256 collect0, uint256 collect1, bytes memory data) {\r\n\t\t_checkCaller();\r\n\t\r\n\t\t// 1. Initialize\r\n\t\taddress pool = ITokenizedUniswapV3Position(msg.sender).getPool(position.fee);\r\n\t\t(uint160 priceSqrtX96,,,,,,) = IUniswapV3Pool(pool).slot0();\r\n\t\tuint256 reinvestBounty = _getBounty(msg.sender, tokenId);\r\n\r\n\t\t// 2. Read position proportion\r\n\t\t(uint256 realX, uint256 realY) = LiquidityAmounts.getAmountsForLiquidity(\r\n\t\t\tpriceSqrtX96, \r\n\t\t\tposition.tickLower.getSqrtRatioAtTick(), \r\n\t\t\tposition.tickUpper.getSqrtRatioAtTick(), \r\n\t\t\tposition.liquidity\r\n\t\t);\r\n\t\t\r\n\t\t// 3. Calculate how much of the earned fee we can compound for each side\r\n\t\tuint256 newLiquidity;\r\n\t\t(newLiquidity, collect0, collect1) = _getReinvestAmounts(position.liquidity, realX, realY, feeCollected0, feeCollected1);\r\n\t\tnewLiquidity = newLiquidity.mul(1e18 - reinvestBounty).div(1e18);\r\n\t\t\r\n\t\tdata = abi.encode(AutocompoundData({\r\n\t\t\tpool: pool,\r\n\t\t\tposition: position,\r\n\t\t\ttokenId: tokenId,\r\n\t\t\tcollect0: collect0,\r\n\t\t\tcollect1: collect1,\r\n\t\t\tnewLiquidity: newLiquidity\r\n\t\t}));\r\n\t}\r\n\t\r\n\tfunction mintLiquidity(\r\n\t\taddress bountyTo, \r\n\t\tbytes calldata data\r\n\t) external returns (uint256 bounty0, uint256 bounty1) {\r\n\t\t(address token0, address token1) = _checkCaller();\r\n\t\tAutocompoundData memory d = abi.decode(data, (AutocompoundData));\r\n\t\t\r\n\t\t(uint256 amount0, uint256 amount1) = IUniswapV3Pool(d.pool).mint(msg.sender, d.position.tickLower, d.position.tickUpper, safe128(d.newLiquidity), abi.encode(d.position.fee, token0, token1));\r\n\r\n\t\tuint256 protocolShare = reservesManager != address(0) ? PROTOCOL_SHARE : 0;\r\n\t\tbounty0 = d.collect0.sub(amount0).mul(1e18 - protocolShare).div(1e18);\r\n\t\tbounty1 = d.collect1.sub(amount1).mul(1e18 - protocolShare).div(1e18);\r\n\t\tif (bounty0 > 0) TransferHelper.safeTransfer(token0, bountyTo, bounty0);\r\n\t\tif (bounty1 > 0) TransferHelper.safeTransfer(token1, bountyTo, bounty1);\r\n\t}\r\n\t\r\n\tfunction uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external {\t\r\n\t\t(uint24 fee, address token0, address token1) = abi.decode(data, (uint24, address, address));\r\n\t\trequire(\r\n\t\t\tIUniswapV3Factory(uniswapV3Factory).getPool(token0, token1, fee) == msg.sender,\r\n\t\t\t\"UniswapV3AC01: UNAUTHORIZED_CALLER\"\r\n\t\t);\r\n\t\t\r\n\t\tif (amount0Owed > 0) TransferHelper.safeTransfer(token0, msg.sender, amount0Owed);\r\n\t\tif (amount1Owed > 0) TransferHelper.safeTransfer(token1, msg.sender, amount1Owed);\r\n\t}\r\n\t\r\n\t/*** Reserves Manager ***/\r\n\t\r\n\tfunction _setReservesPendingAdmin(address newReservesPendingAdmin) external {\r\n\t\trequire(msg.sender == reservesAdmin, \"TokenizedUniswapV3Factory: UNAUTHORIZED\");\r\n\t\taddress oldReservesPendingAdmin = reservesPendingAdmin;\r\n\t\treservesPendingAdmin = newReservesPendingAdmin;\r\n\t\temit NewReservesPendingAdmin(oldReservesPendingAdmin, newReservesPendingAdmin);\r\n\t}\r\n\r\n\tfunction _acceptReservesAdmin() external {\r\n\t\trequire(msg.sender == reservesPendingAdmin, \"TokenizedUniswapV3Factory: UNAUTHORIZED\");\r\n\t\taddress oldReservesAdmin = reservesAdmin;\r\n\t\taddress oldReservesPendingAdmin = reservesPendingAdmin;\r\n\t\treservesAdmin = reservesPendingAdmin;\r\n\t\treservesPendingAdmin = address(0);\r\n\t\temit NewReservesAdmin(oldReservesAdmin, reservesAdmin);\r\n\t\temit NewReservesPendingAdmin(oldReservesPendingAdmin, address(0));\r\n\t}\r\n\r\n\tfunction _setReservesManager(address newReservesManager) external {\r\n\t\trequire(msg.sender == reservesAdmin, \"TokenizedUniswapV3Factory: UNAUTHORIZED\");\r\n\t\taddress oldReservesManager = reservesManager;\r\n\t\treservesManager = newReservesManager;\r\n\t\temit NewReservesManager(oldReservesManager, newReservesManager);\r\n\t}\r\n\t\r\n\tfunction claimToken(address token) public {\r\n\t\tuint256 amount = IERC20(token).balanceOf(address(this));\r\n\t\tif (amount > 0) TransferHelper.safeTransfer(token, reservesManager, amount);\r\n\t}\r\n\tfunction claimTokens(address[] calldata tokens) external {\r\n\t\tfor (uint i = 0; i < tokens.length; i++) {\r\n\t\t\tclaimToken(tokens[i]);\r\n\t\t}\r\n\t}\r\n\t\r\n\t/*** Utilities ***/\r\n\r\n    function safe128(uint n) internal pure returns (uint128) {\r\n        require(n < 2**128, \"Impermax: SAFE128\");\r\n        return uint128(n);\r\n    }\r\n}",
  "abi": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapV3Factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenizedUniswapV3Factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reservesAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reservesManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldReservesAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReservesAdmin\",\"type\":\"address\"}],\"name\":\"NewReservesAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldReservesManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReservesManager\",\"type\":\"address\"}],\"name\":\"NewReservesManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldReservesPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReservesPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewReservesPendingAdmin\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BOUNTY_T\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_REINVEST_BOUNTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROTOCOL_SHARE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptReservesAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReservesManager\",\"type\":\"address\"}],\"name\":\"_setReservesManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReservesPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setReservesPendingAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside0LastX128\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside1LastX128\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unclaimedFees0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unclaimedFees1\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenizedUniswapV3Position.Position\",\"name\":\"position\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeCollected0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeCollected1\",\"type\":\"uint256\"}],\"name\":\"getToCollect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collect0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collect1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"bountyTo\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mintLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bounty0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bounty1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservesAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservesManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservesPendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenizedUniswapV3Factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapV3Factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Owed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Owed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3MintCallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
  "contract_name": "UniswapV3AC01",
  "compiler_version": "v0.5.16+commit.9c3226ce",
  "optimization_used": "1",
  "runs": "999999",
  "constructor_arguments": "00000000000000000000000033128a8fc17869897dce68ed026d694621f6fdfd000000000000000000000000e5d6cf969c01bf8d6c46840ed784d7f209038d7a0000000000000000000000009fd93712400902bff6040efa72b28bf80152f056000000000000000000000000d3080518e5678dc5464b7d4079d1046929985c59",
  "evm_version": "Default",
  "library": "",
  "license_type": "BSL 1.1",
  "proxy": "0",
  "implementation": "",
  "bytecode": null
}