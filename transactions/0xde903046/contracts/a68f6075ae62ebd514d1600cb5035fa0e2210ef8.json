{
  "address": "0xa68f6075ae62ebd514d1600cb5035fa0e2210ef8",
  "has_source_code": true,
  "source_code": "// File: contracts\\libraries\\SafeMath.sol\r\n\r\npragma solidity =0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC721.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC721 {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\t\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction nonces(uint256 tokenId) external view returns (uint256);\r\n\t\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\tfunction setApprovalForAll(address operator, bool approved) external;\r\n\tfunction permit(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC721Receiver.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts\\ImpermaxERC721.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract ImpermaxERC721 is IERC721 {\r\n\tusing SafeMath for uint;\r\n\t\r\n\tstring public name;\r\n\tstring public symbol;\r\n\t\r\n\tmapping(address => uint) public balanceOf;\r\n\tmapping(uint256 => address) internal _ownerOf;\r\n\tmapping(uint256 => address) public getApproved;\r\n\tmapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\t\r\n\tbytes32 public DOMAIN_SEPARATOR;\r\n\tmapping(uint256 => uint) public nonces;\r\n\r\n\tconstructor() public {}\r\n\t\r\n\tfunction _setName(string memory _name, string memory _symbol) internal {\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n\t\t\r\n\t\tuint chainId;\r\n\t\tassembly {\r\n\t\t\tchainId := chainid\r\n\t\t}\r\n\t\tDOMAIN_SEPARATOR = keccak256(\r\n\t\t\tabi.encode(\r\n\t\t\t\tkeccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n\t\t\t\tkeccak256(bytes(_name)),\r\n\t\t\t\tkeccak256(bytes(\"1\")),\r\n\t\t\t\tchainId,\r\n\t\t\t\taddress(this)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\t\r\n\tfunction _isAuthorized(address owner, address operator, uint256 tokenId) internal view returns (bool) {\r\n\t\treturn operator != address(0) && (owner == operator || isApprovedForAll[owner][operator] || getApproved[tokenId] == operator);\r\n\t}\r\n\r\n\tfunction _checkAuthorized(address owner, address operator, uint256 tokenId) internal view {\r\n\t\trequire(_isAuthorized(owner, operator, tokenId), \"ImpermaxERC721: UNAUTHORIZED\");\r\n\t}\r\n\r\n\tfunction _update(address to, uint256 tokenId, address auth) internal returns (address from) {\r\n\t\tfrom = _ownerOf[tokenId];\r\n\t\tif (auth != address(0)) _checkAuthorized(from, auth, tokenId);\r\n\r\n\t\tif (from != address(0)) {\r\n\t\t\t_approve(address(0), tokenId, address(0));\r\n\t\t\tbalanceOf[from] -= 1;\r\n\t\t}\r\n\r\n\t\tif (to != address(0)) {\r\n\t\t\tbalanceOf[to] += 1;\r\n\t\t}\r\n\r\n\t\t_ownerOf[tokenId] = to;\r\n\t\temit Transfer(from, to, tokenId);\r\n\t}\r\n\t\r\n\tfunction _mint(address to, uint256 tokenId) internal {\r\n\t\trequire(to != address(0), \"ImpermaxERC721: INVALID_RECEIVER\");\r\n\t\taddress previousOwner = _update(to, tokenId, address(0));\r\n\t\trequire(previousOwner == address(0), \"ImpermaxERC721: INVALID_SENDER\");\r\n\t}\r\n\tfunction _safeMint(address to, uint256 tokenId) internal {\r\n\t\t_safeMint(to, tokenId, \"\");\r\n\t}\r\n\tfunction _safeMint(address to, uint256 tokenId, bytes memory data) internal {\r\n\t\t_mint(to, tokenId);\r\n\t\t_checkOnERC721Received(address(0), to, tokenId, data);\r\n\t}\r\n\t\r\n\tfunction _burn(uint256 tokenId) internal {\r\n\t\taddress previousOwner = _update(address(0), tokenId, address(0));\r\n\t\trequire(previousOwner != address(0), \"ImpermaxERC721: NONEXISTENT_TOKEN\");\r\n\t}\r\n\t\r\n\tfunction _transfer(address from, address to, uint256 tokenId, address auth) internal {\r\n\t\trequire(to != address(0), \"ImpermaxERC721: INVALID_RECEIVER\");\r\n\t\taddress previousOwner = _update(to, tokenId, auth);\r\n\t\trequire(previousOwner != address(0), \"ImpermaxERC721: NONEXISTENT_TOKEN\");\r\n\t\trequire(previousOwner == from, \"ImpermaxERC721: INCORRECT_OWNER\");\r\n\t}\r\n\t\r\n\tfunction _safeTransfer(address from, address to, uint256 tokenId, address auth) internal {\r\n\t\t_safeTransfer(from, to, tokenId, \"\", auth);\r\n\t}\r\n\tfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory data, address auth) internal {\r\n\t\t_transfer(from, to, tokenId, auth);\r\n\t\t_checkOnERC721Received(from, to, tokenId, data);\r\n\t}\r\n\r\n\tfunction _approve(address to, uint256 tokenId, address auth) internal {\r\n\t\taddress owner = _requireOwned(tokenId);\r\n\t\trequire(auth == address(0) || auth == owner || isApprovedForAll[owner][auth], \"ImpermaxERC721: INVALID_APPROVER\");\r\n\t\tgetApproved[tokenId] = to;\r\n\t\temit Approval(owner, to, tokenId);\r\n\t}\r\n\r\n\tfunction _setApprovalForAll(address owner, address operator, bool approved) internal {\r\n\t\trequire(operator != address(0), \"ImpermaxERC721: INVALID_OPERATOR\");\r\n\t\tisApprovedForAll[owner][operator] = approved;\r\n\t\temit ApprovalForAll(owner, operator, approved);\r\n\t}\r\n\t\r\n\tfunction _requireOwned(uint256 tokenId) internal view returns (address) {\r\n\t\taddress owner = _ownerOf[tokenId];\r\n\t\trequire(owner != address(0), \"ImpermaxERC721: NONEXISTENT_TOKEN\");\r\n\t\treturn owner;\r\n\t}\r\n\t\r\n\tfunction _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) internal {\r\n\t\tif (isContract(to)) {\r\n\t\t\tbytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data);\r\n\t\t\trequire(retval == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")), \"ImpermaxERC721: INVALID_RECEIVER\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address) {\r\n\t\treturn _requireOwned(tokenId);\r\n\t}\r\n\t\r\n\tfunction approve(address to, uint256 tokenId) external {\r\n\t\t_approve(to, tokenId, msg.sender);\r\n\t}\r\n\t\r\n\tfunction setApprovalForAll(address operator, bool approved) external {\r\n\t\t_setApprovalForAll(msg.sender, operator, approved);\r\n\t}\r\n\t\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external {\r\n\t\t_transfer(from, to, tokenId, msg.sender);\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external {\r\n\t\t_safeTransfer(from, to, tokenId, msg.sender);\r\n\t}\r\n\t\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external {\r\n\t\t_safeTransfer(from, to, tokenId, data, msg.sender);\r\n\t}\r\n\t\r\n\tfunction _checkSignature(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s, bytes32 typehash) internal {\r\n\t\trequire(deadline >= block.timestamp, \"ImpermaxERC721: EXPIRED\");\r\n\t\tbytes32 digest = keccak256(\r\n\t\t\tabi.encodePacked(\r\n\t\t\t\t'\\x19\\x01',\r\n\t\t\t\tDOMAIN_SEPARATOR,\r\n\t\t\t\tkeccak256(abi.encode(typehash, spender, tokenId, nonces[tokenId]++, deadline))\r\n\t\t\t)\r\n\t\t);\r\n\t\taddress owner = _requireOwned(tokenId);\r\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\r\n\t\trequire(recoveredAddress == owner, \"ImpermaxERC721: INVALID_SIGNATURE\");\t\r\n\t}\r\n\r\n\t// keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\r\n\tbytes32 public constant PERMIT_TYPEHASH = 0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\r\n\tfunction permit(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n\t\t_checkSignature(spender, tokenId, deadline, v, r, s, PERMIT_TYPEHASH);\r\n\t\t_approve(spender, tokenId, address(0));\r\n\t}\r\n\t\r\n\t/* Utilities */\r\n\tfunction isContract(address _addr) private view returns (bool){\r\n\t\tuint32 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (size > 0);\r\n\t}\r\n}\r\n\r\n// File: contracts\\interfaces\\INFTLP.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface INFTLP {\r\n\tstruct RealXY {\r\n\t\tuint256 realX;\r\n\t\tuint256 realY;\r\n\t}\r\n\t\r\n\tstruct RealXYs {\r\n\t\tRealXY lowestPrice;\r\n\t\tRealXY currentPrice;\r\n\t\tRealXY highestPrice;\r\n\t}\r\n\t\r\n\t// ERC-721\r\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\t\r\n\t// Global state\r\n\tfunction token0() external view returns (address);\r\n\tfunction token1() external view returns (address);\r\n\t\r\n\t// Position state\r\n\tfunction getPositionData(uint256 _tokenId, uint256 _safetyMarginSqrt) external returns (\r\n\t\tuint256 priceSqrtX96,\r\n\t\tRealXYs memory realXYs\r\n\t);\r\n\t\r\n\t// Interactions\r\n\t\r\n\tfunction split(uint256 tokenId, uint256 percentage) external returns (uint256 newTokenId);\r\n\tfunction join(uint256 tokenId, uint256 tokenToJoin) external;\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\IUniswapV3Factory.sol\r\n\r\n// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title The interface for the Uniswap V3 Factory\r\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\r\ninterface IUniswapV3Factory {\r\n    /// @notice Emitted when the owner of the factory is changed\r\n    /// @param oldOwner The owner before the owner was changed\r\n    /// @param newOwner The owner after the owner was changed\r\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// @notice Emitted when a pool is created\r\n    /// @param token0 The first token of the pool by address sort order\r\n    /// @param token1 The second token of the pool by address sort order\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\r\n    /// @param pool The address of the created pool\r\n    event PoolCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        uint24 indexed fee,\r\n        int24 tickSpacing,\r\n        address pool\r\n    );\r\n\r\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\r\n    /// @param fee The enabled fee, denominated in hundredths of a bip\r\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\r\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\r\n\r\n    /// @notice Returns the current owner of the factory\r\n    /// @dev Can be changed by the current owner via setOwner\r\n    /// @return The address of the factory owner\r\n    function owner() external view returns (address);\r\n\r\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\r\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\r\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\r\n    /// @return The tick spacing\r\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\r\n\r\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\r\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\r\n    /// @param tokenA The contract address of either token0 or token1\r\n    /// @param tokenB The contract address of the other token\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @return pool The pool address\r\n    function getPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external view returns (address pool);\r\n\r\n    /// @notice Creates a pool for the given two tokens and fee\r\n    /// @param tokenA One of the two tokens in the desired pool\r\n    /// @param tokenB The other of the two tokens in the desired pool\r\n    /// @param fee The desired fee for the pool\r\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\r\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\r\n    /// are invalid.\r\n    /// @return pool The address of the newly created pool\r\n    function createPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external returns (address pool);\r\n\r\n    /// @notice Updates the owner of the factory\r\n    /// @dev Must be called by the current owner\r\n    /// @param _owner The new owner of the factory\r\n    function setOwner(address _owner) external;\r\n\r\n    /// @notice Enables a fee amount with the given tickSpacing\r\n    /// @dev Fee amounts may never be removed once enabled\r\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\r\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\r\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\IUniswapV3Pool.sol\r\n\r\n// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV3Pool {\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function fee() external view returns (uint24);\r\n    function tickSpacing() external view returns (int24);\r\n    function maxLiquidityPerTick() external view returns (uint128);\r\n\t\r\n    function slot0()\r\n        external\r\n        view\r\n        returns (\r\n            uint160 sqrtPriceX96,\r\n            int24 tick,\r\n            uint16 observationIndex,\r\n            uint16 observationCardinality,\r\n            uint16 observationCardinalityNext,\r\n            uint8 feeProtocol,\r\n            bool unlocked\r\n        );\r\n\r\n    function feeGrowthGlobal0X128() external view returns (uint256);\r\n    function feeGrowthGlobal1X128() external view returns (uint256);\r\n    function protocolFees() external view returns (uint128, uint128);\r\n    function liquidity() external view returns (uint128);\r\n\r\n    function ticks(int24 tick)\r\n        external\r\n        view\r\n        returns (\r\n            uint128 liquidityGross,\r\n            int128 liquidityNet,\r\n            uint256 feeGrowthOutside0X128,\r\n            uint256 feeGrowthOutside1X128,\r\n            int56 tickCumulativeOutside,\r\n            uint160 secondsPerLiquidityOutsideX128,\r\n            uint32 secondsOutside,\r\n            bool initialized\r\n        );\r\n\r\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\r\n\r\n    function positions(bytes32 key)\r\n        external\r\n        view\r\n        returns (\r\n            uint128 _liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n\r\n    function observations(uint256 index)\r\n        external\r\n        view\r\n        returns (\r\n            uint32 blockTimestamp,\r\n            int56 tickCumulative,\r\n            uint160 secondsPerLiquidityCumulativeX128,\r\n            bool initialized\r\n        );\r\n\t\t\r\n    function observe(uint32[] calldata secondsAgos)\r\n        external\r\n        view\r\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\r\n\r\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\r\n        external\r\n        view\r\n        returns (\r\n            int56 tickCumulativeInside,\r\n            uint160 secondsPerLiquidityInsideX128,\r\n            uint32 secondsInside\r\n        );\r\n\t\t\r\n    function initialize(uint160 sqrtPriceX96) external;\r\n\r\n    function mint(\r\n        address recipient,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount,\r\n        bytes calldata data\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function collect(\r\n        address recipient,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount0Requested,\r\n        uint128 amount1Requested\r\n    ) external returns (uint128 amount0, uint128 amount1);\r\n\r\n    function burn(\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        address recipient,\r\n        bool zeroForOne,\r\n        int256 amountSpecified,\r\n        uint160 sqrtPriceLimitX96,\r\n        bytes calldata data\r\n    ) external returns (int256 amount0, int256 amount1);\r\n\t\r\n    function flash(\r\n        address recipient,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\ITokenizedUniswapV3Position.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ITokenizedUniswapV3Position {\r\n\t\r\n\t// ERC-721\r\n\t\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction nonces(uint256 tokenId) external view returns (uint256);\r\n\t\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\tfunction setApprovalForAll(address operator, bool approved) external;\r\n\tfunction permit(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t// INFTLP\r\n\t\r\n\tfunction token0() external view returns (address);\r\n\tfunction token1() external view returns (address);\r\n\tfunction getPositionData(uint256 _tokenId, uint256 _safetyMarginSqrt) external returns (\r\n\t\tuint256 priceSqrtX96,\r\n\t\tINFTLP.RealXYs memory realXYs\r\n\t);\r\n\t\r\n\tfunction join(uint256 tokenId, uint256 tokenToJoin) external;\r\n\tfunction split(uint256 tokenId, uint256 percentage) external returns (uint256 newTokenId);\r\n\t\r\n\t// ITokenizedUniswapV3Position\r\n\t\r\n\tstruct Position {\r\n\t\tuint24 fee;\r\n\t\tint24 tickLower;\r\n\t\tint24 tickUpper;\r\n\t\tuint128 liquidity;\r\n\t\tuint256 feeGrowthInside0LastX128;\r\n\t\tuint256 feeGrowthInside1LastX128;\r\n\t\tuint256 unclaimedFees0;\t\r\n\t\tuint256 unclaimedFees1;\t\r\n\t}\r\n\t\r\n\tfunction factory() external view returns (address);\r\n\tfunction uniswapV3Factory() external view returns (address);\r\n\t\r\n\tfunction totalBalance(uint24 fee, int24 tickLower, int24 tickUpper) external view returns (uint256);\r\n\t\r\n\tfunction positions(uint256 tokenId) external view returns (\r\n\t\tuint24 fee,\r\n\t\tint24 tickLower,\r\n\t\tint24 tickUpper,\r\n\t\tuint128 liquidity,\r\n\t\tuint256 feeGrowthInside0LastX128,\r\n\t\tuint256 feeGrowthInside1LastX128,\r\n\t\tuint256 unclaimedFees0,\r\n\t\tuint256 unclaimedFees1\r\n\t);\r\n\tfunction positionsLength() external view returns (uint256);\r\n\t\r\n\tfunction getPool(uint24 fee) external view returns (address pool);\r\n\t\r\n\tfunction oraclePriceSqrtX96() external returns (uint256);\r\n\t\r\n\tevent MintPosition(uint256 indexed tokenId, uint24 fee, int24 tickLower, int24 tickUpper);\r\n\tevent UpdatePositionLiquidity(uint256 indexed tokenId, uint256 liquidity);\r\n\tevent UpdatePositionFeeGrowthInside(uint256 indexed tokenId, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128);\r\n\tevent UpdatePositionUnclaimedFees(uint256 indexed tokenId, uint256 unclaimedFees0, uint256 unclaimedFees1);\r\n\r\n\tfunction _initialize (\r\n\t\taddress _uniswapV3Factory, \r\n\t\taddress _oracle, \r\n\t\taddress _token0, \r\n\t\taddress _token1\r\n\t) external;\r\n\t\r\n\tfunction mint(address to, uint24 fee, int24 tickLower, int24 tickUpper) external  returns (uint256 newTokenId);\r\n\tfunction redeem(address to, uint256 tokenId) external  returns (uint256 amount0, uint256 amount1);\r\n\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\IUniswapV3AC.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV3AC {\r\n\tfunction getToCollect(\r\n\t\tITokenizedUniswapV3Position.Position calldata position, \r\n\t\tuint256 tokenId, \r\n\t\tuint256 feeCollected0, \r\n\t\tuint256 feeCollected1\r\n\t) external returns (uint256 collect0, uint256 collect1, bytes memory data);\r\n\t\r\n\tfunction mintLiquidity(\r\n\t\taddress bountyTo, \r\n\t\tbytes calldata data\r\n\t) external returns (uint256 bounty0, uint256 bounty1);\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\IV3Oracle.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IV3Oracle {\r\n\tfunction oraclePriceSqrtX96(address token0, address token1) external returns (uint256);\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\ITokenizedUniswapV3Factory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ITokenizedUniswapV3Factory {\r\n\tevent NFTLPCreated(address indexed token0, address indexed token1, address NFTLP, uint);\r\n\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\tevent NewAdmin(address oldAdmin, address newAdmin);\r\n\tevent NewAcModule(address oldAcModule, address newAcModule);\r\n\t\r\n\tfunction admin() external view returns (address);\r\n\tfunction pendingAdmin() external view returns (address);\r\n\t\r\n\tfunction uniswapV3Factory() external view returns (address);\r\n\tfunction deployer() external view returns (address);\r\n\tfunction oracle() external view returns (address);\r\n\tfunction acModule() external view returns (address);\r\n\t\r\n\tfunction getNFTLP(address tokenA, address tokenB) external view returns (address);\r\n\tfunction allNFTLP(uint) external view returns (address);\r\n\tfunction allNFTLPLength() external view returns (uint);\r\n\t\r\n\tfunction createNFTLP(address tokenA, address tokenB) external returns (address NFTLP);\r\n\t\r\n\tfunction _setPendingAdmin(address newPendingAdmin) external;\r\n\tfunction _acceptAdmin() external;\r\n\tfunction _setAcModule(address newAcModule) external;\r\n}\r\n\r\n// File: contracts\\libraries\\FullMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.0 <0.8.0;\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = a * b\r\n        // Compute the product mod 2**256 and mod 2**256 - 1\r\n        // then use the Chinese Remainder Theorem to reconstruct\r\n        // the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2**256 + prod0\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(a, b, not(0))\r\n            prod0 := mul(a, b)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division\r\n        if (prod1 == 0) {\r\n            require(denominator > 0);\r\n            assembly {\r\n                result := div(prod0, denominator)\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2**256.\r\n        // Also prevents denominator == 0\r\n        require(denominator > prod1);\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0]\r\n        // Compute remainder using mulmod\r\n        uint256 remainder;\r\n        assembly {\r\n            remainder := mulmod(a, b, denominator)\r\n        }\r\n        // Subtract 256 bit number from 512 bit number\r\n        assembly {\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator\r\n        // Compute largest power of two divisor of denominator.\r\n        // Always >= 1.\r\n        uint256 twos = -denominator & denominator;\r\n        // Divide denominator by power of two\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        // Divide [prod1 prod0] by the factors of two\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n        // Shift in bits from prod1 into prod0. For this we need\r\n        // to flip `twos` such that it is 2**256 / twos.\r\n        // If twos is zero, then it becomes one\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        prod0 |= prod1 * twos;\r\n\r\n        // Invert denominator mod 2**256\r\n        // Now that denominator is an odd number, it has an inverse\r\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n        // Compute the inverse by starting with a seed that is correct\r\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n        uint256 inv = (3 * denominator) ^ 2;\r\n        // Now use Newton-Raphson iteration to improve the precision.\r\n        // Thanks to Hensel's lifting lemma, this also works in modular\r\n        // arithmetic, doubling the correct bits in each step.\r\n        inv *= 2 - denominator * inv; // inverse mod 2**8\r\n        inv *= 2 - denominator * inv; // inverse mod 2**16\r\n        inv *= 2 - denominator * inv; // inverse mod 2**32\r\n        inv *= 2 - denominator * inv; // inverse mod 2**64\r\n        inv *= 2 - denominator * inv; // inverse mod 2**128\r\n        inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n        // Because the division is now exact we can divide by multiplying\r\n        // with the modular inverse of denominator. This will give us the\r\n        // correct result modulo 2**256. Since the precoditions guarantee\r\n        // that the outcome is less than 2**256, this is the final result.\r\n        // We don't need to compute the high bits of the result and prod1\r\n        // is no longer required.\r\n        result = prod0 * inv;\r\n        return result;\r\n    }\r\n\r\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        result = mulDiv(a, b, denominator);\r\n        if (mulmod(a, b, denominator) > 0) {\r\n            require(result < uint256(-1));\r\n            result++;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\extensions\\libraries\\LiquidityAmounts.sol\r\n\r\n// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Liquidity amount functions\r\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\r\nlibrary LiquidityAmounts {\r\n    uint constant Q96 = 2**96;\r\n\t\r\n    /// @notice Downcasts uint256 to uint128\r\n    /// @param x The uint258 to be downcasted\r\n    /// @return y The passed value, downcasted to uint128\r\n    function toUint128(uint256 x) private pure returns (uint128 y) {\r\n        require((y = uint128(x)) == x);\r\n    }\r\n\r\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\r\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount0 The amount0 being sent in\r\n    /// @return liquidity The amount of returned liquidity\r\n    function getLiquidityForAmount0(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\r\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\r\n    }\r\n\r\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\r\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount1 The amount1 being sent in\r\n    /// @return liquidity The amount of returned liquidity\r\n    function getLiquidityForAmount1(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        return toUint128(FullMath.mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\r\n    }\r\n\r\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\r\n    /// pool prices and the prices at the tick boundaries\r\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount0 The amount of token0 being sent in\r\n    /// @param amount1 The amount of token1 being sent in\r\n    /// @return liquidity The maximum amount of liquidity received\r\n    function getLiquidityForAmounts(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\r\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\r\n\r\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\r\n        } else {\r\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\r\n        }\r\n    }\r\n\r\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount0 The amount of token0\r\n    function getAmount0ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return\r\n            FullMath.mulDiv(\r\n                uint256(liquidity) << 96,\r\n                sqrtRatioBX96 - sqrtRatioAX96,\r\n                sqrtRatioBX96\r\n            ) / sqrtRatioAX96;\r\n    }\r\n\r\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount1 The amount of token1\r\n    function getAmount1ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\r\n    }\r\n\r\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\r\n    /// pool prices and the prices at the tick boundaries\r\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount0 The amount of token0\r\n    /// @return amount1 The amount of token1\r\n    function getAmountsForLiquidity(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\r\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\r\n        } else {\r\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\extensions\\libraries\\UniswapV3Position.sol\r\n\r\n// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0 <0.8.0;\r\n\r\n/// @title Position\r\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\r\n/// @dev Positions store additional state for tracking fees owed to the position\r\nlibrary UniswapV3Position {\r\n    // info stored for each user's position\r\n    struct Info {\r\n        // the amount of liquidity owned by this position\r\n        uint128 liquidity;\r\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\r\n        uint256 feeGrowthInside0LastX128;\r\n        uint256 feeGrowthInside1LastX128;\r\n        // the fees owed to the position owner in token0/token1\r\n        uint128 tokensOwed0;\r\n        uint128 tokensOwed1;\r\n    }\r\n\r\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\r\n    /// @param owner The address of the position owner\r\n    /// @param tickLower The lower tick boundary of the position\r\n    /// @param tickUpper The upper tick boundary of the position\r\n    /// @return hash of the position\r\n    function getHash(\r\n        address owner,\r\n        int24 tickLower,\r\n        int24 tickUpper\r\n    ) internal view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));\r\n    }\r\n}\r\n\r\n// File: contracts\\extensions\\libraries\\TickMath.sol\r\n\r\n// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0 <0.8.0;\r\n\r\n/// @title Math library for computing sqrt prices from ticks and vice versa\r\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\r\n/// prices between 2**-128 and 2**128\r\nlibrary TickMath {\r\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n    int24 internal constant MIN_TICK = -887272;\r\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\r\n\r\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n    /// @dev Throws if |tick| > max tick\r\n    /// @param tick The input tick for the above formula\r\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n    /// at the given tick\r\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\r\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\r\n        require(absTick <= uint256(MAX_TICK), 'TickMath: T');\r\n\r\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\r\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n        if (tick > 0) ratio = uint256(-1) / ratio;\r\n\r\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\r\n    }\r\n\r\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\r\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\r\n    /// ever return.\r\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\r\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\r\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\r\n        // second inequality must be < because the price can never reach the price at the max tick\r\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'TickMath: R');\r\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\r\n\r\n        uint256 r = ratio;\r\n        uint256 msb = 0;\r\n\r\n        assembly {\r\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(5, gt(r, 0xFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(4, gt(r, 0xFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(3, gt(r, 0xFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(2, gt(r, 0xF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(1, gt(r, 0x3))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := gt(r, 0x1)\r\n            msb := or(msb, f)\r\n        }\r\n\r\n        if (msb >= 128) r = ratio >> (msb - 127);\r\n        else r = ratio << (127 - msb);\r\n\r\n        int256 log_2 = (int256(msb) - 128) << 64;\r\n\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(63, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(62, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(61, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(60, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(59, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(58, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(57, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(56, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(55, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(54, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(53, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(52, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(51, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(50, f))\r\n        }\r\n\r\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\r\n\r\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\r\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\r\n\r\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\r\n    }\r\n}\r\n\r\n// File: contracts\\extensions\\TokenizedUniswapV3Position.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract TokenizedUniswapV3Position is ITokenizedUniswapV3Position, INFTLP, ImpermaxERC721 {\r\n\tusing TickMath for int24;\r\n\t\r\n    uint constant Q128 = 2**128;\r\n\r\n\tuint256 public constant FEE_COLLECTED_WEIGHT = 0.95e18; // 95%\r\n\t\r\n\taddress public factory;\r\n\taddress public uniswapV3Factory;\r\n\taddress public oracle;\r\n\taddress public token0;\r\n\taddress public token1;\r\n\t\r\n\tmapping(uint24 => \r\n\t\tmapping(int24 => \r\n\t\t\tmapping(int24 => uint256)\r\n\t\t)\r\n\t) public totalBalance;\r\n\t\r\n\tmapping(uint256 => Position) public positions;\r\n\tuint256 public positionsLength;\r\n\t\t\r\n\t/*** Global state ***/\r\n\t\r\n\t// called once by the factory at the time of deployment\r\n\tfunction _initialize (\r\n\t\taddress _uniswapV3Factory, \r\n\t\taddress _oracle, \r\n\t\taddress _token0, \r\n\t\taddress _token1\r\n\t) external {\r\n\t\trequire(factory == address(0), \"Impermax: FACTORY_ALREADY_SET\"); // sufficient check\r\n\t\tfactory = msg.sender;\r\n\t\t_setName(\"Tokenized Uniswap V3\", \"NFT-UNI-V3\");\r\n\t\tuniswapV3Factory = _uniswapV3Factory;\r\n\t\toracle = _oracle;\r\n\t\ttoken0 = _token0;\r\n\t\ttoken1 = _token1;\r\n\t\t\r\n\t\t// quickly check if the oracle support this tokens pair\r\n\t\toraclePriceSqrtX96();\r\n\t}\r\n\t\r\n\tfunction getPool(uint24 fee) public view returns (address pool) {\r\n\t\tpool = IUniswapV3Factory(uniswapV3Factory).getPool(token0, token1, fee);\r\n\t\trequire(pool != address(0), \"TokenizedUniswapV3Position: UNSUPPORTED_FEE\");\r\n\t}\r\n\t\r\n\tfunction _updateBalance(uint24 fee, int24 tickLower, int24 tickUpper) internal {\r\n\t\taddress pool = getPool(fee);\r\n\t\tbytes32 hash = UniswapV3Position.getHash(address(this), tickLower, tickUpper);\r\n\t\t(uint balance,,,,) = IUniswapV3Pool(pool).positions(hash);\r\n\t\ttotalBalance[fee][tickLower][tickUpper] = balance;\r\n\t}\r\n\t\r\n\tfunction oraclePriceSqrtX96() public returns (uint256) {\r\n\t\treturn IV3Oracle(oracle).oraclePriceSqrtX96(token0, token1);\r\n\t}\r\n \r\n\t/*** Position state ***/\r\n\t\r\n\t// this assumes that the position fee growth snapshot has already been updated through burn()\r\n\tfunction _getfeeCollectedAndGrowth(Position memory position, address pool) internal view returns (uint256 fg0, uint256 fg1, uint256 feeCollected0, uint256 feeCollected1) {\r\n\t\tbytes32 hash = UniswapV3Position.getHash(address(this), position.tickLower, position.tickUpper);\r\n\t\t(,fg0, fg1,,) = IUniswapV3Pool(pool).positions(hash);\r\n\t\t\r\n\t\tuint256 delta0 = fg0 - position.feeGrowthInside0LastX128;\r\n\t\tuint256 delta1 = fg1 - position.feeGrowthInside1LastX128;\r\n\t\t\r\n\t\tfeeCollected0 = delta0.mul(position.liquidity).div(Q128).add(position.unclaimedFees0);\r\n\t\tfeeCollected1 = delta1.mul(position.liquidity).div(Q128).add(position.unclaimedFees1);\r\n\t}\r\n\tfunction _getFeeCollected(Position memory position, address pool) internal view returns (uint256 feeCollected0, uint256 feeCollected1) {\r\n\t\t(,,feeCollected0, feeCollected1) = _getfeeCollectedAndGrowth(position, pool);\r\n\t}\r\n\t\r\n\tfunction getPositionData(uint256 tokenId, uint256 safetyMarginSqrt) external returns (\r\n\t\tuint256 priceSqrtX96,\r\n\t\tINFTLP.RealXYs memory realXYs\r\n\t) {\r\n\t\tPosition memory position = positions[tokenId];\r\n\t\t\r\n\t\t// trigger update of fee growth\r\n\t\taddress pool = getPool(position.fee);\r\n\t\tIUniswapV3Pool(pool).burn(position.tickLower, position.tickUpper, 0);\r\n\t\t(uint256 feeCollectedX, uint256 feeCollectedY) = _getFeeCollected(position, pool);\r\n\t\r\n\t\trequire(safetyMarginSqrt >= 1e18, \"TokenizedUniswapV3Position: INVALID_SAFETY_MARGIN\");\r\n\t\t_requireOwned(tokenId);\r\n\t\t\r\n\t\tuint160 pa = position.tickLower.getSqrtRatioAtTick();\r\n\t\tuint160 pb = position.tickUpper.getSqrtRatioAtTick();\r\n\t\t\r\n\t\tpriceSqrtX96 = oraclePriceSqrtX96();\r\n\t\tuint160 currentPrice = safe160(priceSqrtX96);\r\n\t\tuint160 lowestPrice = safe160(priceSqrtX96.mul(1e18).div(safetyMarginSqrt));\r\n\t\tuint160 highestPrice = safe160(priceSqrtX96.mul(safetyMarginSqrt).div(1e18));\r\n\t\t\r\n\t\t(realXYs.lowestPrice.realX, realXYs.lowestPrice.realY) = LiquidityAmounts.getAmountsForLiquidity(lowestPrice, pa, pb, position.liquidity);\r\n\t\t(realXYs.currentPrice.realX, realXYs.currentPrice.realY) = LiquidityAmounts.getAmountsForLiquidity(currentPrice, pa, pb, position.liquidity);\r\n\t\t(realXYs.highestPrice.realX, realXYs.highestPrice.realY) = LiquidityAmounts.getAmountsForLiquidity(highestPrice, pa, pb, position.liquidity);\r\n\t\t\r\n\t\tuint256 feeCollectedWeightedX = feeCollectedX.mul(FEE_COLLECTED_WEIGHT).div(1e18);\r\n\t\tuint256 feeCollectedWeightedY = feeCollectedY.mul(FEE_COLLECTED_WEIGHT).div(1e18);\r\n\t\t\r\n\t\trealXYs.lowestPrice.realX += feeCollectedWeightedX;\r\n\t\trealXYs.lowestPrice.realY += feeCollectedWeightedY; \r\n\t\trealXYs.currentPrice.realX += feeCollectedX;\r\n\t\trealXYs.currentPrice.realY += feeCollectedY;\r\n\t\trealXYs.highestPrice.realX += feeCollectedWeightedX;\r\n\t\trealXYs.highestPrice.realY += feeCollectedWeightedY;\r\n\t}\r\n \r\n\t/*** Interactions ***/\r\n\t\r\n\t// this low-level function should be called from another contract\r\n\tfunction mint(address to, uint24 fee, int24 tickLower, int24 tickUpper) external nonReentrant returns (uint256 newTokenId) {\r\n\t\taddress pool = getPool(fee);\t\t\r\n\t\tbytes32 hash = UniswapV3Position.getHash(address(this), tickLower, tickUpper);\r\n\t\t(uint balance, uint256 fg0, uint256 fg1,,) = IUniswapV3Pool(pool).positions(hash);\r\n\t\tuint liquidity = balance.sub(totalBalance[fee][tickLower][tickUpper]);\r\n\t\t\r\n\t\tnewTokenId = positionsLength++;\r\n\t\t_mint(to, newTokenId);\t\t\r\n\t\tpositions[newTokenId] = Position({\r\n\t\t\tfee: fee,\r\n\t\t\ttickLower: tickLower,\r\n\t\t\ttickUpper: tickUpper,\r\n\t\t\tliquidity: safe128(liquidity),\r\n\t\t\tfeeGrowthInside0LastX128: fg0,\r\n\t\t\tfeeGrowthInside1LastX128: fg1,\r\n\t\t\tunclaimedFees0: 0,\r\n\t\t\tunclaimedFees1: 0\r\n\t\t});\r\n\t\t\r\n\t\t_updateBalance(fee, tickLower, tickUpper);\r\n\t\t\r\n\t\temit MintPosition(newTokenId, fee, tickLower, tickUpper);\r\n\t\temit UpdatePositionLiquidity(newTokenId, liquidity);\r\n\t\temit UpdatePositionFeeGrowthInside(newTokenId, fg0, fg1);\r\n\t\temit UpdatePositionUnclaimedFees(newTokenId, 0, 0);\r\n\t}\r\n\r\n\t// this low-level function should be called from another contract\r\n\tfunction redeem(address to, uint256 tokenId) external nonReentrant returns (uint256 amount0, uint256 amount1) {\r\n\t\t_checkAuthorized(_requireOwned(tokenId), msg.sender, tokenId);\r\n\t\t\r\n\t\tPosition memory position = positions[tokenId];\r\n\t\tdelete positions[tokenId];\r\n\t\t_burn(tokenId);\r\n\t\t\r\n\t\taddress pool = getPool(position.fee);\t\t\r\n\t\t(amount0, amount1) = IUniswapV3Pool(pool).burn(position.tickLower, position.tickUpper, position.liquidity);\r\n\t\t_updateBalance(position.fee, position.tickLower, position.tickUpper);\r\n\t\t\r\n\t\t(uint256 feeCollected0, uint256 feeCollected1) = _getFeeCollected(position, pool);\r\n\t\tamount0 = amount0.add(feeCollected0);\r\n\t\tamount1 = amount1.add(feeCollected1);\r\n\r\n\t\t(amount0, amount1) = IUniswapV3Pool(pool).collect(to, position.tickLower, position.tickUpper, safe128(amount0), safe128(amount1));\r\n\t\t\r\n\t\temit UpdatePositionLiquidity(tokenId, 0);\r\n\t\temit UpdatePositionUnclaimedFees(tokenId, 0, 0);\r\n\t}\r\n\t\r\n\tfunction _splitUint(uint256 n, uint256 percentage) internal pure returns (uint256 a, uint256 b) {\r\n\t\ta = n.mul(percentage).div(1e18);\r\n\t\tb = n.sub(a);\r\n\t}\r\n\tfunction split(uint256 tokenId, uint256 percentage) external nonReentrant returns (uint256 newTokenId) {\r\n\t\trequire(percentage <= 1e18, \"TokenizedUniswapV3Position: ABOVE_100_PERCENT\");\r\n\t\taddress owner = _requireOwned(tokenId);\r\n\t\t_checkAuthorized(owner, msg.sender, tokenId);\r\n\t\t_approve(address(0), tokenId, address(0)); // reset approval\r\n\t\t\r\n\t\tPosition memory oldPosition = positions[tokenId];\r\n\t\t(uint256 newLiquidity, uint256 oldLiquidity) = _splitUint(oldPosition.liquidity, percentage);\r\n\t\t(uint256 newUnclaimedFees0, uint256 oldUnclaimedFees0) = _splitUint(oldPosition.unclaimedFees0, percentage);\r\n\t\t(uint256 newUnclaimedFees1, uint256 oldUnclaimedFees1) = _splitUint(oldPosition.unclaimedFees1, percentage);\r\n\t\tpositions[tokenId].liquidity = safe128(oldLiquidity);\r\n\t\tpositions[tokenId].unclaimedFees0 = oldUnclaimedFees0;\r\n\t\tpositions[tokenId].unclaimedFees1 = oldUnclaimedFees1;\r\n\t\tnewTokenId = positionsLength++;\r\n\t\t_mint(owner, newTokenId);\r\n\t\tpositions[newTokenId] = Position({\r\n\t\t\tfee: oldPosition.fee,\r\n\t\t\ttickLower: oldPosition.tickLower,\r\n\t\t\ttickUpper: oldPosition.tickUpper,\r\n\t\t\tliquidity: safe128(newLiquidity),\r\n\t\t\tfeeGrowthInside0LastX128: oldPosition.feeGrowthInside0LastX128,\r\n\t\t\tfeeGrowthInside1LastX128: oldPosition.feeGrowthInside1LastX128,\r\n\t\t\tunclaimedFees0: newUnclaimedFees0,\r\n\t\t\tunclaimedFees1: newUnclaimedFees1\r\n\t\t});\r\n\t\t\r\n\t\temit UpdatePositionLiquidity(tokenId, oldLiquidity);\r\n\t\temit UpdatePositionUnclaimedFees(tokenId, oldUnclaimedFees0, oldUnclaimedFees1);\r\n\t\temit MintPosition(newTokenId, oldPosition.fee, oldPosition.tickLower, oldPosition.tickUpper);\r\n\t\temit UpdatePositionLiquidity(newTokenId, newLiquidity);\r\n\t\temit UpdatePositionUnclaimedFees(newTokenId, newUnclaimedFees0, newUnclaimedFees1);\r\n\t\temit UpdatePositionFeeGrowthInside(newTokenId, oldPosition.feeGrowthInside0LastX128, oldPosition.feeGrowthInside1LastX128);\r\n\t}\r\n\t\r\n\tfunction join(uint256 tokenId, uint256 tokenToJoin) external nonReentrant {\r\n\t\t_checkAuthorized(_requireOwned(tokenToJoin), msg.sender, tokenToJoin);\r\n\t\t\r\n\t\tPosition memory positionA = positions[tokenId];\r\n\t\tPosition memory positionB = positions[tokenToJoin];\r\n\t\t\r\n\t\trequire(tokenId != tokenToJoin, \"TokenizedUniswapV3Position: SAME_ID\");\r\n\t\trequire(positionA.fee == positionB.fee, \"TokenizedUniswapV3Position: INCOMPATIBLE_TOKENS_META\");\r\n\t\trequire(positionA.tickLower == positionB.tickLower, \"TokenizedUniswapV3Position: INCOMPATIBLE_TOKENS_META\");\r\n\t\trequire(positionA.tickUpper == positionB.tickUpper, \"TokenizedUniswapV3Position: INCOMPATIBLE_TOKENS_META\");\r\n\t\t\r\n\t\tuint256 newLiquidity = uint256(positionA.liquidity).add(positionB.liquidity);\r\n\t\t\r\n\t\t// update feeGrowthInside and feeCollected based on the latest snapshot\r\n\t\t// it's not necessary to call burn() in order to update the feeGrowthInside of the position\r\n\t\tuint256 newUnclaimedFees0; uint256 newUnclaimedFees1;\r\n\t\taddress pool = getPool(positionA.fee);\r\n\t\t(\r\n\t\t\tuint256 newFeeGrowthInside0LastX128, \r\n\t\t\tuint256 newFeeGrowthInside1LastX128, \r\n\t\t\tuint256 feeCollectedA0, \r\n\t\t\tuint256 feeCollectedA1\r\n\t\t) = _getfeeCollectedAndGrowth(positionA, pool);\r\n\t\t{\r\n\t\t(\r\n\t\t\tuint256 feeCollectedB0, \r\n\t\t\tuint256 feeCollectedB1\r\n\t\t) = _getFeeCollected(positionB, pool);\r\n\t\tnewUnclaimedFees0 = feeCollectedA0.add(feeCollectedB0);\r\n\t\tnewUnclaimedFees1 = feeCollectedA1.add(feeCollectedB1);\r\n\t\t}\r\n\t\t\r\n\t\tpositions[tokenId].liquidity = safe128(newLiquidity);\r\n\t\tpositions[tokenId].feeGrowthInside0LastX128 = newFeeGrowthInside0LastX128;\r\n\t\tpositions[tokenId].feeGrowthInside1LastX128 = newFeeGrowthInside1LastX128;\r\n\t\tpositions[tokenId].unclaimedFees0 = newUnclaimedFees0;\r\n\t\tpositions[tokenId].unclaimedFees1 = newUnclaimedFees1;\r\n\t\tdelete positions[tokenToJoin];\r\n\t\t_burn(tokenToJoin);\r\n\t\t\r\n\t\temit UpdatePositionLiquidity(tokenId, newLiquidity);\r\n\t\temit UpdatePositionFeeGrowthInside(tokenId, newFeeGrowthInside0LastX128, newFeeGrowthInside1LastX128);\r\n\t\temit UpdatePositionUnclaimedFees(tokenId, newUnclaimedFees0, newUnclaimedFees1);\r\n\t\temit UpdatePositionLiquidity(tokenToJoin, 0);\r\n\t\temit UpdatePositionUnclaimedFees(tokenToJoin, 0, 0);\r\n\t}\r\n\t\r\n\t/*** Autocompounding Module ***/\r\n\t\r\n\tfunction reinvest(uint256 tokenId, address bountyTo) external nonReentrant returns (uint256 bounty0, uint256 bounty1) {\r\n\t\t// 1. Initialize and read fee collected\r\n\t\taddress acModule = ITokenizedUniswapV3Factory(factory).acModule();\r\n\t\tPosition memory position = positions[tokenId];\r\n\t\tPosition memory newPosition = positions[tokenId];\r\n\t\tuint256 feeCollected0; uint256 feeCollected1;\r\n\t\taddress pool = getPool(position.fee);\r\n\t\tIUniswapV3Pool(pool).burn(position.tickLower, position.tickUpper, 0);\r\n\t\t(\r\n\t\t\tnewPosition.feeGrowthInside0LastX128,\r\n\t\t\tnewPosition.feeGrowthInside1LastX128,\r\n\t\t\tfeeCollected0,\r\n\t\t\tfeeCollected1\r\n\t\t) = _getfeeCollectedAndGrowth(position, pool);\r\n\t\trequire(feeCollected0 > 0 || feeCollected1 > 0, \"TokenizedUniswapV3Position: NO_FEES_COLLECTED\");\r\n\t\r\n\t\t// 2. Calculate how much to collect and send it to autocompounder (and update unclaimedFees)\r\n\t\t(uint256 collect0, uint256 collect1, bytes memory data) = IUniswapV3AC(acModule).getToCollect(\r\n\t\t\tposition, \r\n\t\t\ttokenId, \r\n\t\t\tfeeCollected0, \r\n\t\t\tfeeCollected1\r\n\t\t);\r\n\t\tnewPosition.unclaimedFees0 = feeCollected0.sub(collect0, \"TokenizedUniswapV3Position: COLLECT_0_TOO_HIGH\");\r\n\t\tnewPosition.unclaimedFees1 = feeCollected1.sub(collect1, \"TokenizedUniswapV3Position: COLLECT_1_TOO_HIGH\");\r\n\t\t\r\n\t\tIUniswapV3Pool(pool).collect(acModule, position.tickLower, position.tickUpper, safe128(collect0), safe128(collect1));\r\n\t\t\r\n\t\t\r\n\t\t// 3. Let the autocompounder convert the fees to liquidity\r\n\t\t{\r\n\t\tuint256 totalBalanceBefore = totalBalance[position.fee][position.tickLower][position.tickUpper];\r\n\t\t(bounty0, bounty1) = IUniswapV3AC(acModule).mintLiquidity(bountyTo, data);\t\t\r\n\t\t_updateBalance(position.fee, position.tickLower, position.tickUpper);\r\n\t\tuint256 newLiquidity = totalBalance[position.fee][position.tickLower][position.tickUpper].sub(totalBalanceBefore);\r\n\t\trequire(newLiquidity > 0, \"TokenizedUniswapV3Position: NO_LIQUIDITY_ADDED\");\r\n\t\tnewPosition.liquidity = safe128(newLiquidity.add(position.liquidity));\r\n\t\t}\r\n\t\t\r\n\t\t// 4. Update the position\r\n\t\tpositions[tokenId] = newPosition;\r\n\t\t\r\n\t\temit UpdatePositionLiquidity(tokenId, newPosition.liquidity);\r\n\t\temit UpdatePositionFeeGrowthInside(tokenId, newPosition.feeGrowthInside0LastX128, newPosition.feeGrowthInside1LastX128);\r\n\t\temit UpdatePositionUnclaimedFees(tokenId, newPosition.unclaimedFees0, newPosition.unclaimedFees1);\r\n\t}\r\n\t\r\n\t/*** Utilities ***/\r\n\r\n    function safe128(uint n) internal pure returns (uint128) {\r\n        require(n < 2**128, \"Impermax: SAFE128\");\r\n        return uint128(n);\r\n    }\r\n\r\n    function safe160(uint n) internal pure returns (uint160) {\r\n        require(n < 2**160, \"Impermax: SAFE160\");\r\n        return uint160(n);\r\n    }\r\n\t\r\n\t// prevents a contract from calling itself, directly or indirectly.\r\n\tbool internal _notEntered = true;\r\n\tmodifier nonReentrant() {\r\n\t\trequire(_notEntered, \"Impermax: REENTERED\");\r\n\t\t_notEntered = false;\r\n\t\t_;\r\n\t\t_notEntered = true;\r\n\t}\r\n}\r\n\r\n// File: contracts\\extensions\\interfaces\\ITokenizedUniswapV3Deployer.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ITokenizedUniswapV3Deployer {\r\n\tfunction deployNFTLP(address token0, address token1) external returns (address NFTLP);\r\n}\r\n\r\n// File: contracts\\extensions\\TokenizedUniswapV3Deployer.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract TokenizedUniswapV3Deployer is ITokenizedUniswapV3Deployer {\r\n\tconstructor () public {}\r\n\t\r\n\tfunction deployNFTLP(address token0, address token1) external returns (address NFTLP) {\r\n\t\tbytes memory bytecode = type(TokenizedUniswapV3Position).creationCode;\r\n\t\tbytes32 salt = keccak256(abi.encodePacked(msg.sender, token0, token1));\r\n\t\tassembly {\r\n\t\t\tNFTLP := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n\t\t}\r\n\t}\r\n}",
  "abi": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"MintPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeGrowthInside0LastX128\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeGrowthInside1LastX128\",\"type\":\"uint256\"}],\"name\":\"UpdatePositionFeeGrowthInside\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"UpdatePositionLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unclaimedFees0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unclaimedFees1\",\"type\":\"uint256\"}],\"name\":\"UpdatePositionUnclaimedFees\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_COLLECTED_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapV3Factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"_initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"safetyMarginSqrt\",\"type\":\"uint256\"}],\"name\":\"getPositionData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceSqrtX96\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"realX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"realY\",\"type\":\"uint256\"}],\"internalType\":\"struct INFTLP.RealXY\",\"name\":\"lowestPrice\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"realX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"realY\",\"type\":\"uint256\"}],\"internalType\":\"struct INFTLP.RealXY\",\"name\":\"currentPrice\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"realX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"realY\",\"type\":\"uint256\"}],\"internalType\":\"struct INFTLP.RealXY\",\"name\":\"highestPrice\",\"type\":\"tuple\"}],\"internalType\":\"struct INFTLP.RealXYs\",\"name\":\"realXYs\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenToJoin\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"oraclePriceSqrtX96\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside0LastX128\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside1LastX128\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unclaimedFees0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unclaimedFees1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"positionsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bountyTo\",\"type\":\"address\"}],\"name\":\"reinvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bounty0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bounty1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"split\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapV3Factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]",
  "contract_name": "TokenizedUniswapV3Position",
  "compiler_version": "v0.5.16+commit.9c3226ce",
  "optimization_used": "1",
  "runs": "999999",
  "constructor_arguments": "",
  "evm_version": "Default",
  "library": "",
  "license_type": "BSL 1.1",
  "proxy": "0",
  "implementation": "",
  "bytecode": null
}