{
  "address": "0xbc303acda8b2a0dcd3d17f05adddf854edd6da59",
  "has_source_code": true,
  "source_code": "// File: contracts\\libraries\\SafeMath.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// File: contracts\\ImpermaxERC20.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract ImpermaxERC20 is IERC20 {\r\n\tusing SafeMath for uint;\r\n\t\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals = 18;\r\n\tuint public totalSupply;\r\n\tmapping(address => uint) public balanceOf;\r\n\tmapping(address => mapping(address => uint)) public allowance;\r\n\t\r\n\tbytes32 public DOMAIN_SEPARATOR;\r\n\tmapping(address => uint) public nonces;\r\n\r\n\tconstructor() public {}\t\r\n\t\r\n\tfunction _setName(string memory _name, string memory _symbol) internal {\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n\t\tuint chainId;\r\n\t\tassembly {\r\n\t\t\tchainId := chainid\r\n\t\t}\r\n\t\tDOMAIN_SEPARATOR = keccak256(\r\n\t\t\tabi.encode(\r\n\t\t\t\tkeccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n\t\t\t\tkeccak256(bytes(_name)),\r\n\t\t\t\tkeccak256(bytes(\"1\")),\r\n\t\t\t\tchainId,\r\n\t\t\t\taddress(this)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tfunction _mint(address to, uint value) internal {\r\n\t\ttotalSupply = totalSupply.add(value);\r\n\t\tbalanceOf[to] = balanceOf[to].add(value);\r\n\t\temit Transfer(address(0), to, value);\r\n\t}\r\n\r\n\tfunction _burn(address from, uint value) internal {\r\n\t\tbalanceOf[from] = balanceOf[from].sub(value);\r\n\t\ttotalSupply = totalSupply.sub(value);\r\n\t\temit Transfer(from, address(0), value);\r\n\t}\r\n\r\n\tfunction _approve(address owner, address spender, uint value) private {\r\n\t\tallowance[owner][spender] = value;\r\n\t\temit Approval(owner, spender, value);\r\n\t}\r\n\r\n\tfunction _transfer(address from, address to, uint value) internal {\r\n\t\tbalanceOf[from] = balanceOf[from].sub(value, \"ImpermaxERC20: TRANSFER_TOO_HIGH\");\r\n\t\tbalanceOf[to] = balanceOf[to].add(value);\r\n\t\temit Transfer(from, to, value);\r\n\t}\r\n\r\n\tfunction approve(address spender, uint value) external returns (bool) {\r\n\t\t_approve(msg.sender, spender, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transfer(address to, uint value) external returns (bool) {\r\n\t\t_transfer(msg.sender, to, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool) {\r\n\t\tif (allowance[from][msg.sender] != uint(-1)) {\r\n\t\t\tallowance[from][msg.sender] = allowance[from][msg.sender].sub(value, \"ImpermaxERC20: TRANSFER_NOT_ALLOWED\");\r\n\t\t}\r\n\t\t_transfer(from, to, value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction _checkSignature(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s, bytes32 typehash) internal {\r\n\t\trequire(deadline >= block.timestamp, \"ImpermaxERC20: EXPIRED\");\r\n\t\tbytes32 digest = keccak256(\r\n\t\t\tabi.encodePacked(\r\n\t\t\t\t'\\x19\\x01',\r\n\t\t\t\tDOMAIN_SEPARATOR,\r\n\t\t\t\tkeccak256(abi.encode(typehash, owner, spender, value, nonces[owner]++, deadline))\r\n\t\t\t)\r\n\t\t);\r\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\r\n\t\trequire(recoveredAddress != address(0) && recoveredAddress == owner, \"ImpermaxERC20: INVALID_SIGNATURE\");\t\r\n\t}\r\n\r\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n\t\t_checkSignature(owner, spender, value, deadline, v, r, s, PERMIT_TYPEHASH);\r\n\t\t_approve(owner, spender, value);\r\n\t}\r\n}\r\n\r\n// File: contracts\\interfaces\\IPoolToken.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IPoolToken {\r\n\r\n\t/*** Impermax ERC20 ***/\r\n\t\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\t\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction totalSupply() external view returns (uint);\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction nonces(address owner) external view returns (uint);\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t/*** Pool Token ***/\r\n\t\r\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\r\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\r\n\tevent Sync(uint totalBalance);\r\n\t\r\n\tfunction underlying() external view returns (address);\r\n\tfunction factory() external view returns (address);\r\n\tfunction totalBalance() external view returns (uint);\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n\tfunction exchangeRate() external returns (uint);\r\n\tfunction mint(address minter) external returns (uint mintTokens);\r\n\tfunction redeem(address redeemer) external returns (uint redeemAmount);\r\n\tfunction skim(address to) external;\r\n\tfunction sync() external;\r\n\t\r\n\tfunction _setFactory() external;\r\n}\r\n\r\n// File: contracts\\PoolToken.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract PoolToken is IPoolToken, ImpermaxERC20 {\r\n   \tuint internal constant initialExchangeRate = 1e18;\r\n\taddress public underlying;\r\n\taddress public factory;\r\n\tuint public totalBalance;\r\n\tuint public constant MINIMUM_LIQUIDITY = 1000;\r\n\t\r\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\r\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\r\n\tevent Sync(uint totalBalance);\r\n\t\r\n\t/*** Initialize ***/\r\n\t\r\n\t// called once by the factory\r\n\tfunction _setFactory() external {\r\n\t\trequire(factory == address(0), \"PoolToken: FACTORY_ALREADY_SET\");\r\n\t\tfactory = msg.sender;\r\n\t}\r\n\t\r\n\t/*** PoolToken ***/\r\n\t\r\n\tfunction _update() internal {\r\n\t\ttotalBalance = IERC20(underlying).balanceOf(address(this));\r\n\t\temit Sync(totalBalance);\r\n\t}\r\n\r\n\tfunction exchangeRate() public returns (uint) \r\n\t{\r\n\t\tuint _totalSupply = totalSupply; // gas savings\r\n\t\tuint _totalBalance = totalBalance; // gas savings\r\n\t\tif (_totalSupply == 0 || _totalBalance == 0) return initialExchangeRate;\r\n\t\treturn _totalBalance.mul(1e18).div(_totalSupply);\r\n\t}\r\n\t\r\n\t// this low-level function should be called from another contract\r\n\tfunction mint(address minter) external nonReentrant update returns (uint mintTokens) {\r\n\t\tuint balance = IERC20(underlying).balanceOf(address(this));\r\n\t\tuint mintAmount = balance.sub(totalBalance);\r\n\t\tmintTokens = mintAmount.mul(1e18).div(exchangeRate());\r\n\r\n\t\tif(totalSupply == 0) {\r\n\t\t\t// permanently lock the first MINIMUM_LIQUIDITY tokens\r\n\t\t\tmintTokens = mintTokens.sub(MINIMUM_LIQUIDITY);\r\n\t\t\t_mint(address(0), MINIMUM_LIQUIDITY);\r\n\t\t}\r\n\t\trequire(mintTokens > 0, \"PoolToken: MINT_AMOUNT_ZERO\");\r\n\t\t_mint(minter, mintTokens);\r\n\t\temit Mint(msg.sender, minter, mintAmount, mintTokens);\r\n\t}\r\n\r\n\t// this low-level function should be called from another contract\r\n\tfunction redeem(address redeemer) external nonReentrant update returns (uint redeemAmount) {\r\n\t\tuint redeemTokens = balanceOf[address(this)];\r\n\t\tredeemAmount = redeemTokens.mul(exchangeRate()).div(1e18);\r\n\r\n\t\trequire(redeemAmount > 0, \"PoolToken: REDEEM_AMOUNT_ZERO\");\r\n\t\trequire(redeemAmount <= totalBalance, \"PoolToken: INSUFFICIENT_CASH\");\r\n\t\t_burn(address(this), redeemTokens);\r\n\t\t_safeTransfer(redeemer, redeemAmount);\r\n\t\temit Redeem(msg.sender, redeemer, redeemAmount, redeemTokens);\t\t\r\n\t}\r\n\r\n\t// force real balance to match totalBalance\r\n\tfunction skim(address to) external nonReentrant {\r\n\t\t_safeTransfer(to, IERC20(underlying).balanceOf(address(this)).sub(totalBalance));\r\n\t}\r\n\r\n\t// force totalBalance to match real balance\r\n\tfunction sync() external nonReentrant update {}\r\n\t\r\n\t/*** Utilities ***/\r\n\t\r\n\t// same safe transfer function used by UniSwapV2 (with fixed underlying)\r\n\tbytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n\tfunction _safeTransfer(address to, uint amount) internal {\r\n\t\trequire(underlying != address(0), \"PoolToken: NOT_INITIALIZED\");\r\n\t\t(bool success, bytes memory data) = underlying.call(abi.encodeWithSelector(SELECTOR, to, amount));\r\n\t\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \"PoolToken: TRANSFER_FAILED\");\r\n\t}\r\n\t\r\n\t// prevents a contract from calling itself, directly or indirectly.\r\n\tbool internal _notEntered = true;\r\n\tmodifier nonReentrant() {\r\n\t\trequire(_notEntered, \"PoolToken: REENTERED\");\r\n\t\t_notEntered = false;\r\n\t\t_;\r\n\t\t_notEntered = true;\r\n\t}\r\n\t\r\n\t// update totalBalance with current balance\r\n\tmodifier update() {\r\n\t\t_;\r\n\t\t_update();\r\n\t}\r\n}\r\n\r\n// File: contracts\\BStorage.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ncontract BStorage {\r\n\r\n\taddress public collateral;\r\n\r\n\tmapping (address => mapping (address => uint256)) public borrowAllowance;\r\n\t\r\n\tstruct BorrowSnapshot {\r\n\t\tuint112 principal;\t\t// amount in underlying when the borrow was last updated\r\n\t\tuint112 interestIndex;\t// borrow index when borrow was last updated\r\n\t}\r\n\tmapping(uint256 => BorrowSnapshot) internal borrowBalances;\t\r\n\r\n\t// use one memory slot\r\n\tuint112 public borrowIndex = 1e18;\r\n\tuint112 public totalBorrows;\r\n\tuint32 public accrualTimestamp = uint32(block.timestamp % 2**32);\t\r\n\r\n\tuint public exchangeRateLast;\r\n\t\t\r\n\t// use one memory slot\r\n\tuint48 public borrowRate;\r\n\tuint48 public kinkBorrowRate = 6.3419584e9; //20% per year\r\n\tuint32 public rateUpdateTimestamp = uint32(block.timestamp % 2**32);\r\n\r\n\tuint public reserveFactor = 0.10e18; //10%\r\n\tuint public kinkUtilizationRate = 0.75e18; //75%\r\n\tuint public adjustSpeed = 5.787037e12; //50% per day\r\n\tuint public debtCeiling = uint(-1);\r\n\r\n    function safe112(uint n) internal pure returns (uint112) {\r\n        require(n < 2**112, \"Impermax: SAFE112\");\r\n        return uint112(n);\r\n    }\r\n}\r\n\r\n// File: contracts\\BAllowance.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract BAllowance is PoolToken, BStorage {\t\r\n\r\n\tevent BorrowApproval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\tfunction _borrowApprove(address owner, address spender, uint256 value) private {\r\n\t\tborrowAllowance[owner][spender] = value;\r\n\t\temit BorrowApproval(owner, spender, value);\r\n\t}\r\n\t\r\n\tfunction borrowApprove(address spender, uint256 value) external returns (bool) {\r\n\t\t_borrowApprove(msg.sender, spender, value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction _checkBorrowAllowance(address owner, address spender, uint256 value) internal {\r\n\t\tif (spender == owner) return;\r\n\t\tuint _borrowAllowance = borrowAllowance[owner][spender];\r\n\t\tif (_borrowAllowance == uint256(-1)) return;\r\n\t\trequire(_borrowAllowance >= value, \"ImpermaxV3Borrowable: BORROW_NOT_ALLOWED\");\r\n\t\tborrowAllowance[owner][spender] = _borrowAllowance - value;\r\n\t}\r\n\r\n\t// keccak256(\"BorrowPermit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\tbytes32 public constant BORROW_PERMIT_TYPEHASH = 0xf6d86ed606f871fa1a557ac0ba607adce07767acf53f492fb215a1a4db4aea6f;\r\n\tfunction borrowPermit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n\t\t_checkSignature(owner, spender, value, deadline, v, r, s, BORROW_PERMIT_TYPEHASH);\r\n\t\t_borrowApprove(owner, spender, value);\r\n\t}\r\n}\r\n\r\n// File: contracts\\BInterestRateModel.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract BInterestRateModel is PoolToken, BStorage {\r\n\r\n\t// When utilization is 100% borrowRate is kinkBorrowRate * KINK_MULTIPLIER\r\n\t// kinkBorrowRate relative adjustment per second belongs to [1-adjustSpeed, 1+adjustSpeed*(KINK_MULTIPLIER-1)]\r\n\tuint public constant KINK_MULTIPLIER = 2;\r\n\tuint public constant KINK_BORROW_RATE_MAX = 792.744800e9; //2500% per year\r\n\tuint public constant KINK_BORROW_RATE_MIN = 0.31709792e9; //1% per year\r\n\r\n\tevent AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\tevent CalculateKinkBorrowRate(uint kinkBorrowRate);\r\n\tevent CalculateBorrowRate(uint borrowRate);\r\n\t\t\r\n\tfunction _calculateBorrowRate() internal {\r\n\t\tuint _kinkUtilizationRate = kinkUtilizationRate;\t\t\r\n\t\tuint _adjustSpeed = adjustSpeed;\r\n\t\tuint _borrowRate = borrowRate;\t\r\n\t\tuint _kinkBorrowRate = kinkBorrowRate;\r\n\t\tuint32 _rateUpdateTimestamp = rateUpdateTimestamp;\t\t\r\n\t\r\n\t\t// update kinkBorrowRate using previous borrowRate\r\n\t\tuint32 timeElapsed = getBlockTimestamp() - _rateUpdateTimestamp; // underflow is desired\r\n\t\tif(timeElapsed > 0) {\r\n\t\t\trateUpdateTimestamp = getBlockTimestamp();\r\n\t\t\tuint adjustFactor;\r\n\t\t\t\r\n\t\t\tif (_borrowRate < _kinkBorrowRate) {\r\n\t\t\t\t// never overflows, _kinkBorrowRate is never 0\r\n\t\t\t\tuint tmp = (_kinkBorrowRate - _borrowRate) * 1e18 / _kinkBorrowRate * _adjustSpeed * timeElapsed / 1e18;\r\n\t\t\t\tadjustFactor = tmp > 1e18 ? 0 : 1e18 - tmp;\r\n\t\t\t} else {\r\n\t\t\t\t// never overflows, _kinkBorrowRate is never 0\r\n\t\t\t\tuint tmp = (_borrowRate - _kinkBorrowRate) * 1e18 / _kinkBorrowRate * _adjustSpeed * timeElapsed / 1e18;\r\n\t\t\t\tadjustFactor = tmp + 1e18;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// never overflows\r\n\t\t\t_kinkBorrowRate = _kinkBorrowRate * adjustFactor / 1e18;\r\n\t\t\tif(_kinkBorrowRate > KINK_BORROW_RATE_MAX) _kinkBorrowRate = KINK_BORROW_RATE_MAX;\r\n\t\t\tif(_kinkBorrowRate < KINK_BORROW_RATE_MIN) _kinkBorrowRate = KINK_BORROW_RATE_MIN;\r\n\r\n\t\t\tkinkBorrowRate = uint48(_kinkBorrowRate);\r\n\t\t\temit CalculateKinkBorrowRate(_kinkBorrowRate);\r\n\t\t}\r\n\t\t\r\n\t\tuint _utilizationRate;\r\n\t\t{ // avoid stack to deep\r\n\t\tuint _totalBorrows = totalBorrows; // gas savings\r\n\t\tuint _actualBalance = totalBalance.add(_totalBorrows);\r\n\t\t_utilizationRate = (_actualBalance == 0) ? 0 : _totalBorrows * 1e18 / _actualBalance;\r\n\t\t}\r\n\t\t\r\n\t\t// update borrowRate using the new kinkBorrowRate\t\r\n\t\tif(_utilizationRate <= _kinkUtilizationRate) {\r\n\t\t\t// never overflows, _kinkUtilizationRate is never 0\r\n\t\t\t_borrowRate = _kinkBorrowRate * _utilizationRate / _kinkUtilizationRate;\r\n\t\t} else {\r\n\t\t\t// never overflows, _kinkUtilizationRate is always < 1e18\r\n\t\t\tuint overUtilization = (_utilizationRate - _kinkUtilizationRate) * 1e18 / (1e18 - _kinkUtilizationRate);\r\n\t\t\t// never overflows\r\n\t\t\t_borrowRate = ((KINK_MULTIPLIER - 1) * overUtilization + 1e18) * _kinkBorrowRate / 1e18;\r\n\t\t}\r\n\t\tborrowRate = uint48(_borrowRate);\r\n\t\temit CalculateBorrowRate(_borrowRate);\r\n\t}\r\n\t\r\n\t// applies accrued interest to total borrows and reserves\r\n\tfunction accrueInterest() public {\r\n\t\tuint _borrowIndex = borrowIndex;\r\n\t\tuint _totalBorrows = totalBorrows;\r\n\t\tuint32 _accrualTimestamp = accrualTimestamp;\r\n\t\t\r\n\t\tuint32 blockTimestamp = getBlockTimestamp();\r\n\t\tif (_accrualTimestamp == blockTimestamp) return;\r\n\t\tuint32 timeElapsed = blockTimestamp - _accrualTimestamp; // underflow is desired\r\n\t\taccrualTimestamp = blockTimestamp;\r\n\t\t\r\n\t\tuint interestFactor = uint(borrowRate).mul(timeElapsed);\t\r\n\t\tuint interestAccumulated = interestFactor.mul(_totalBorrows).div(1e18);\r\n\t\t_totalBorrows = _totalBorrows.add( interestAccumulated );\r\n\t\t_borrowIndex = _borrowIndex.add( interestFactor.mul(_borrowIndex).div(1e18) );\r\n\t\r\n\t\tborrowIndex = safe112(_borrowIndex);\r\n\t\ttotalBorrows = safe112(_totalBorrows);\r\n\t\temit AccrueInterest(interestAccumulated, _borrowIndex, _totalBorrows);\r\n\t}\r\n\t\t\r\n\tfunction getBlockTimestamp() public view returns (uint32) {\r\n\t\treturn uint32(block.timestamp % 2**32);\r\n\t}\r\n}\r\n\r\n// File: contracts\\interfaces\\IFactory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IFactory {\r\n\tevent LendingPoolInitialized(address indexed nftlp, address indexed token0, address indexed token1,\r\n\t\taddress collateral, address borrowable0, address borrowable1, uint lendingPoolId);\r\n\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\tevent NewAdmin(address oldAdmin, address newAdmin);\r\n\tevent NewReservesPendingAdmin(address oldReservesPendingAdmin, address newReservesPendingAdmin);\r\n\tevent NewReservesAdmin(address oldReservesAdmin, address newReservesAdmin);\r\n\tevent NewReservesManager(address oldReservesManager, address newReservesManager);\r\n\t\r\n\tfunction admin() external view returns (address);\r\n\tfunction pendingAdmin() external view returns (address);\r\n\tfunction reservesAdmin() external view returns (address);\r\n\tfunction reservesPendingAdmin() external view returns (address);\r\n\tfunction reservesManager() external view returns (address);\r\n\r\n\tfunction getLendingPool(address nftlp) external view returns (\r\n\t\tbool initialized, \r\n\t\tuint24 lendingPoolId, \r\n\t\taddress collateral, \r\n\t\taddress borrowable0, \r\n\t\taddress borrowable1\r\n\t);\r\n\tfunction allLendingPools(uint) external view returns (address nftlp);\r\n\tfunction allLendingPoolsLength() external view returns (uint);\r\n\t\r\n\tfunction bDeployer() external view returns (address);\r\n\tfunction cDeployer() external view returns (address);\r\n\r\n\tfunction createCollateral(address nftlp) external returns (address collateral);\r\n\tfunction createBorrowable0(address nftlp) external returns (address borrowable0);\r\n\tfunction createBorrowable1(address nftlp) external returns (address borrowable1);\r\n\tfunction initializeLendingPool(address nftlp) external;\r\n\r\n\tfunction _setPendingAdmin(address newPendingAdmin) external;\r\n\tfunction _acceptAdmin() external;\r\n\tfunction _setReservesPendingAdmin(address newPendingAdmin) external;\r\n\tfunction _acceptReservesAdmin() external;\r\n\tfunction _setReservesManager(address newReservesManager) external;\r\n}\r\n\r\n// File: contracts\\BSetter.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract BSetter is PoolToken, BStorage {\r\n\r\n\tuint public constant RESERVE_FACTOR_MAX = 0.20e18; //20%\r\n\tuint public constant KINK_UR_MIN = 0.50e18; //50%\r\n\tuint public constant KINK_UR_MAX = 0.99e18; //99%\r\n\tuint public constant ADJUST_SPEED_MIN = 0.05787037e12; //0.5% per day\r\n\tuint public constant ADJUST_SPEED_MAX = 57.87037e12; //500% per day\r\n\r\n\tevent NewReserveFactor(uint newReserveFactor);\r\n\tevent NewKinkUtilizationRate(uint newKinkUtilizationRate);\r\n\tevent NewAdjustSpeed(uint newAdjustSpeed);\r\n\tevent NewDebtCeiling(uint newDebtCeiling);\r\n\t\r\n\t// called once by the factory at time of deployment\r\n\tfunction _initialize (\r\n\t\tstring calldata _name, \r\n\t\tstring calldata _symbol,\r\n\t\taddress _underlying, \r\n\t\taddress _collateral\r\n\t) external {\r\n\t\trequire(msg.sender == factory, \"ImpermaxV3Borrowable: UNAUTHORIZED\"); // sufficient check\r\n\t\t_setName(_name, _symbol);\r\n\t\tunderlying = _underlying;\r\n\t\tcollateral = _collateral;\r\n\t\texchangeRateLast = initialExchangeRate;\r\n\t}\r\n\t\r\n\tfunction _setReserveFactor(uint newReserveFactor) external nonReentrant onlyAdmin {\r\n\t\t_checkSetting(newReserveFactor, 0, RESERVE_FACTOR_MAX);\r\n\t\treserveFactor = newReserveFactor;\r\n\t\temit NewReserveFactor(newReserveFactor);\r\n\t}\r\n\r\n\tfunction _setKinkUtilizationRate(uint newKinkUtilizationRate) external nonReentrant onlyAdmin {\r\n\t\t_checkSetting(newKinkUtilizationRate, KINK_UR_MIN, KINK_UR_MAX);\r\n\t\tkinkUtilizationRate = newKinkUtilizationRate;\r\n\t\temit NewKinkUtilizationRate(newKinkUtilizationRate);\r\n\t}\r\n\r\n\tfunction _setAdjustSpeed(uint newAdjustSpeed) external nonReentrant onlyAdmin {\r\n\t\t_checkSetting(newAdjustSpeed, ADJUST_SPEED_MIN, ADJUST_SPEED_MAX);\r\n\t\tadjustSpeed = newAdjustSpeed;\r\n\t\temit NewAdjustSpeed(newAdjustSpeed);\r\n\t}\r\n\r\n\tfunction _setDebtCeiling(uint newDebtCeiling) external nonReentrant onlyAdmin {\r\n\t\tdebtCeiling = newDebtCeiling;\r\n\t\temit NewDebtCeiling(newDebtCeiling);\r\n\t}\r\n\t\r\n\tfunction _checkSetting(uint parameter, uint min, uint max) internal view {\r\n\t\trequire(parameter >= min, \"ImpermaxV3Borrowable: INVALID_SETTING\");\r\n\t\trequire(parameter <= max, \"ImpermaxV3Borrowable: INVALID_SETTING\");\r\n\t}\r\n\r\n\tmodifier onlyAdmin() {\r\n\t\trequire(msg.sender == IFactory(factory).admin(), \"ImpermaxV3Borrowable: UNAUTHORIZED\");\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n// File: contracts\\interfaces\\IBorrowable.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IBorrowable {\r\n\r\n\t/*** Impermax ERC20 ***/\r\n\t\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\t\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction totalSupply() external view returns (uint);\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction nonces(address owner) external view returns (uint);\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t/*** Pool Token ***/\r\n\t\r\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\r\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\r\n\tevent Sync(uint totalBalance);\r\n\t\r\n\tfunction underlying() external view returns (address);\r\n\tfunction factory() external view returns (address);\r\n\tfunction totalBalance() external view returns (uint);\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n\tfunction exchangeRate() external returns (uint);\r\n\tfunction mint(address minter) external returns (uint mintTokens);\r\n\tfunction redeem(address redeemer) external returns (uint redeemAmount);\r\n\tfunction skim(address to) external;\r\n\tfunction sync() external;\r\n\t\r\n\tfunction _setFactory() external;\r\n\t\r\n\t/*** Borrowable ***/\r\n\r\n\tevent BorrowApproval(address indexed owner, address indexed spender, uint value);\r\n\tevent Borrow(address indexed sender, uint256 indexed tokenId, address indexed receiver, uint borrowAmount, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\r\n\tevent Liquidate(address indexed sender, uint256 indexed tokenId, address indexed liquidator, uint seizeTokenId, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\r\n\tevent RestructureDebt(uint256 indexed tokenId, uint reduceToRatio, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\r\n\t\r\n\tfunction collateral() external view returns (address);\r\n\tfunction reserveFactor() external view returns (uint);\r\n\tfunction exchangeRateLast() external view returns (uint);\r\n\tfunction borrowIndex() external view returns (uint);\r\n\tfunction totalBorrows() external view returns (uint);\r\n\tfunction borrowAllowance(address owner, address spender) external view returns (uint);\r\n\tfunction borrowBalance(uint tokenId) external view returns (uint);\t\r\n\tfunction currentBorrowBalance(uint tokenId) external returns (uint);\t\r\n\t\r\n\tfunction BORROW_PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction borrowApprove(address spender, uint256 value) external returns (bool);\r\n\tfunction borrowPermit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\tfunction borrow(uint256 tokenId, address receiver, uint borrowAmount, bytes calldata data) external;\r\n\tfunction liquidate(uint256 tokenId, uint repayAmount, address liquidator, bytes calldata data) external returns (uint seizeTokenId);\r\n\tfunction restructureDebt(uint256 tokenId, uint256 reduceToRatio) external;\r\n\t\r\n\t/*** Borrowable Interest Rate Model ***/\r\n\r\n\tevent AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\tevent CalculateKink(uint kinkRate);\r\n\tevent CalculateBorrowRate(uint borrowRate);\r\n\t\r\n\tfunction KINK_BORROW_RATE_MAX() external pure returns (uint);\r\n\tfunction KINK_BORROW_RATE_MIN() external pure returns (uint);\r\n\tfunction KINK_MULTIPLIER() external pure returns (uint);\r\n\tfunction borrowRate() external view returns (uint);\r\n\tfunction kinkBorrowRate() external view returns (uint);\r\n\tfunction kinkUtilizationRate() external view returns (uint);\r\n\tfunction adjustSpeed() external view returns (uint);\r\n\tfunction rateUpdateTimestamp() external view returns (uint32);\r\n\tfunction accrualTimestamp() external view returns (uint32);\r\n\t\r\n\tfunction accrueInterest() external;\r\n\t\r\n\t/*** Borrowable Setter ***/\r\n\r\n\tevent NewReserveFactor(uint newReserveFactor);\r\n\tevent NewKinkUtilizationRate(uint newKinkUtilizationRate);\r\n\tevent NewAdjustSpeed(uint newAdjustSpeed);\r\n\tevent NewDebtCeiling(uint newDebtCeiling);\r\n\r\n\tfunction RESERVE_FACTOR_MAX() external pure returns (uint);\r\n\tfunction KINK_UR_MIN() external pure returns (uint);\r\n\tfunction KINK_UR_MAX() external pure returns (uint);\r\n\tfunction ADJUST_SPEED_MIN() external pure returns (uint);\r\n\tfunction ADJUST_SPEED_MAX() external pure returns (uint);\r\n\t\r\n\tfunction _initialize (\r\n\t\tstring calldata _name, \r\n\t\tstring calldata _symbol,\r\n\t\taddress _underlying, \r\n\t\taddress _collateral\r\n\t) external;\r\n\tfunction _setReserveFactor(uint newReserveFactor) external;\r\n\tfunction _setKinkUtilizationRate(uint newKinkUtilizationRate) external;\r\n\tfunction _setAdjustSpeed(uint newAdjustSpeed) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\ICollateral.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ICollateral {\r\n\t\r\n\t/* ImpermaxERC721 */\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\t\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\t\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\tfunction setApprovalForAll(address operator, bool approved) external;\r\n\tfunction permit(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t/* Collateral */\r\n\t\r\n\tevent Mint(address indexed to, uint tokenId);\r\n\tevent Redeem(address indexed to, uint tokenId, uint percentage, uint redeemTokenId);\r\n\tevent Seize(address indexed to, uint tokenId, uint percentage, uint redeemTokenId);\r\n\tevent RestructureBadDebt(uint tokenId, uint postLiquidationCollateralRatio);\r\n\t\r\n\tfunction underlying() external view returns (address);\r\n\tfunction factory() external view returns (address);\r\n\tfunction borrowable0() external view returns (address);\r\n\tfunction borrowable1() external view returns (address);\r\n\tfunction safetyMarginSqrt() external view returns (uint);\r\n\tfunction liquidationIncentive() external view returns (uint);\r\n\tfunction liquidationFee() external view returns (uint);\r\n\tfunction liquidationPenalty() external view returns (uint);\r\n\r\n\tfunction mint(address to, uint256 tokenId) external;\r\n\tfunction redeem(address to, uint256 tokenId, uint256 percentage, bytes calldata data) external returns (uint redeemTokenId);\r\n\tfunction redeem(address to, uint256 tokenId, uint256 percentage) external returns (uint redeemTokenId);\r\n\tfunction isLiquidatable(uint tokenId) external returns (bool);\r\n\tfunction isUnderwater(uint tokenId) external returns (bool);\r\n\tfunction canBorrow(uint tokenId, address borrowable, uint accountBorrows) external returns (bool);\r\n\tfunction restructureBadDebt(uint tokenId) external;\r\n\tfunction seize(uint tokenId, uint repayAmount, address liquidator, bytes calldata data) external returns (uint seizeTokenId);\r\n\t\r\n\t/* CSetter */\r\n\t\r\n\tevent NewSafetyMargin(uint newSafetyMarginSqrt);\r\n\tevent NewLiquidationIncentive(uint newLiquidationIncentive);\r\n\tevent NewLiquidationFee(uint newLiquidationFee);\r\n\r\n\tfunction SAFETY_MARGIN_SQRT_MIN() external pure returns (uint);\r\n\tfunction SAFETY_MARGIN_SQRT_MAX() external pure returns (uint);\r\n\tfunction LIQUIDATION_INCENTIVE_MIN() external pure returns (uint);\r\n\tfunction LIQUIDATION_INCENTIVE_MAX() external pure returns (uint);\r\n\tfunction LIQUIDATION_FEE_MAX() external pure returns (uint);\r\n\t\r\n\tfunction _setFactory() external;\r\n\tfunction _initialize (\r\n\t\tstring calldata _name,\r\n\t\tstring calldata _symbol,\r\n\t\taddress _underlying, \r\n\t\taddress _borrowable0, \r\n\t\taddress _borrowable1\r\n\t) external;\r\n\tfunction _setSafetyMarginSqrt(uint newSafetyMarginSqrt) external;\r\n\tfunction _setLiquidationIncentive(uint newLiquidationIncentive) external;\r\n\tfunction _setLiquidationFee(uint newLiquidationFee) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IImpermaxCallee.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IImpermaxCallee {\r\n    function impermaxV3Borrow(address sender, uint256 tokenId, uint borrowAmount, bytes calldata data) external;\r\n    function impermaxV3Redeem(address sender, uint256 tokenId, uint256 redeemTokenId, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC721.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC721 {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\t\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction nonces(uint256 tokenId) external view returns (uint256);\r\n\t\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\tfunction setApprovalForAll(address operator, bool approved) external;\r\n\tfunction permit(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n// File: contracts\\libraries\\Math.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for performing various math operations\r\n// forked from: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\t\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        z = x > y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\ImpermaxV3Borrowable.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract ImpermaxV3Borrowable is IBorrowable, PoolToken, BStorage, BSetter, BInterestRateModel, BAllowance {\r\n\t\t\r\n\tconstructor() public {}\r\n\r\n\t/*** PoolToken ***/\r\n\t\r\n\tfunction _update() internal {\r\n\t\tsuper._update();\r\n\t\t_calculateBorrowRate();\r\n\t}\r\n\t\r\n\tfunction _mintReserves(uint _exchangeRate, uint _totalSupply) internal returns (uint) {\r\n\t\tuint _exchangeRateLast = exchangeRateLast;\r\n\t\tif (_exchangeRate > _exchangeRateLast) {\r\n\t\t\tuint _exchangeRateNew = _exchangeRate.sub( _exchangeRate.sub(_exchangeRateLast).mul(reserveFactor).div(1e18) );\r\n\t\t\tuint liquidity = _totalSupply.mul(_exchangeRate).div(_exchangeRateNew).sub(_totalSupply);\r\n\t\t\tif (liquidity > 0) {\r\n\t\t\t\taddress reservesManager = IFactory(factory).reservesManager();\r\n\t\t\t\t_mint(reservesManager, liquidity);\r\n\t\t\t}\r\n\t\t\texchangeRateLast = _exchangeRateNew;\r\n\t\t\treturn _exchangeRateNew;\r\n\t\t}\r\n\t\telse return _exchangeRate;\r\n\t}\r\n\t\r\n\tfunction exchangeRate() public accrue returns (uint) {\r\n\t\tuint _totalSupply = totalSupply;\r\n\t\tuint _actualBalance = totalBalance.add(totalBorrows);\r\n\t\tif (_totalSupply == 0 || _actualBalance == 0) return initialExchangeRate;\r\n\t\tuint _exchangeRate = _actualBalance.mul(1e18).div(_totalSupply);\r\n\t\treturn _mintReserves(_exchangeRate, _totalSupply);\r\n\t}\r\n\t\r\n\t// force totalBalance to match real balance\r\n\tfunction sync() external nonReentrant update accrue {}\r\n\t\r\n\t/*** Borrowable ***/\r\n\t\r\n\t// this is the stored borrow balance; the current borrow balance may be slightly higher\r\n\tfunction borrowBalance(uint256 tokenId) public view returns (uint) {\r\n\t\tBorrowSnapshot memory borrowSnapshot = borrowBalances[tokenId];\r\n\t\tif (borrowSnapshot.interestIndex == 0) return 0; // not initialized\r\n\t\treturn uint(borrowSnapshot.principal).mul(borrowIndex).div(borrowSnapshot.interestIndex);\r\n\t}\r\n\tfunction currentBorrowBalance(uint256 tokenId) external accrue returns (uint) {\r\n\t\treturn borrowBalance(tokenId);\r\n\t}\r\n\t\r\n\tfunction _updateBorrow(uint256 tokenId, uint borrowAmount, uint repayAmount) private returns (uint accountBorrowsPrior, uint accountBorrows, uint _totalBorrows) {\r\n\t\taccountBorrowsPrior = borrowBalance(tokenId);\r\n\t\tif (borrowAmount == repayAmount) return (accountBorrowsPrior, accountBorrowsPrior, totalBorrows);\r\n\t\tuint112 _borrowIndex = borrowIndex;\r\n\t\tif (borrowAmount > repayAmount) {\r\n\t\t\tBorrowSnapshot storage borrowSnapshot = borrowBalances[tokenId];\r\n\t\t\tuint increaseAmount = borrowAmount - repayAmount;\r\n\t\t\taccountBorrows = accountBorrowsPrior.add(increaseAmount);\r\n\t\t\tborrowSnapshot.principal = safe112(accountBorrows);\r\n\t\t\tborrowSnapshot.interestIndex = _borrowIndex;\r\n\t\t\t_totalBorrows = uint(totalBorrows).add(increaseAmount);\r\n\t\t\ttotalBorrows = safe112(_totalBorrows);\r\n\t\t\trequire(_totalBorrows <= debtCeiling, \"ImpermaxV3Borrowable: TOTAL_BORROWS_ABOVE_DEBT_CEILING\");\r\n\t\t}\r\n\t\telse {\r\n\t\t\tBorrowSnapshot storage borrowSnapshot = borrowBalances[tokenId];\r\n\t\t\tuint decreaseAmount = repayAmount - borrowAmount;\t\t\r\n\t\t\taccountBorrows = accountBorrowsPrior > decreaseAmount ? accountBorrowsPrior - decreaseAmount : 0;\r\n\t\t\tborrowSnapshot.principal = safe112(accountBorrows);\r\n\t\t\tif(accountBorrows == 0) {\r\n\t\t\t\tborrowSnapshot.interestIndex = 0;\r\n\t\t\t} else {\r\n\t\t\t\tborrowSnapshot.interestIndex = _borrowIndex;\r\n\t\t\t}\r\n\t\t\tuint actualDecreaseAmount = accountBorrowsPrior.sub(accountBorrows);\r\n\t\t\t_totalBorrows = totalBorrows; // gas savings\r\n\t\t\t_totalBorrows = _totalBorrows > actualDecreaseAmount ? _totalBorrows - actualDecreaseAmount : 0;\r\n\t\t\ttotalBorrows = safe112(_totalBorrows);\t\t\t\r\n\t\t}\r\n\t}\r\n\t\r\n\t// this low-level function should be called from another contract\r\n\tfunction borrow(uint256 tokenId, address receiver, uint borrowAmount, bytes calldata data) external nonReentrant update accrue {\r\n\t\tuint _totalBalance = totalBalance;\r\n\t\trequire(borrowAmount <= _totalBalance, \"ImpermaxV3Borrowable: INSUFFICIENT_CASH\");\r\n\t\t\r\n\t\tif (borrowAmount > 0) {\r\n\t\t\taddress borrower = IERC721(collateral).ownerOf(tokenId);\r\n\t\t\t_checkBorrowAllowance(borrower, msg.sender, borrowAmount);\r\n\t\t}\r\n\t\t\r\n\t\t// optimistically transfer funds\r\n\t\tif (borrowAmount > 0) _safeTransfer(receiver, borrowAmount);\r\n\t\tif (data.length > 0) IImpermaxCallee(receiver).impermaxV3Borrow(msg.sender, tokenId, borrowAmount, data);\r\n\t\tuint balance = IERC20(underlying).balanceOf(address(this));\r\n\t\t\r\n\t\tuint repayAmount = balance.add(borrowAmount).sub(_totalBalance);\r\n\t\t(uint accountBorrowsPrior, uint accountBorrows, uint _totalBorrows) = _updateBorrow(tokenId, borrowAmount, repayAmount);\r\n\t\t\r\n\t\tif(borrowAmount > repayAmount) require(\r\n\t\t\tICollateral(collateral).canBorrow(tokenId, address(this), accountBorrows),\r\n\t\t\t\"ImpermaxV3Borrowable: INSUFFICIENT_LIQUIDITY\"\r\n\t\t);\r\n\t\t\r\n\t\temit Borrow(msg.sender, tokenId, receiver, borrowAmount, repayAmount, accountBorrowsPrior, accountBorrows, _totalBorrows);\r\n\t}\r\n\r\n\t// this low-level function should be called from another contract\r\n\tfunction liquidate(uint256 tokenId, uint repayAmount, address liquidator, bytes calldata data) external nonReentrant update accrue returns (uint seizeTokenId) {\r\n\t\trepayAmount = Math.min(repayAmount, borrowBalance(tokenId));\r\n\t\tseizeTokenId = ICollateral(collateral).seize(tokenId, repayAmount, liquidator, data);\r\n\t\t\r\n\t\tuint balance = IERC20(underlying).balanceOf(address(this));\r\n\t\trequire(balance.sub(totalBalance) >= repayAmount, \"ImpermaxV3Borrowable: INSUFFICIENT_ACTUAL_REPAY\");\r\n\t\t\r\n\t\t(uint accountBorrowsPrior, uint accountBorrows, uint _totalBorrows) = _updateBorrow(tokenId, 0, repayAmount);\r\n\t\t\r\n\t\temit Liquidate(msg.sender, tokenId, liquidator, seizeTokenId, repayAmount, accountBorrowsPrior, accountBorrows, _totalBorrows);\r\n\t}\r\n\t\r\n\t// this function must be called from collateral\r\n\tfunction restructureDebt(uint tokenId, uint reduceToRatio) public nonReentrant update accrue {\r\n\t\trequire(msg.sender == collateral, \"ImpermaxV3Borrowable: UNAUTHORIZED\");\r\n\t\trequire(reduceToRatio < 1e18, \"ImpermaxV3Borrowable: NOT_UNDERWATER\");\r\n\t\r\n\t\tuint _borrowBalance = borrowBalance(tokenId);\r\n\t\tif (_borrowBalance == 0) return;\r\n\t\tuint repayAmount = _borrowBalance.sub(_borrowBalance.mul(reduceToRatio).div(1e18));\r\n\t\t(uint accountBorrowsPrior, uint accountBorrows, uint _totalBorrows) = _updateBorrow(tokenId, 0, repayAmount);\r\n\t\t\r\n\t\temit RestructureDebt(tokenId, reduceToRatio, repayAmount, accountBorrowsPrior, accountBorrows, _totalBorrows);\r\n\t}\r\n\t\t\r\n\tmodifier accrue() {\r\n\t\taccrueInterest();\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n// File: contracts\\interfaces\\IBDeployer.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IBDeployer {\r\n\tfunction deployBorrowable(address nftlp, uint8 index) external returns (address borrowable);\r\n}\r\n\r\n// File: contracts\\BDeployer.sol\r\n\r\npragma solidity =0.5.16;\r\n/*\r\n * This contract is used by the Factory to deploy Borrowable(s)\r\n * The bytecode would be too long to fit in the Factory\r\n */\r\n\r\ncontract BDeployer is IBDeployer {\r\n\tconstructor () public {}\r\n\t\r\n\tfunction deployBorrowable(address nftlp, uint8 index) external returns (address borrowable) {\r\n\t\tbytes memory bytecode = type(ImpermaxV3Borrowable).creationCode;\r\n\t\tbytes32 salt = keccak256(abi.encodePacked(msg.sender, nftlp, index));\r\n\t\tassembly {\r\n\t\t\tborrowable := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n\t\t}\r\n\t}\r\n}",
  "abi": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestAccumulated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"AccrueInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrowsPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BorrowApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"}],\"name\":\"CalculateBorrowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kinkRate\",\"type\":\"uint256\"}],\"name\":\"CalculateKink\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kinkBorrowRate\",\"type\":\"uint256\"}],\"name\":\"CalculateKinkBorrowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizeTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrowsPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"Liquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAdjustSpeed\",\"type\":\"uint256\"}],\"name\":\"NewAdjustSpeed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDebtCeiling\",\"type\":\"uint256\"}],\"name\":\"NewDebtCeiling\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newKinkUtilizationRate\",\"type\":\"uint256\"}],\"name\":\"NewKinkUtilizationRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveFactor\",\"type\":\"uint256\"}],\"name\":\"NewReserveFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reduceToRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrowsPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"RestructureDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADJUST_SPEED_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADJUST_SPEED_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BORROW_PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_BORROW_RATE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_BORROW_RATE_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_UR_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_UR_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVE_FACTOR_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"}],\"name\":\"_initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAdjustSpeed\",\"type\":\"uint256\"}],\"name\":\"_setAdjustSpeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDebtCeiling\",\"type\":\"uint256\"}],\"name\":\"_setDebtCeiling\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_setFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newKinkUtilizationRate\",\"type\":\"uint256\"}],\"name\":\"_setKinkUtilizationRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReserveFactor\",\"type\":\"uint256\"}],\"name\":\"_setReserveFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accrualTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"accrueInterest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adjustSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"borrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"borrowApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"borrowBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"borrowPermit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowRate\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"currentBorrowBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debtCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRateLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kinkBorrowRate\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kinkUtilizationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"liquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seizeTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateUpdateTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reduceToRatio\",\"type\":\"uint256\"}],\"name\":\"restructureDebt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBorrows\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]",
  "contract_name": "ImpermaxV3Borrowable",
  "compiler_version": "v0.5.16+commit.9c3226ce",
  "optimization_used": "1",
  "runs": "999999",
  "constructor_arguments": "",
  "evm_version": "Default",
  "library": "",
  "license_type": "BSL 1.1",
  "proxy": "0",
  "implementation": "",
  "bytecode": null
}