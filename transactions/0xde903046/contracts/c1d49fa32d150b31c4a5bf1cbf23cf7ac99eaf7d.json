{
  "address": "0xc1d49fa32d150b31c4a5bf1cbf23cf7ac99eaf7d",
  "has_source_code": true,
  "source_code": "// File: contracts\\CStorage.sol\r\n\r\npragma solidity =0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract CStorage {\r\n\taddress public underlying;\r\n\taddress public factory;\r\n\taddress public borrowable0;\r\n\taddress public borrowable1;\r\n\tuint public safetyMarginSqrt = 1.58113883e18; //safetyMargin: 250%\r\n\tuint public liquidationIncentive = 1.02e18; //2%\r\n\tuint public liquidationFee = 0.02e18; //2%\r\n\tmapping(uint => uint) public blockOfLastRestructureOrLiquidation;\t\r\n\t\r\n\tfunction liquidationPenalty() public view returns (uint) {\r\n\t\treturn liquidationIncentive + liquidationFee;\r\n\t}\r\n}\r\n\r\n// File: contracts\\libraries\\SafeMath.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC721.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC721 {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\t\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction nonces(uint256 tokenId) external view returns (uint256);\r\n\t\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\tfunction setApprovalForAll(address operator, bool approved) external;\r\n\tfunction permit(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC721Receiver.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts\\ImpermaxERC721.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract ImpermaxERC721 is IERC721 {\r\n\tusing SafeMath for uint;\r\n\t\r\n\tstring public name;\r\n\tstring public symbol;\r\n\t\r\n\tmapping(address => uint) public balanceOf;\r\n\tmapping(uint256 => address) internal _ownerOf;\r\n\tmapping(uint256 => address) public getApproved;\r\n\tmapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\t\r\n\tbytes32 public DOMAIN_SEPARATOR;\r\n\tmapping(uint256 => uint) public nonces;\r\n\r\n\tconstructor() public {}\r\n\t\r\n\tfunction _setName(string memory _name, string memory _symbol) internal {\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n\t\t\r\n\t\tuint chainId;\r\n\t\tassembly {\r\n\t\t\tchainId := chainid\r\n\t\t}\r\n\t\tDOMAIN_SEPARATOR = keccak256(\r\n\t\t\tabi.encode(\r\n\t\t\t\tkeccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n\t\t\t\tkeccak256(bytes(_name)),\r\n\t\t\t\tkeccak256(bytes(\"1\")),\r\n\t\t\t\tchainId,\r\n\t\t\t\taddress(this)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\t\r\n\tfunction _isAuthorized(address owner, address operator, uint256 tokenId) internal view returns (bool) {\r\n\t\treturn operator != address(0) && (owner == operator || isApprovedForAll[owner][operator] || getApproved[tokenId] == operator);\r\n\t}\r\n\r\n\tfunction _checkAuthorized(address owner, address operator, uint256 tokenId) internal view {\r\n\t\trequire(_isAuthorized(owner, operator, tokenId), \"ImpermaxERC721: UNAUTHORIZED\");\r\n\t}\r\n\r\n\tfunction _update(address to, uint256 tokenId, address auth) internal returns (address from) {\r\n\t\tfrom = _ownerOf[tokenId];\r\n\t\tif (auth != address(0)) _checkAuthorized(from, auth, tokenId);\r\n\r\n\t\tif (from != address(0)) {\r\n\t\t\t_approve(address(0), tokenId, address(0));\r\n\t\t\tbalanceOf[from] -= 1;\r\n\t\t}\r\n\r\n\t\tif (to != address(0)) {\r\n\t\t\tbalanceOf[to] += 1;\r\n\t\t}\r\n\r\n\t\t_ownerOf[tokenId] = to;\r\n\t\temit Transfer(from, to, tokenId);\r\n\t}\r\n\t\r\n\tfunction _mint(address to, uint256 tokenId) internal {\r\n\t\trequire(to != address(0), \"ImpermaxERC721: INVALID_RECEIVER\");\r\n\t\taddress previousOwner = _update(to, tokenId, address(0));\r\n\t\trequire(previousOwner == address(0), \"ImpermaxERC721: INVALID_SENDER\");\r\n\t}\r\n\tfunction _safeMint(address to, uint256 tokenId) internal {\r\n\t\t_safeMint(to, tokenId, \"\");\r\n\t}\r\n\tfunction _safeMint(address to, uint256 tokenId, bytes memory data) internal {\r\n\t\t_mint(to, tokenId);\r\n\t\t_checkOnERC721Received(address(0), to, tokenId, data);\r\n\t}\r\n\t\r\n\tfunction _burn(uint256 tokenId) internal {\r\n\t\taddress previousOwner = _update(address(0), tokenId, address(0));\r\n\t\trequire(previousOwner != address(0), \"ImpermaxERC721: NONEXISTENT_TOKEN\");\r\n\t}\r\n\t\r\n\tfunction _transfer(address from, address to, uint256 tokenId, address auth) internal {\r\n\t\trequire(to != address(0), \"ImpermaxERC721: INVALID_RECEIVER\");\r\n\t\taddress previousOwner = _update(to, tokenId, auth);\r\n\t\trequire(previousOwner != address(0), \"ImpermaxERC721: NONEXISTENT_TOKEN\");\r\n\t\trequire(previousOwner == from, \"ImpermaxERC721: INCORRECT_OWNER\");\r\n\t}\r\n\t\r\n\tfunction _safeTransfer(address from, address to, uint256 tokenId, address auth) internal {\r\n\t\t_safeTransfer(from, to, tokenId, \"\", auth);\r\n\t}\r\n\tfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory data, address auth) internal {\r\n\t\t_transfer(from, to, tokenId, auth);\r\n\t\t_checkOnERC721Received(from, to, tokenId, data);\r\n\t}\r\n\r\n\tfunction _approve(address to, uint256 tokenId, address auth) internal {\r\n\t\taddress owner = _requireOwned(tokenId);\r\n\t\trequire(auth == address(0) || auth == owner || isApprovedForAll[owner][auth], \"ImpermaxERC721: INVALID_APPROVER\");\r\n\t\tgetApproved[tokenId] = to;\r\n\t\temit Approval(owner, to, tokenId);\r\n\t}\r\n\r\n\tfunction _setApprovalForAll(address owner, address operator, bool approved) internal {\r\n\t\trequire(operator != address(0), \"ImpermaxERC721: INVALID_OPERATOR\");\r\n\t\tisApprovedForAll[owner][operator] = approved;\r\n\t\temit ApprovalForAll(owner, operator, approved);\r\n\t}\r\n\t\r\n\tfunction _requireOwned(uint256 tokenId) internal view returns (address) {\r\n\t\taddress owner = _ownerOf[tokenId];\r\n\t\trequire(owner != address(0), \"ImpermaxERC721: NONEXISTENT_TOKEN\");\r\n\t\treturn owner;\r\n\t}\r\n\t\r\n\tfunction _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) internal {\r\n\t\tif (isContract(to)) {\r\n\t\t\tbytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data);\r\n\t\t\trequire(retval == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")), \"ImpermaxERC721: INVALID_RECEIVER\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address) {\r\n\t\treturn _requireOwned(tokenId);\r\n\t}\r\n\t\r\n\tfunction approve(address to, uint256 tokenId) external {\r\n\t\t_approve(to, tokenId, msg.sender);\r\n\t}\r\n\t\r\n\tfunction setApprovalForAll(address operator, bool approved) external {\r\n\t\t_setApprovalForAll(msg.sender, operator, approved);\r\n\t}\r\n\t\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external {\r\n\t\t_transfer(from, to, tokenId, msg.sender);\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external {\r\n\t\t_safeTransfer(from, to, tokenId, msg.sender);\r\n\t}\r\n\t\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external {\r\n\t\t_safeTransfer(from, to, tokenId, data, msg.sender);\r\n\t}\r\n\t\r\n\tfunction _checkSignature(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s, bytes32 typehash) internal {\r\n\t\trequire(deadline >= block.timestamp, \"ImpermaxERC721: EXPIRED\");\r\n\t\tbytes32 digest = keccak256(\r\n\t\t\tabi.encodePacked(\r\n\t\t\t\t'\\x19\\x01',\r\n\t\t\t\tDOMAIN_SEPARATOR,\r\n\t\t\t\tkeccak256(abi.encode(typehash, spender, tokenId, nonces[tokenId]++, deadline))\r\n\t\t\t)\r\n\t\t);\r\n\t\taddress owner = _requireOwned(tokenId);\r\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\r\n\t\trequire(recoveredAddress == owner, \"ImpermaxERC721: INVALID_SIGNATURE\");\t\r\n\t}\r\n\r\n\t// keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\r\n\tbytes32 public constant PERMIT_TYPEHASH = 0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\r\n\tfunction permit(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n\t\t_checkSignature(spender, tokenId, deadline, v, r, s, PERMIT_TYPEHASH);\r\n\t\t_approve(spender, tokenId, address(0));\r\n\t}\r\n\t\r\n\t/* Utilities */\r\n\tfunction isContract(address _addr) private view returns (bool){\r\n\t\tuint32 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (size > 0);\r\n\t}\r\n}\r\n\r\n// File: contracts\\interfaces\\IFactory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IFactory {\r\n\tevent LendingPoolInitialized(address indexed nftlp, address indexed token0, address indexed token1,\r\n\t\taddress collateral, address borrowable0, address borrowable1, uint lendingPoolId);\r\n\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\tevent NewAdmin(address oldAdmin, address newAdmin);\r\n\tevent NewReservesPendingAdmin(address oldReservesPendingAdmin, address newReservesPendingAdmin);\r\n\tevent NewReservesAdmin(address oldReservesAdmin, address newReservesAdmin);\r\n\tevent NewReservesManager(address oldReservesManager, address newReservesManager);\r\n\t\r\n\tfunction admin() external view returns (address);\r\n\tfunction pendingAdmin() external view returns (address);\r\n\tfunction reservesAdmin() external view returns (address);\r\n\tfunction reservesPendingAdmin() external view returns (address);\r\n\tfunction reservesManager() external view returns (address);\r\n\r\n\tfunction getLendingPool(address nftlp) external view returns (\r\n\t\tbool initialized, \r\n\t\tuint24 lendingPoolId, \r\n\t\taddress collateral, \r\n\t\taddress borrowable0, \r\n\t\taddress borrowable1\r\n\t);\r\n\tfunction allLendingPools(uint) external view returns (address nftlp);\r\n\tfunction allLendingPoolsLength() external view returns (uint);\r\n\t\r\n\tfunction bDeployer() external view returns (address);\r\n\tfunction cDeployer() external view returns (address);\r\n\r\n\tfunction createCollateral(address nftlp) external returns (address collateral);\r\n\tfunction createBorrowable0(address nftlp) external returns (address borrowable0);\r\n\tfunction createBorrowable1(address nftlp) external returns (address borrowable1);\r\n\tfunction initializeLendingPool(address nftlp) external;\r\n\r\n\tfunction _setPendingAdmin(address newPendingAdmin) external;\r\n\tfunction _acceptAdmin() external;\r\n\tfunction _setReservesPendingAdmin(address newPendingAdmin) external;\r\n\tfunction _acceptReservesAdmin() external;\r\n\tfunction _setReservesManager(address newReservesManager) external;\r\n}\r\n\r\n// File: contracts\\CSetter.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\ncontract CSetter is ImpermaxERC721, CStorage {\r\n\r\n\tuint public constant SAFETY_MARGIN_SQRT_MIN = 1.00e18; //safetyMargin: 100%\r\n\tuint public constant SAFETY_MARGIN_SQRT_MAX = 1.58113884e18; //safetyMargin: 250%\r\n\tuint public constant LIQUIDATION_INCENTIVE_MIN = 1.00e18; //100%\r\n\tuint public constant LIQUIDATION_INCENTIVE_MAX = 1.05e18; //105%\r\n\tuint public constant LIQUIDATION_FEE_MAX = 0.08e18; //8%\r\n\t\r\n\tevent NewSafetyMargin(uint newSafetyMarginSqrt);\r\n\tevent NewLiquidationIncentive(uint newLiquidationIncentive);\r\n\tevent NewLiquidationFee(uint newLiquidationFee);\r\n\r\n\t// called once by the factory\r\n\tfunction _setFactory() external {\r\n\t\trequire(factory == address(0), \"ImpermaxV3Collateral: FACTORY_ALREADY_SET\");\r\n\t\tfactory = msg.sender;\r\n\t}\r\n\t\r\n\tfunction _initialize (\r\n\t\tstring calldata _name,\r\n\t\tstring calldata _symbol,\r\n\t\taddress _underlying, \r\n\t\taddress _borrowable0, \r\n\t\taddress _borrowable1\r\n\t) external {\r\n\t\trequire(msg.sender == factory, \"ImpermaxV3Collateral: UNAUTHORIZED\"); // sufficient check\r\n\t\t_setName(_name, _symbol);\r\n\t\tunderlying = _underlying;\r\n\t\tborrowable0 = _borrowable0;\r\n\t\tborrowable1 = _borrowable1;\r\n\t}\r\n\r\n\tfunction _setSafetyMarginSqrt(uint newSafetyMarginSqrt) external nonReentrant {\r\n\t\t_checkSetting(newSafetyMarginSqrt, SAFETY_MARGIN_SQRT_MIN, SAFETY_MARGIN_SQRT_MAX);\r\n\t\tsafetyMarginSqrt = newSafetyMarginSqrt;\r\n\t\temit NewSafetyMargin(newSafetyMarginSqrt);\r\n\t}\r\n\r\n\tfunction _setLiquidationIncentive(uint newLiquidationIncentive) external nonReentrant {\r\n\t\t_checkSetting(newLiquidationIncentive, LIQUIDATION_INCENTIVE_MIN, LIQUIDATION_INCENTIVE_MAX);\r\n\t\tliquidationIncentive = newLiquidationIncentive;\r\n\t\temit NewLiquidationIncentive(newLiquidationIncentive);\r\n\t}\r\n\r\n\tfunction _setLiquidationFee(uint newLiquidationFee) external nonReentrant {\r\n\t\t_checkSetting(newLiquidationFee, 0, LIQUIDATION_FEE_MAX);\r\n\t\tliquidationFee = newLiquidationFee;\r\n\t\temit NewLiquidationFee(newLiquidationFee);\r\n\t}\r\n\t\r\n\tfunction _checkSetting(uint parameter, uint min, uint max) internal view {\r\n\t\t_checkAdmin();\r\n\t\trequire(parameter >= min, \"ImpermaxV3Collateral: INVALID_SETTING\");\r\n\t\trequire(parameter <= max, \"ImpermaxV3Collateral: INVALID_SETTING\");\r\n\t}\r\n\t\r\n\tfunction _checkAdmin() internal view {\r\n\t\trequire(msg.sender == IFactory(factory).admin(), \"ImpermaxV3Collateral: UNAUTHORIZED\");\r\n\t}\r\n\t\r\n\t/*** Utilities ***/\r\n\t\r\n\t// prevents a contract from calling itself, directly or indirectly.\r\n\tbool internal _notEntered = true;\r\n\tmodifier nonReentrant() {\r\n\t\trequire(_notEntered, \"ImpermaxV3Collateral: REENTERED\");\r\n\t\t_notEntered = false;\r\n\t\t_;\r\n\t\t_notEntered = true;\r\n\t}\r\n}\r\n\r\n// File: contracts\\interfaces\\IBorrowable.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IBorrowable {\r\n\r\n\t/*** Impermax ERC20 ***/\r\n\t\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\t\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction totalSupply() external view returns (uint);\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction nonces(address owner) external view returns (uint);\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t/*** Pool Token ***/\r\n\t\r\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\r\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\r\n\tevent Sync(uint totalBalance);\r\n\t\r\n\tfunction underlying() external view returns (address);\r\n\tfunction factory() external view returns (address);\r\n\tfunction totalBalance() external view returns (uint);\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n\tfunction exchangeRate() external returns (uint);\r\n\tfunction mint(address minter) external returns (uint mintTokens);\r\n\tfunction redeem(address redeemer) external returns (uint redeemAmount);\r\n\tfunction skim(address to) external;\r\n\tfunction sync() external;\r\n\t\r\n\tfunction _setFactory() external;\r\n\t\r\n\t/*** Borrowable ***/\r\n\r\n\tevent BorrowApproval(address indexed owner, address indexed spender, uint value);\r\n\tevent Borrow(address indexed sender, uint256 indexed tokenId, address indexed receiver, uint borrowAmount, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\r\n\tevent Liquidate(address indexed sender, uint256 indexed tokenId, address indexed liquidator, uint seizeTokenId, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\r\n\tevent RestructureDebt(uint256 indexed tokenId, uint reduceToRatio, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\r\n\t\r\n\tfunction collateral() external view returns (address);\r\n\tfunction reserveFactor() external view returns (uint);\r\n\tfunction exchangeRateLast() external view returns (uint);\r\n\tfunction borrowIndex() external view returns (uint);\r\n\tfunction totalBorrows() external view returns (uint);\r\n\tfunction borrowAllowance(address owner, address spender) external view returns (uint);\r\n\tfunction borrowBalance(uint tokenId) external view returns (uint);\t\r\n\tfunction currentBorrowBalance(uint tokenId) external returns (uint);\t\r\n\t\r\n\tfunction BORROW_PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction borrowApprove(address spender, uint256 value) external returns (bool);\r\n\tfunction borrowPermit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\tfunction borrow(uint256 tokenId, address receiver, uint borrowAmount, bytes calldata data) external;\r\n\tfunction liquidate(uint256 tokenId, uint repayAmount, address liquidator, bytes calldata data) external returns (uint seizeTokenId);\r\n\tfunction restructureDebt(uint256 tokenId, uint256 reduceToRatio) external;\r\n\t\r\n\t/*** Borrowable Interest Rate Model ***/\r\n\r\n\tevent AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\tevent CalculateKink(uint kinkRate);\r\n\tevent CalculateBorrowRate(uint borrowRate);\r\n\t\r\n\tfunction KINK_BORROW_RATE_MAX() external pure returns (uint);\r\n\tfunction KINK_BORROW_RATE_MIN() external pure returns (uint);\r\n\tfunction KINK_MULTIPLIER() external pure returns (uint);\r\n\tfunction borrowRate() external view returns (uint);\r\n\tfunction kinkBorrowRate() external view returns (uint);\r\n\tfunction kinkUtilizationRate() external view returns (uint);\r\n\tfunction adjustSpeed() external view returns (uint);\r\n\tfunction rateUpdateTimestamp() external view returns (uint32);\r\n\tfunction accrualTimestamp() external view returns (uint32);\r\n\t\r\n\tfunction accrueInterest() external;\r\n\t\r\n\t/*** Borrowable Setter ***/\r\n\r\n\tevent NewReserveFactor(uint newReserveFactor);\r\n\tevent NewKinkUtilizationRate(uint newKinkUtilizationRate);\r\n\tevent NewAdjustSpeed(uint newAdjustSpeed);\r\n\tevent NewDebtCeiling(uint newDebtCeiling);\r\n\r\n\tfunction RESERVE_FACTOR_MAX() external pure returns (uint);\r\n\tfunction KINK_UR_MIN() external pure returns (uint);\r\n\tfunction KINK_UR_MAX() external pure returns (uint);\r\n\tfunction ADJUST_SPEED_MIN() external pure returns (uint);\r\n\tfunction ADJUST_SPEED_MAX() external pure returns (uint);\r\n\t\r\n\tfunction _initialize (\r\n\t\tstring calldata _name, \r\n\t\tstring calldata _symbol,\r\n\t\taddress _underlying, \r\n\t\taddress _collateral\r\n\t) external;\r\n\tfunction _setReserveFactor(uint newReserveFactor) external;\r\n\tfunction _setKinkUtilizationRate(uint newKinkUtilizationRate) external;\r\n\tfunction _setAdjustSpeed(uint newAdjustSpeed) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\ICollateral.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ICollateral {\r\n\t\r\n\t/* ImpermaxERC721 */\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\t\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\t\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\tfunction setApprovalForAll(address operator, bool approved) external;\r\n\tfunction permit(address spender, uint tokenId, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t/* Collateral */\r\n\t\r\n\tevent Mint(address indexed to, uint tokenId);\r\n\tevent Redeem(address indexed to, uint tokenId, uint percentage, uint redeemTokenId);\r\n\tevent Seize(address indexed to, uint tokenId, uint percentage, uint redeemTokenId);\r\n\tevent RestructureBadDebt(uint tokenId, uint postLiquidationCollateralRatio);\r\n\t\r\n\tfunction underlying() external view returns (address);\r\n\tfunction factory() external view returns (address);\r\n\tfunction borrowable0() external view returns (address);\r\n\tfunction borrowable1() external view returns (address);\r\n\tfunction safetyMarginSqrt() external view returns (uint);\r\n\tfunction liquidationIncentive() external view returns (uint);\r\n\tfunction liquidationFee() external view returns (uint);\r\n\tfunction liquidationPenalty() external view returns (uint);\r\n\r\n\tfunction mint(address to, uint256 tokenId) external;\r\n\tfunction redeem(address to, uint256 tokenId, uint256 percentage, bytes calldata data) external returns (uint redeemTokenId);\r\n\tfunction redeem(address to, uint256 tokenId, uint256 percentage) external returns (uint redeemTokenId);\r\n\tfunction isLiquidatable(uint tokenId) external returns (bool);\r\n\tfunction isUnderwater(uint tokenId) external returns (bool);\r\n\tfunction canBorrow(uint tokenId, address borrowable, uint accountBorrows) external returns (bool);\r\n\tfunction restructureBadDebt(uint tokenId) external;\r\n\tfunction seize(uint tokenId, uint repayAmount, address liquidator, bytes calldata data) external returns (uint seizeTokenId);\r\n\t\r\n\t/* CSetter */\r\n\t\r\n\tevent NewSafetyMargin(uint newSafetyMarginSqrt);\r\n\tevent NewLiquidationIncentive(uint newLiquidationIncentive);\r\n\tevent NewLiquidationFee(uint newLiquidationFee);\r\n\r\n\tfunction SAFETY_MARGIN_SQRT_MIN() external pure returns (uint);\r\n\tfunction SAFETY_MARGIN_SQRT_MAX() external pure returns (uint);\r\n\tfunction LIQUIDATION_INCENTIVE_MIN() external pure returns (uint);\r\n\tfunction LIQUIDATION_INCENTIVE_MAX() external pure returns (uint);\r\n\tfunction LIQUIDATION_FEE_MAX() external pure returns (uint);\r\n\t\r\n\tfunction _setFactory() external;\r\n\tfunction _initialize (\r\n\t\tstring calldata _name,\r\n\t\tstring calldata _symbol,\r\n\t\taddress _underlying, \r\n\t\taddress _borrowable0, \r\n\t\taddress _borrowable1\r\n\t) external;\r\n\tfunction _setSafetyMarginSqrt(uint newSafetyMarginSqrt) external;\r\n\tfunction _setLiquidationIncentive(uint newLiquidationIncentive) external;\r\n\tfunction _setLiquidationFee(uint newLiquidationFee) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IImpermaxCallee.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IImpermaxCallee {\r\n    function impermaxV3Borrow(address sender, uint256 tokenId, uint borrowAmount, bytes calldata data) external;\r\n    function impermaxV3Redeem(address sender, uint256 tokenId, uint256 redeemTokenId, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\INFTLP.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface INFTLP {\r\n\tstruct RealXY {\r\n\t\tuint256 realX;\r\n\t\tuint256 realY;\r\n\t}\r\n\t\r\n\tstruct RealXYs {\r\n\t\tRealXY lowestPrice;\r\n\t\tRealXY currentPrice;\r\n\t\tRealXY highestPrice;\r\n\t}\r\n\t\r\n\t// ERC-721\r\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\t\r\n\t// Global state\r\n\tfunction token0() external view returns (address);\r\n\tfunction token1() external view returns (address);\r\n\t\r\n\t// Position state\r\n\tfunction getPositionData(uint256 _tokenId, uint256 _safetyMarginSqrt) external returns (\r\n\t\tuint256 priceSqrtX96,\r\n\t\tRealXYs memory realXYs\r\n\t);\r\n\t\r\n\t// Interactions\r\n\t\r\n\tfunction split(uint256 tokenId, uint256 percentage) external returns (uint256 newTokenId);\r\n\tfunction join(uint256 tokenId, uint256 tokenToJoin) external;\r\n}\r\n\r\n// File: contracts\\libraries\\CollateralMath.sol\r\n\r\npragma solidity =0.5.16;\r\nlibrary CollateralMath {\r\n\tusing SafeMath for uint;\r\n\r\n    uint constant Q64 = 2**64;\r\n    uint constant Q96 = 2**96;\r\n    uint constant Q192 = 2**192;\r\n\t\r\n\tenum Price {LOWEST, CURRENT, HIGHEST}\r\n\r\n\tstruct PositionObject {\r\n\t\tINFTLP.RealXYs realXYs;\r\n\t\tuint priceSqrtX96;\r\n\t\tuint debtX;\r\n\t\tuint debtY;\r\n\t\tuint liquidationPenalty;\r\n\t\tuint safetyMarginSqrt;\r\n\t}\r\n\t\r\n\tfunction newPosition(\r\n\t\tINFTLP.RealXYs memory realXYs,\r\n\t\tuint priceSqrtX96,\r\n\t\tuint debtX,\r\n\t\tuint debtY,\r\n\t\tuint liquidationPenalty,\r\n\t\tuint safetyMarginSqrt\r\n\t) internal pure returns (PositionObject memory) {\r\n\t\treturn PositionObject({\r\n\t\t\trealXYs: realXYs,\r\n\t\t\tpriceSqrtX96: priceSqrtX96,\r\n\t\t\tdebtX: debtX,\r\n\t\t\tdebtY: debtY,\r\n\t\t\tliquidationPenalty: liquidationPenalty,\r\n\t\t\tsafetyMarginSqrt: safetyMarginSqrt\r\n\t\t});\r\n\t}\r\n\t\r\n    function safeInt256(uint256 n) internal pure returns (int256) {\r\n        require(n < 2**255, \"Impermax: SAFE_INT\");\r\n        return int256(n);\r\n    }\r\n\t\r\n\t// price\r\n\tfunction getRelativePriceX(uint priceSqrtX96) internal pure returns (uint) {\r\n\t\treturn priceSqrtX96;\r\n\t}\r\n\t// 1 / price\r\n\tfunction getRelativePriceY(uint priceSqrtX96) internal pure returns (uint) {\r\n\t\treturn Q192.div(priceSqrtX96);\r\n\t}\r\n\t\r\n\t// amountX * priceX + amountY * priceY\r\n\tfunction getValue(PositionObject memory positionObject, Price price, uint amountX, uint amountY) internal pure returns (uint) {\r\n\t\tuint priceSqrtX96 = positionObject.priceSqrtX96;\r\n\t\tif (price == Price.LOWEST) priceSqrtX96 = priceSqrtX96.mul(1e18).div(positionObject.safetyMarginSqrt);\r\n\t\tif (price == Price.HIGHEST) priceSqrtX96 = priceSqrtX96.mul(positionObject.safetyMarginSqrt).div(1e18);\r\n\t\tuint relativePriceX = getRelativePriceX(priceSqrtX96);\r\n\t\tuint relativePriceY = getRelativePriceY(priceSqrtX96);\r\n\t\treturn amountX.mul(relativePriceX).div(Q64).add(amountY.mul(relativePriceY).div(Q64));\r\n\t}\r\n\t\r\n\t// realX * priceX + realY * priceY\r\n\tfunction getCollateralValue(PositionObject memory positionObject, Price price) internal pure returns (uint) {\r\n\t\tINFTLP.RealXY memory realXY = positionObject.realXYs.currentPrice;\r\n\t\tif (price == Price.LOWEST) realXY = positionObject.realXYs.lowestPrice;\r\n\t\tif (price == Price.HIGHEST) realXY = positionObject.realXYs.highestPrice;\r\n\t\treturn getValue(positionObject, price, realXY.realX, realXY.realY);\r\n\t}\r\n\r\n\t// debtX * priceX + realY * debtY\t\r\n\tfunction getDebtValue(PositionObject memory positionObject, Price price) internal pure returns (uint) {\r\n\t\treturn getValue(positionObject, price, positionObject.debtX, positionObject.debtY);\r\n\t}\r\n\t\r\n\t// collateralValue - debtValue * liquidationPenalty\r\n\tfunction getLiquidityPostLiquidation(PositionObject memory positionObject, Price price) internal pure returns (int) {\r\n\t\tuint collateralNeeded = getDebtValue(positionObject, price).mul(positionObject.liquidationPenalty).div(1e18);\r\n\t\tuint collateralValue = getCollateralValue(positionObject, price);\r\n\t\treturn safeInt256(collateralValue) - safeInt256(collateralNeeded);\r\n\t}\r\n\t\r\n\t// collateralValue / (debtValue * liquidationPenalty)\r\n\tfunction getPostLiquidationCollateralRatio(PositionObject memory positionObject) internal pure returns (uint) {\r\n\t\tuint collateralNeeded = getDebtValue(positionObject, Price.CURRENT).mul(positionObject.liquidationPenalty).div(1e18);\r\n\t\tuint collateralValue = getCollateralValue(positionObject, Price.CURRENT);\r\n\t\treturn collateralValue.mul(1e18).div(collateralNeeded, \"ImpermaxV3Collateral: NO_DEBT\");\r\n\t}\r\n\t\r\n\tfunction isLiquidatable(PositionObject memory positionObject) internal pure returns (bool) {\r\n\t\tint a = getLiquidityPostLiquidation(positionObject, Price.LOWEST);\r\n\t\tint b = getLiquidityPostLiquidation(positionObject, Price.HIGHEST);\r\n\t\treturn a < 0 || b < 0;\r\n\t}\r\n\t\r\n\tfunction isUnderwater(PositionObject memory positionObject) internal pure returns (bool) {\r\n\t\tint liquidity = getLiquidityPostLiquidation(positionObject, Price.CURRENT);\r\n\t\treturn liquidity < 0;\r\n\t}\r\n}\r\n\r\n// File: contracts\\ImpermaxV3Collateral.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ImpermaxV3Collateral is ICollateral, CSetter {\t\r\n\tusing CollateralMath for CollateralMath.PositionObject;\r\n\r\n    uint256 internal constant Q192 = 2**192;\r\n\r\n\tconstructor() public {}\r\n\t\r\n\t/*** Collateralization Model ***/\r\n\t\r\n\tfunction _getPositionObjectAmounts(uint tokenId, uint debtX, uint debtY) internal returns (CollateralMath.PositionObject memory positionObject) {\r\n\t\tif (debtX == uint(-1)) debtX = IBorrowable(borrowable0).currentBorrowBalance(tokenId);\r\n\t\tif (debtY == uint(-1)) debtY = IBorrowable(borrowable1).currentBorrowBalance(tokenId);\r\n\t\t\r\n\t\t(uint priceSqrtX96, INFTLP.RealXYs memory realXYs) = \r\n\t\t\tINFTLP(underlying).getPositionData(tokenId, safetyMarginSqrt);\r\n\t\trequire(priceSqrtX96 > 100 && priceSqrtX96 < Q192 / 100, \"ImpermaxV3Collateral: PRICE_CALCULATION_ERROR\");\r\n\t\t\r\n\t\tpositionObject = CollateralMath.newPosition(realXYs, priceSqrtX96, debtX, debtY, liquidationPenalty(), safetyMarginSqrt);\r\n\t}\r\n\t\r\n\tfunction _getPositionObject(uint tokenId) internal returns (CollateralMath.PositionObject memory positionObject) {\r\n\t\treturn _getPositionObjectAmounts(tokenId, uint(-1), uint(-1));\r\n\t}\r\n\t\r\n\t/*** ERC721 Wrapper ***/\r\n\t\r\n\tfunction mint(address to, uint256 tokenId) external nonReentrant {\r\n\t\trequire(_ownerOf[tokenId] == address(0), \"ImpermaxV3Collateral: NFT_ALREADY_MINTED\");\r\n\t\trequire(INFTLP(underlying).ownerOf(tokenId) == address(this), \"ImpermaxV3Collateral: NFT_NOT_RECEIVED\");\r\n\t\t_mint(to, tokenId);\r\n\t\temit Mint(to, tokenId);\r\n\t}\r\n\r\n\tfunction redeem(address to, uint256 tokenId, uint256 percentage, bytes memory data) public nonReentrant returns (uint256 redeemTokenId) {\r\n\t\trequire(percentage <= 1e18, \"ImpermaxV3Collateral: PERCENTAGE_ABOVE_100\");\r\n\t\t_checkAuthorized(_requireOwned(tokenId), msg.sender, tokenId);\r\n\t\t_approve(address(0), tokenId, address(0)); // reset approval\r\n\t\t\t\t\r\n\t\t// optimistically redeem\r\n\t\tif (percentage == 1e18) {\r\n\t\t\tredeemTokenId = tokenId;\r\n\t\t\t_burn(tokenId);\r\n\t\t\tINFTLP(underlying).safeTransferFrom(address(this), to, redeemTokenId);\r\n\t\t\tif (data.length > 0) IImpermaxCallee(to).impermaxV3Redeem(msg.sender, tokenId, redeemTokenId, data);\r\n\t\t\t\r\n\t\t\t// finally check that the position is not left underwater\r\n\t\t\trequire(IBorrowable(borrowable0).borrowBalance(tokenId) == 0, \"ImpermaxV3Collateral: INSUFFICIENT_LIQUIDITY\");\r\n\t\t\trequire(IBorrowable(borrowable1).borrowBalance(tokenId) == 0, \"ImpermaxV3Collateral: INSUFFICIENT_LIQUIDITY\");\r\n\t\t} else {\r\n\t\t\tredeemTokenId = INFTLP(underlying).split(tokenId, percentage);\r\n\t\t\tINFTLP(underlying).safeTransferFrom(address(this), to, redeemTokenId);\r\n\t\t\tif (data.length > 0) IImpermaxCallee(to).impermaxV3Redeem(msg.sender, tokenId, redeemTokenId, data);\r\n\t\t\t\r\n\t\t\t// finally check that the position is not left underwater\r\n\t\t\trequire(!isLiquidatable(tokenId), \"ImpermaxV3Collateral: INSUFFICIENT_LIQUIDITY\");\r\n\t\t}\r\n\t\t\r\n\t\temit Redeem(to, tokenId, percentage, redeemTokenId);\r\n\t}\r\n\tfunction redeem(address to, uint256 tokenId, uint256 percentage) external returns (uint256 redeemTokenId) {\r\n\t\treturn redeem(to, tokenId, percentage, \"\");\r\n\t}\r\n\t\r\n\t/*** Collateral ***/\r\n\t\r\n\tfunction isLiquidatable(uint tokenId) public returns (bool) {\r\n\t\tCollateralMath.PositionObject memory positionObject = _getPositionObject(tokenId);\r\n\t\treturn positionObject.isLiquidatable();\r\n\t}\r\n\t\r\n\tfunction isUnderwater(uint tokenId) public returns (bool) {\r\n\t\tCollateralMath.PositionObject memory positionObject = _getPositionObject(tokenId);\r\n\t\treturn positionObject.isUnderwater();\r\n\t}\r\n\t\r\n\tfunction canBorrow(uint tokenId, address borrowable, uint accountBorrows) public returns (bool) {\r\n\t\taddress _borrowable0 = borrowable0;\r\n\t\taddress _borrowable1 = borrowable1;\r\n\t\trequire(borrowable == _borrowable0 || borrowable == _borrowable1, \"ImpermaxV3Collateral: INVALID_BORROWABLE\");\r\n\t\trequire(INFTLP(underlying).ownerOf(tokenId) == address(this), \"ImpermaxV3Collateral: INVALID_NFTLP_ID\");\r\n\t\t\r\n\t\tuint debtX = borrowable == _borrowable0 ? accountBorrows : uint(-1);\r\n\t\tuint debtY = borrowable == _borrowable1 ? accountBorrows : uint(-1);\r\n\t\t\r\n\t\tCollateralMath.PositionObject memory positionObject = _getPositionObjectAmounts(tokenId, debtX, debtY);\r\n\t\treturn !positionObject.isLiquidatable();\r\n\t}\r\n\t\r\n\tfunction restructureBadDebt(uint tokenId) external nonReentrant {\r\n\t\tCollateralMath.PositionObject memory positionObject = _getPositionObject(tokenId);\r\n\t\tuint postLiquidationCollateralRatio = positionObject.getPostLiquidationCollateralRatio();\r\n\t\trequire(postLiquidationCollateralRatio < 1e18, \"ImpermaxV3Collateral: NOT_UNDERWATER\");\r\n\t\tIBorrowable(borrowable0).restructureDebt(tokenId, postLiquidationCollateralRatio);\r\n\t\tIBorrowable(borrowable1).restructureDebt(tokenId, postLiquidationCollateralRatio);\r\n\t\t\r\n\t\tblockOfLastRestructureOrLiquidation[tokenId] = block.number;\r\n\t\t\r\n\t\temit RestructureBadDebt(tokenId, postLiquidationCollateralRatio);\r\n\t}\r\n\t\r\n\t// this function must be called from borrowable0 or borrowable1\r\n\tfunction seize(uint tokenId, uint repayAmount, address liquidator, bytes calldata data) external nonReentrant returns (uint seizeTokenId) {\r\n\t\trequire(msg.sender == borrowable0 || msg.sender == borrowable1, \"ImpermaxV3Collateral: UNAUTHORIZED\");\r\n\t\t\r\n\t\tuint repayToCollateralRatio;\r\n\t\t{\r\n\t\t\tCollateralMath.PositionObject memory positionObject = _getPositionObject(tokenId);\r\n\t\t\t\r\n\t\t\tif (blockOfLastRestructureOrLiquidation[tokenId] != block.number) {\r\n\t\t\t\trequire(positionObject.isLiquidatable(), \"ImpermaxV3Collateral: INSUFFICIENT_SHORTFALL\");\r\n\t\t\t\trequire(!positionObject.isUnderwater(), \"ImpermaxV3Collateral: CANNOT_LIQUIDATE_UNDERWATER_POSITION\");\r\n\t\t\t\tblockOfLastRestructureOrLiquidation[tokenId] = block.number;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tuint collateralValue = positionObject.getCollateralValue(CollateralMath.Price.CURRENT);\r\n\t\t\tuint repayValue = msg.sender == borrowable0\r\n\t\t\t\t? positionObject.getValue(CollateralMath.Price.CURRENT, repayAmount, 0)\r\n\t\t\t\t: positionObject.getValue(CollateralMath.Price.CURRENT, 0, repayAmount);\r\n\t\t\t\r\n\t\t\trepayToCollateralRatio = repayValue.mul(1e18).div(collateralValue);\r\n\t\t\trequire(repayToCollateralRatio.mul(liquidationPenalty()) <= 1e36, \"ImpermaxV3Collateral: UNEXPECTED_RATIO\");\r\n\t\t}\r\n\t\t\r\n\t\tuint seizePercentage = repayToCollateralRatio.mul(liquidationIncentive).div(1e18);\r\n\t\tseizeTokenId = INFTLP(underlying).split(tokenId, seizePercentage);\r\n\r\n\t\taddress reservesManager = IFactory(factory).reservesManager();\t\t\r\n\t\tif (liquidationFee > 0) {\r\n\t\t\tuint feePercentage = repayToCollateralRatio.mul(liquidationFee).div(uint(1e18).sub(seizePercentage));\t\r\n\t\t\tuint feeTokenId = INFTLP(underlying).split(tokenId, feePercentage);\r\n\t\t\t_mint(reservesManager, feeTokenId); // _safeMint would be unsafe\r\n\t\t\temit Seize(reservesManager, tokenId, feePercentage, feeTokenId);\r\n\t\t}\r\n\t\t\r\n\t\tINFTLP(underlying).safeTransferFrom(address(this), liquidator, seizeTokenId, data);\r\n\t\temit Seize(liquidator, tokenId, seizePercentage, seizeTokenId);\r\n\t}\r\n\t\r\n\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external pure returns (bytes4 returnValue) {\r\n\t\toperator; from; tokenId; data;\r\n\t\treturn bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n\t}\r\n}\r\n\r\n// File: contracts\\interfaces\\ICDeployer.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ICDeployer {\r\n\tfunction deployCollateral(address nftlp) external returns (address collateral);\r\n}\r\n\r\n// File: contracts\\CDeployer.sol\r\n\r\npragma solidity =0.5.16;\r\n/*\r\n * This contract is used by the Factory to deploy Collateral(s)\r\n * The bytecode would be too long to fit in the Factory\r\n */\r\n \r\ncontract CDeployer is ICDeployer {\r\n\tconstructor () public {}\r\n\t\r\n\tfunction deployCollateral(address nftlp) external returns (address collateral) {\r\n\t\tbytes memory bytecode = type(ImpermaxV3Collateral).creationCode;\r\n\t\tbytes32 salt = keccak256(abi.encodePacked(msg.sender, nftlp));\r\n\t\tassembly {\r\n\t\t\tcollateral := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n\t\t}\r\n\t}\r\n}",
  "abi": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidationFee\",\"type\":\"uint256\"}],\"name\":\"NewLiquidationFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidationIncentive\",\"type\":\"uint256\"}],\"name\":\"NewLiquidationIncentive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSafetyMarginSqrt\",\"type\":\"uint256\"}],\"name\":\"NewSafetyMargin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokenId\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"postLiquidationCollateralRatio\",\"type\":\"uint256\"}],\"name\":\"RestructureBadDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokenId\",\"type\":\"uint256\"}],\"name\":\"Seize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUIDATION_FEE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUIDATION_INCENTIVE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUIDATION_INCENTIVE_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAFETY_MARGIN_SQRT_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAFETY_MARGIN_SQRT_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowable0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowable1\",\"type\":\"address\"}],\"name\":\"_initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_setFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidationFee\",\"type\":\"uint256\"}],\"name\":\"_setLiquidationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidationIncentive\",\"type\":\"uint256\"}],\"name\":\"_setLiquidationIncentive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSafetyMarginSqrt\",\"type\":\"uint256\"}],\"name\":\"_setSafetyMarginSqrt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blockOfLastRestructureOrLiquidation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowable0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowable1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"}],\"name\":\"canBorrow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isLiquidatable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isUnderwater\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationIncentive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"returnValue\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"restructureBadDebt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safetyMarginSqrt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"seize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seizeTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]",
  "contract_name": "ImpermaxV3Collateral",
  "compiler_version": "v0.5.16+commit.9c3226ce",
  "optimization_used": "1",
  "runs": "999999",
  "constructor_arguments": "",
  "evm_version": "Default",
  "library": "",
  "license_type": "BSL 1.1",
  "proxy": "0",
  "implementation": "",
  "bytecode": null
}